#![allow(non_camel_case_types)]
/* automatically generated by rust-bindgen 0.60.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const _CACHED_RUNES: u32 = 256;
pub const _CRMASK: i32 = -256;
pub const _RUNE_MAGIC_A: &[u8; 9usize] = b"RuneMagA\0";
pub const _CTYPE_A: u32 = 256;
pub const _CTYPE_C: u32 = 512;
pub const _CTYPE_D: u32 = 1024;
pub const _CTYPE_G: u32 = 2048;
pub const _CTYPE_L: u32 = 4096;
pub const _CTYPE_P: u32 = 8192;
pub const _CTYPE_S: u32 = 16384;
pub const _CTYPE_U: u32 = 32768;
pub const _CTYPE_X: u32 = 65536;
pub const _CTYPE_B: u32 = 131072;
pub const _CTYPE_R: u32 = 262144;
pub const _CTYPE_I: u32 = 524288;
pub const _CTYPE_T: u32 = 1048576;
pub const _CTYPE_Q: u32 = 2097152;
pub const _CTYPE_SW0: u32 = 536870912;
pub const _CTYPE_SW1: u32 = 1073741824;
pub const _CTYPE_SW2: u32 = 2147483648;
pub const _CTYPE_SW3: u32 = 3221225472;
pub const _CTYPE_SWM: u32 = 3758096384;
pub const _CTYPE_SWS: u32 = 30;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EDEADLK: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EAGAIN: u32 = 35;
pub const EWOULDBLOCK: u32 = 35;
pub const EINPROGRESS: u32 = 36;
pub const EALREADY: u32 = 37;
pub const ENOTSOCK: u32 = 38;
pub const EDESTADDRREQ: u32 = 39;
pub const EMSGSIZE: u32 = 40;
pub const EPROTOTYPE: u32 = 41;
pub const ENOPROTOOPT: u32 = 42;
pub const EPROTONOSUPPORT: u32 = 43;
pub const ESOCKTNOSUPPORT: u32 = 44;
pub const ENOTSUP: u32 = 45;
pub const EPFNOSUPPORT: u32 = 46;
pub const EAFNOSUPPORT: u32 = 47;
pub const EADDRINUSE: u32 = 48;
pub const EADDRNOTAVAIL: u32 = 49;
pub const ENETDOWN: u32 = 50;
pub const ENETUNREACH: u32 = 51;
pub const ENETRESET: u32 = 52;
pub const ECONNABORTED: u32 = 53;
pub const ECONNRESET: u32 = 54;
pub const ENOBUFS: u32 = 55;
pub const EISCONN: u32 = 56;
pub const ENOTCONN: u32 = 57;
pub const ESHUTDOWN: u32 = 58;
pub const ETOOMANYREFS: u32 = 59;
pub const ETIMEDOUT: u32 = 60;
pub const ECONNREFUSED: u32 = 61;
pub const ELOOP: u32 = 62;
pub const ENAMETOOLONG: u32 = 63;
pub const EHOSTDOWN: u32 = 64;
pub const EHOSTUNREACH: u32 = 65;
pub const ENOTEMPTY: u32 = 66;
pub const EPROCLIM: u32 = 67;
pub const EUSERS: u32 = 68;
pub const EDQUOT: u32 = 69;
pub const ESTALE: u32 = 70;
pub const EREMOTE: u32 = 71;
pub const EBADRPC: u32 = 72;
pub const ERPCMISMATCH: u32 = 73;
pub const EPROGUNAVAIL: u32 = 74;
pub const EPROGMISMATCH: u32 = 75;
pub const EPROCUNAVAIL: u32 = 76;
pub const ENOLCK: u32 = 77;
pub const ENOSYS: u32 = 78;
pub const EFTYPE: u32 = 79;
pub const EAUTH: u32 = 80;
pub const ENEEDAUTH: u32 = 81;
pub const EPWROFF: u32 = 82;
pub const EDEVERR: u32 = 83;
pub const EOVERFLOW: u32 = 84;
pub const EBADEXEC: u32 = 85;
pub const EBADARCH: u32 = 86;
pub const ESHLIBVERS: u32 = 87;
pub const EBADMACHO: u32 = 88;
pub const ECANCELED: u32 = 89;
pub const EIDRM: u32 = 90;
pub const ENOMSG: u32 = 91;
pub const EILSEQ: u32 = 92;
pub const ENOATTR: u32 = 93;
pub const EBADMSG: u32 = 94;
pub const EMULTIHOP: u32 = 95;
pub const ENODATA: u32 = 96;
pub const ENOLINK: u32 = 97;
pub const ENOSR: u32 = 98;
pub const ENOSTR: u32 = 99;
pub const EPROTO: u32 = 100;
pub const ETIME: u32 = 101;
pub const EOPNOTSUPP: u32 = 102;
pub const ENOPOLICY: u32 = 103;
pub const ENOTRECOVERABLE: u32 = 104;
pub const EOWNERDEAD: u32 = 105;
pub const EQFULL: u32 = 106;
pub const ELAST: u32 = 106;
pub const __PRI_8_LENGTH_MODIFIER__: &[u8; 3usize] = b"hh\0";
pub const __PRI_64_LENGTH_MODIFIER__: &[u8; 3usize] = b"ll\0";
pub const __SCN_64_LENGTH_MODIFIER__: &[u8; 3usize] = b"ll\0";
pub const __PRI_MAX_LENGTH_MODIFIER__: &[u8; 2usize] = b"j\0";
pub const __SCN_MAX_LENGTH_MODIFIER__: &[u8; 2usize] = b"j\0";
pub const PRId8: &[u8; 4usize] = b"hhd\0";
pub const PRIi8: &[u8; 4usize] = b"hhi\0";
pub const PRIo8: &[u8; 4usize] = b"hho\0";
pub const PRIu8: &[u8; 4usize] = b"hhu\0";
pub const PRIx8: &[u8; 4usize] = b"hhx\0";
pub const PRIX8: &[u8; 4usize] = b"hhX\0";
pub const PRId16: &[u8; 3usize] = b"hd\0";
pub const PRIi16: &[u8; 3usize] = b"hi\0";
pub const PRIo16: &[u8; 3usize] = b"ho\0";
pub const PRIu16: &[u8; 3usize] = b"hu\0";
pub const PRIx16: &[u8; 3usize] = b"hx\0";
pub const PRIX16: &[u8; 3usize] = b"hX\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRId64: &[u8; 4usize] = b"lld\0";
pub const PRIi64: &[u8; 4usize] = b"lli\0";
pub const PRIo64: &[u8; 4usize] = b"llo\0";
pub const PRIu64: &[u8; 4usize] = b"llu\0";
pub const PRIx64: &[u8; 4usize] = b"llx\0";
pub const PRIX64: &[u8; 4usize] = b"llX\0";
pub const PRIdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const PRIiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const PRIoLEAST8: &[u8; 4usize] = b"hho\0";
pub const PRIuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const PRIxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const PRIXLEAST8: &[u8; 4usize] = b"hhX\0";
pub const PRIdLEAST16: &[u8; 3usize] = b"hd\0";
pub const PRIiLEAST16: &[u8; 3usize] = b"hi\0";
pub const PRIoLEAST16: &[u8; 3usize] = b"ho\0";
pub const PRIuLEAST16: &[u8; 3usize] = b"hu\0";
pub const PRIxLEAST16: &[u8; 3usize] = b"hx\0";
pub const PRIXLEAST16: &[u8; 3usize] = b"hX\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIdLEAST64: &[u8; 4usize] = b"lld\0";
pub const PRIiLEAST64: &[u8; 4usize] = b"lli\0";
pub const PRIoLEAST64: &[u8; 4usize] = b"llo\0";
pub const PRIuLEAST64: &[u8; 4usize] = b"llu\0";
pub const PRIxLEAST64: &[u8; 4usize] = b"llx\0";
pub const PRIXLEAST64: &[u8; 4usize] = b"llX\0";
pub const PRIdFAST8: &[u8; 4usize] = b"hhd\0";
pub const PRIiFAST8: &[u8; 4usize] = b"hhi\0";
pub const PRIoFAST8: &[u8; 4usize] = b"hho\0";
pub const PRIuFAST8: &[u8; 4usize] = b"hhu\0";
pub const PRIxFAST8: &[u8; 4usize] = b"hhx\0";
pub const PRIXFAST8: &[u8; 4usize] = b"hhX\0";
pub const PRIdFAST16: &[u8; 3usize] = b"hd\0";
pub const PRIiFAST16: &[u8; 3usize] = b"hi\0";
pub const PRIoFAST16: &[u8; 3usize] = b"ho\0";
pub const PRIuFAST16: &[u8; 3usize] = b"hu\0";
pub const PRIxFAST16: &[u8; 3usize] = b"hx\0";
pub const PRIXFAST16: &[u8; 3usize] = b"hX\0";
pub const PRIdFAST32: &[u8; 2usize] = b"d\0";
pub const PRIiFAST32: &[u8; 2usize] = b"i\0";
pub const PRIoFAST32: &[u8; 2usize] = b"o\0";
pub const PRIuFAST32: &[u8; 2usize] = b"u\0";
pub const PRIxFAST32: &[u8; 2usize] = b"x\0";
pub const PRIXFAST32: &[u8; 2usize] = b"X\0";
pub const PRIdFAST64: &[u8; 4usize] = b"lld\0";
pub const PRIiFAST64: &[u8; 4usize] = b"lli\0";
pub const PRIoFAST64: &[u8; 4usize] = b"llo\0";
pub const PRIuFAST64: &[u8; 4usize] = b"llu\0";
pub const PRIxFAST64: &[u8; 4usize] = b"llx\0";
pub const PRIXFAST64: &[u8; 4usize] = b"llX\0";
pub const PRIdPTR: &[u8; 3usize] = b"ld\0";
pub const PRIiPTR: &[u8; 3usize] = b"li\0";
pub const PRIoPTR: &[u8; 3usize] = b"lo\0";
pub const PRIuPTR: &[u8; 3usize] = b"lu\0";
pub const PRIxPTR: &[u8; 3usize] = b"lx\0";
pub const PRIXPTR: &[u8; 3usize] = b"lX\0";
pub const PRIdMAX: &[u8; 3usize] = b"jd\0";
pub const PRIiMAX: &[u8; 3usize] = b"ji\0";
pub const PRIoMAX: &[u8; 3usize] = b"jo\0";
pub const PRIuMAX: &[u8; 3usize] = b"ju\0";
pub const PRIxMAX: &[u8; 3usize] = b"jx\0";
pub const PRIXMAX: &[u8; 3usize] = b"jX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNd64: &[u8; 4usize] = b"lld\0";
pub const SCNi64: &[u8; 4usize] = b"lli\0";
pub const SCNo64: &[u8; 4usize] = b"llo\0";
pub const SCNu64: &[u8; 4usize] = b"llu\0";
pub const SCNx64: &[u8; 4usize] = b"llx\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNdLEAST64: &[u8; 4usize] = b"lld\0";
pub const SCNiLEAST64: &[u8; 4usize] = b"lli\0";
pub const SCNoLEAST64: &[u8; 4usize] = b"llo\0";
pub const SCNuLEAST64: &[u8; 4usize] = b"llu\0";
pub const SCNxLEAST64: &[u8; 4usize] = b"llx\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNdFAST16: &[u8; 3usize] = b"hd\0";
pub const SCNiFAST16: &[u8; 3usize] = b"hi\0";
pub const SCNoFAST16: &[u8; 3usize] = b"ho\0";
pub const SCNuFAST16: &[u8; 3usize] = b"hu\0";
pub const SCNxFAST16: &[u8; 3usize] = b"hx\0";
pub const SCNdFAST32: &[u8; 2usize] = b"d\0";
pub const SCNiFAST32: &[u8; 2usize] = b"i\0";
pub const SCNoFAST32: &[u8; 2usize] = b"o\0";
pub const SCNuFAST32: &[u8; 2usize] = b"u\0";
pub const SCNxFAST32: &[u8; 2usize] = b"x\0";
pub const SCNdFAST64: &[u8; 4usize] = b"lld\0";
pub const SCNiFAST64: &[u8; 4usize] = b"lli\0";
pub const SCNoFAST64: &[u8; 4usize] = b"llo\0";
pub const SCNuFAST64: &[u8; 4usize] = b"llu\0";
pub const SCNxFAST64: &[u8; 4usize] = b"llx\0";
pub const SCNdPTR: &[u8; 3usize] = b"ld\0";
pub const SCNiPTR: &[u8; 3usize] = b"li\0";
pub const SCNoPTR: &[u8; 3usize] = b"lo\0";
pub const SCNuPTR: &[u8; 3usize] = b"lu\0";
pub const SCNxPTR: &[u8; 3usize] = b"lx\0";
pub const SCNdMAX: &[u8; 3usize] = b"jd\0";
pub const SCNiMAX: &[u8; 3usize] = b"ji\0";
pub const SCNoMAX: &[u8; 3usize] = b"jo\0";
pub const SCNuMAX: &[u8; 3usize] = b"ju\0";
pub const SCNxMAX: &[u8; 3usize] = b"jx\0";
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 120300;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 1048576;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const __GNUC_VA_LIST: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_ctermid: u32 = 1024;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_CURRENT: u32 = 5;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const __HAS_FIXED_CHK_PROTOTYPES: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const KEV_INET_SUBCLASS: u32 = 1;
pub const KEV_INET_NEW_ADDR: u32 = 1;
pub const KEV_INET_CHANGED_ADDR: u32 = 2;
pub const KEV_INET_ADDR_DELETED: u32 = 3;
pub const KEV_INET_SIFDSTADDR: u32 = 4;
pub const KEV_INET_SIFBRDADDR: u32 = 5;
pub const KEV_INET_SIFNETMASK: u32 = 6;
pub const KEV_INET_ARPCOLLISION: u32 = 7;
pub const KEV_INET_PORTINUSE: u32 = 8;
pub const KEV_INET_ARPRTRFAILURE: u32 = 9;
pub const KEV_INET_ARPRTRALIVE: u32 = 10;
pub const KEV_DL_SUBCLASS: u32 = 2;
pub const KEV_DL_SIFFLAGS: u32 = 1;
pub const KEV_DL_SIFMETRICS: u32 = 2;
pub const KEV_DL_SIFMTU: u32 = 3;
pub const KEV_DL_SIFPHYS: u32 = 4;
pub const KEV_DL_SIFMEDIA: u32 = 5;
pub const KEV_DL_SIFGENERIC: u32 = 6;
pub const KEV_DL_ADDMULTI: u32 = 7;
pub const KEV_DL_DELMULTI: u32 = 8;
pub const KEV_DL_IF_ATTACHED: u32 = 9;
pub const KEV_DL_IF_DETACHING: u32 = 10;
pub const KEV_DL_IF_DETACHED: u32 = 11;
pub const KEV_DL_LINK_OFF: u32 = 12;
pub const KEV_DL_LINK_ON: u32 = 13;
pub const KEV_DL_PROTO_ATTACHED: u32 = 14;
pub const KEV_DL_PROTO_DETACHED: u32 = 15;
pub const KEV_DL_LINK_ADDRESS_CHANGED: u32 = 16;
pub const KEV_DL_WAKEFLAGS_CHANGED: u32 = 17;
pub const KEV_DL_IF_IDLE_ROUTE_REFCNT: u32 = 18;
pub const KEV_DL_IFCAP_CHANGED: u32 = 19;
pub const KEV_DL_LINK_QUALITY_METRIC_CHANGED: u32 = 20;
pub const KEV_DL_NODE_PRESENCE: u32 = 21;
pub const KEV_DL_NODE_ABSENCE: u32 = 22;
pub const KEV_DL_PRIMARY_ELECTED: u32 = 23;
pub const KEV_DL_ISSUES: u32 = 24;
pub const KEV_DL_IFDELEGATE_CHANGED: u32 = 25;
pub const KEV_DL_AWDL_RESTRICTED: u32 = 26;
pub const KEV_DL_AWDL_UNRESTRICTED: u32 = 27;
pub const KEV_DL_RRC_STATE_CHANGED: u32 = 28;
pub const KEV_DL_QOS_MODE_CHANGED: u32 = 29;
pub const KEV_DL_LOW_POWER_MODE_CHANGED: u32 = 30;
pub const KEV_INET6_SUBCLASS: u32 = 6;
pub const KEV_INET6_NEW_USER_ADDR: u32 = 1;
pub const KEV_INET6_CHANGED_ADDR: u32 = 2;
pub const KEV_INET6_ADDR_DELETED: u32 = 3;
pub const KEV_INET6_NEW_LL_ADDR: u32 = 4;
pub const KEV_INET6_NEW_RTADV_ADDR: u32 = 5;
pub const KEV_INET6_DEFROUTER: u32 = 6;
pub const KEV_INET6_REQUEST_NAT64_PREFIX: u32 = 7;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const SOCK_RAW: u32 = 3;
pub const SOCK_RDM: u32 = 4;
pub const SOCK_SEQPACKET: u32 = 5;
pub const SO_DEBUG: u32 = 1;
pub const SO_ACCEPTCONN: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_BROADCAST: u32 = 32;
pub const SO_USELOOPBACK: u32 = 64;
pub const SO_LINGER: u32 = 128;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_REUSEPORT: u32 = 512;
pub const SO_TIMESTAMP: u32 = 1024;
pub const SO_TIMESTAMP_MONOTONIC: u32 = 2048;
pub const SO_DONTTRUNC: u32 = 8192;
pub const SO_WANTMORE: u32 = 16384;
pub const SO_WANTOOBFLAG: u32 = 32768;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_SNDTIMEO: u32 = 4101;
pub const SO_RCVTIMEO: u32 = 4102;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SO_LABEL: u32 = 4112;
pub const SO_PEERLABEL: u32 = 4113;
pub const SO_NREAD: u32 = 4128;
pub const SO_NKE: u32 = 4129;
pub const SO_NOSIGPIPE: u32 = 4130;
pub const SO_NOADDRERR: u32 = 4131;
pub const SO_NWRITE: u32 = 4132;
pub const SO_REUSESHAREUID: u32 = 4133;
pub const SO_NOTIFYCONFLICT: u32 = 4134;
pub const SO_UPCALLCLOSEWAIT: u32 = 4135;
pub const SO_LINGER_SEC: u32 = 4224;
pub const SO_RANDOMPORT: u32 = 4226;
pub const SO_NP_EXTENSIONS: u32 = 4227;
pub const SO_NUMRCVPKT: u32 = 4370;
pub const SO_NET_SERVICE_TYPE: u32 = 4374;
pub const SO_NETSVC_MARKING_LEVEL: u32 = 4377;
pub const NET_SERVICE_TYPE_BE: u32 = 0;
pub const NET_SERVICE_TYPE_BK: u32 = 1;
pub const NET_SERVICE_TYPE_SIG: u32 = 2;
pub const NET_SERVICE_TYPE_VI: u32 = 3;
pub const NET_SERVICE_TYPE_VO: u32 = 4;
pub const NET_SERVICE_TYPE_RV: u32 = 5;
pub const NET_SERVICE_TYPE_AV: u32 = 6;
pub const NET_SERVICE_TYPE_OAM: u32 = 7;
pub const NET_SERVICE_TYPE_RD: u32 = 8;
pub const NETSVC_MRKNG_UNKNOWN: u32 = 0;
pub const NETSVC_MRKNG_LVL_L2: u32 = 1;
pub const NETSVC_MRKNG_LVL_L3L2_ALL: u32 = 2;
pub const NETSVC_MRKNG_LVL_L3L2_BK: u32 = 3;
pub const SAE_ASSOCID_ANY: u32 = 0;
pub const SAE_CONNID_ANY: u32 = 0;
pub const CONNECT_RESUME_ON_READ_WRITE: u32 = 1;
pub const CONNECT_DATA_IDEMPOTENT: u32 = 2;
pub const CONNECT_DATA_AUTHENTICATED: u32 = 4;
pub const SONPX_SETOPTSHUT: u32 = 1;
pub const SOL_SOCKET: u32 = 65535;
pub const AF_UNSPEC: u32 = 0;
pub const AF_UNIX: u32 = 1;
pub const AF_LOCAL: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_IMPLINK: u32 = 3;
pub const AF_PUP: u32 = 4;
pub const AF_CHAOS: u32 = 5;
pub const AF_NS: u32 = 6;
pub const AF_ISO: u32 = 7;
pub const AF_OSI: u32 = 7;
pub const AF_ECMA: u32 = 8;
pub const AF_DATAKIT: u32 = 9;
pub const AF_CCITT: u32 = 10;
pub const AF_SNA: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_DLI: u32 = 13;
pub const AF_LAT: u32 = 14;
pub const AF_HYLINK: u32 = 15;
pub const AF_APPLETALK: u32 = 16;
pub const AF_ROUTE: u32 = 17;
pub const AF_LINK: u32 = 18;
pub const pseudo_AF_XTP: u32 = 19;
pub const AF_COIP: u32 = 20;
pub const AF_CNT: u32 = 21;
pub const pseudo_AF_RTIP: u32 = 22;
pub const AF_IPX: u32 = 23;
pub const AF_SIP: u32 = 24;
pub const pseudo_AF_PIP: u32 = 25;
pub const AF_NDRV: u32 = 27;
pub const AF_ISDN: u32 = 28;
pub const AF_E164: u32 = 28;
pub const pseudo_AF_KEY: u32 = 29;
pub const AF_INET6: u32 = 30;
pub const AF_NATM: u32 = 31;
pub const AF_SYSTEM: u32 = 32;
pub const AF_NETBIOS: u32 = 33;
pub const AF_PPP: u32 = 34;
pub const pseudo_AF_HDRCMPLT: u32 = 35;
pub const AF_RESERVED_36: u32 = 36;
pub const AF_IEEE80211: u32 = 37;
pub const AF_UTUN: u32 = 38;
pub const AF_VSOCK: u32 = 40;
pub const AF_MAX: u32 = 41;
pub const SOCK_MAXADDRLEN: u32 = 255;
pub const _SS_MAXSIZE: u32 = 128;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_IMPLINK: u32 = 3;
pub const PF_PUP: u32 = 4;
pub const PF_CHAOS: u32 = 5;
pub const PF_NS: u32 = 6;
pub const PF_ISO: u32 = 7;
pub const PF_OSI: u32 = 7;
pub const PF_ECMA: u32 = 8;
pub const PF_DATAKIT: u32 = 9;
pub const PF_CCITT: u32 = 10;
pub const PF_SNA: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_DLI: u32 = 13;
pub const PF_LAT: u32 = 14;
pub const PF_HYLINK: u32 = 15;
pub const PF_APPLETALK: u32 = 16;
pub const PF_ROUTE: u32 = 17;
pub const PF_LINK: u32 = 18;
pub const PF_XTP: u32 = 19;
pub const PF_COIP: u32 = 20;
pub const PF_CNT: u32 = 21;
pub const PF_SIP: u32 = 24;
pub const PF_IPX: u32 = 23;
pub const PF_RTIP: u32 = 22;
pub const PF_PIP: u32 = 25;
pub const PF_NDRV: u32 = 27;
pub const PF_ISDN: u32 = 28;
pub const PF_KEY: u32 = 29;
pub const PF_INET6: u32 = 30;
pub const PF_NATM: u32 = 31;
pub const PF_SYSTEM: u32 = 32;
pub const PF_NETBIOS: u32 = 33;
pub const PF_PPP: u32 = 34;
pub const PF_RESERVED_36: u32 = 36;
pub const PF_UTUN: u32 = 38;
pub const PF_VSOCK: u32 = 40;
pub const PF_MAX: u32 = 41;
pub const NET_MAXID: u32 = 41;
pub const NET_RT_DUMP: u32 = 1;
pub const NET_RT_FLAGS: u32 = 2;
pub const NET_RT_IFLIST: u32 = 3;
pub const NET_RT_STAT: u32 = 4;
pub const NET_RT_TRASH: u32 = 5;
pub const NET_RT_IFLIST2: u32 = 6;
pub const NET_RT_DUMP2: u32 = 7;
pub const NET_RT_FLAGS_PRIV: u32 = 10;
pub const NET_RT_MAXID: u32 = 11;
pub const SOMAXCONN: u32 = 128;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_EOR: u32 = 8;
pub const MSG_TRUNC: u32 = 16;
pub const MSG_CTRUNC: u32 = 32;
pub const MSG_WAITALL: u32 = 64;
pub const MSG_DONTWAIT: u32 = 128;
pub const MSG_EOF: u32 = 256;
pub const MSG_WAITSTREAM: u32 = 512;
pub const MSG_FLUSH: u32 = 1024;
pub const MSG_HOLD: u32 = 2048;
pub const MSG_SEND: u32 = 4096;
pub const MSG_HAVEMORE: u32 = 8192;
pub const MSG_RCVMORE: u32 = 16384;
pub const MSG_NEEDSA: u32 = 65536;
pub const MSG_NOSIGNAL: u32 = 524288;
pub const SCM_RIGHTS: u32 = 1;
pub const SCM_TIMESTAMP: u32 = 2;
pub const SCM_CREDS: u32 = 3;
pub const SCM_TIMESTAMP_MONOTONIC: u32 = 4;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_HOPOPTS: u32 = 0;
pub const IPPROTO_ICMP: u32 = 1;
pub const IPPROTO_IGMP: u32 = 2;
pub const IPPROTO_GGP: u32 = 3;
pub const IPPROTO_IPV4: u32 = 4;
pub const IPPROTO_IPIP: u32 = 4;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_ST: u32 = 7;
pub const IPPROTO_EGP: u32 = 8;
pub const IPPROTO_PIGP: u32 = 9;
pub const IPPROTO_RCCMON: u32 = 10;
pub const IPPROTO_NVPII: u32 = 11;
pub const IPPROTO_PUP: u32 = 12;
pub const IPPROTO_ARGUS: u32 = 13;
pub const IPPROTO_EMCON: u32 = 14;
pub const IPPROTO_XNET: u32 = 15;
pub const IPPROTO_CHAOS: u32 = 16;
pub const IPPROTO_UDP: u32 = 17;
pub const IPPROTO_MUX: u32 = 18;
pub const IPPROTO_MEAS: u32 = 19;
pub const IPPROTO_HMP: u32 = 20;
pub const IPPROTO_PRM: u32 = 21;
pub const IPPROTO_IDP: u32 = 22;
pub const IPPROTO_TRUNK1: u32 = 23;
pub const IPPROTO_TRUNK2: u32 = 24;
pub const IPPROTO_LEAF1: u32 = 25;
pub const IPPROTO_LEAF2: u32 = 26;
pub const IPPROTO_RDP: u32 = 27;
pub const IPPROTO_IRTP: u32 = 28;
pub const IPPROTO_TP: u32 = 29;
pub const IPPROTO_BLT: u32 = 30;
pub const IPPROTO_NSP: u32 = 31;
pub const IPPROTO_INP: u32 = 32;
pub const IPPROTO_SEP: u32 = 33;
pub const IPPROTO_3PC: u32 = 34;
pub const IPPROTO_IDPR: u32 = 35;
pub const IPPROTO_XTP: u32 = 36;
pub const IPPROTO_DDP: u32 = 37;
pub const IPPROTO_CMTP: u32 = 38;
pub const IPPROTO_TPXX: u32 = 39;
pub const IPPROTO_IL: u32 = 40;
pub const IPPROTO_IPV6: u32 = 41;
pub const IPPROTO_SDRP: u32 = 42;
pub const IPPROTO_ROUTING: u32 = 43;
pub const IPPROTO_FRAGMENT: u32 = 44;
pub const IPPROTO_IDRP: u32 = 45;
pub const IPPROTO_RSVP: u32 = 46;
pub const IPPROTO_GRE: u32 = 47;
pub const IPPROTO_MHRP: u32 = 48;
pub const IPPROTO_BHA: u32 = 49;
pub const IPPROTO_ESP: u32 = 50;
pub const IPPROTO_AH: u32 = 51;
pub const IPPROTO_INLSP: u32 = 52;
pub const IPPROTO_SWIPE: u32 = 53;
pub const IPPROTO_NHRP: u32 = 54;
pub const IPPROTO_ICMPV6: u32 = 58;
pub const IPPROTO_NONE: u32 = 59;
pub const IPPROTO_DSTOPTS: u32 = 60;
pub const IPPROTO_AHIP: u32 = 61;
pub const IPPROTO_CFTP: u32 = 62;
pub const IPPROTO_HELLO: u32 = 63;
pub const IPPROTO_SATEXPAK: u32 = 64;
pub const IPPROTO_KRYPTOLAN: u32 = 65;
pub const IPPROTO_RVD: u32 = 66;
pub const IPPROTO_IPPC: u32 = 67;
pub const IPPROTO_ADFS: u32 = 68;
pub const IPPROTO_SATMON: u32 = 69;
pub const IPPROTO_VISA: u32 = 70;
pub const IPPROTO_IPCV: u32 = 71;
pub const IPPROTO_CPNX: u32 = 72;
pub const IPPROTO_CPHB: u32 = 73;
pub const IPPROTO_WSN: u32 = 74;
pub const IPPROTO_PVP: u32 = 75;
pub const IPPROTO_BRSATMON: u32 = 76;
pub const IPPROTO_ND: u32 = 77;
pub const IPPROTO_WBMON: u32 = 78;
pub const IPPROTO_WBEXPAK: u32 = 79;
pub const IPPROTO_EON: u32 = 80;
pub const IPPROTO_VMTP: u32 = 81;
pub const IPPROTO_SVMTP: u32 = 82;
pub const IPPROTO_VINES: u32 = 83;
pub const IPPROTO_TTP: u32 = 84;
pub const IPPROTO_IGP: u32 = 85;
pub const IPPROTO_DGP: u32 = 86;
pub const IPPROTO_TCF: u32 = 87;
pub const IPPROTO_IGRP: u32 = 88;
pub const IPPROTO_OSPFIGP: u32 = 89;
pub const IPPROTO_SRPC: u32 = 90;
pub const IPPROTO_LARP: u32 = 91;
pub const IPPROTO_MTP: u32 = 92;
pub const IPPROTO_AX25: u32 = 93;
pub const IPPROTO_IPEIP: u32 = 94;
pub const IPPROTO_MICP: u32 = 95;
pub const IPPROTO_SCCSP: u32 = 96;
pub const IPPROTO_ETHERIP: u32 = 97;
pub const IPPROTO_ENCAP: u32 = 98;
pub const IPPROTO_APES: u32 = 99;
pub const IPPROTO_GMTP: u32 = 100;
pub const IPPROTO_PIM: u32 = 103;
pub const IPPROTO_IPCOMP: u32 = 108;
pub const IPPROTO_PGM: u32 = 113;
pub const IPPROTO_SCTP: u32 = 132;
pub const IPPROTO_DIVERT: u32 = 254;
pub const IPPROTO_RAW: u32 = 255;
pub const IPPROTO_MAX: u32 = 256;
pub const IPPROTO_DONE: u32 = 257;
pub const __DARWIN_IPPORT_RESERVED: u32 = 1024;
pub const IPPORT_RESERVED: u32 = 1024;
pub const IPPORT_USERRESERVED: u32 = 5000;
pub const IPPORT_HIFIRSTAUTO: u32 = 49152;
pub const IPPORT_HILASTAUTO: u32 = 65535;
pub const IPPORT_RESERVEDSTART: u32 = 600;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_CLASSD_NET: u32 = 4026531840;
pub const IN_CLASSD_NSHIFT: u32 = 28;
pub const IN_CLASSD_HOST: u32 = 268435455;
pub const INADDR_NONE: u32 = 4294967295;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const IP_OPTIONS: u32 = 1;
pub const IP_HDRINCL: u32 = 2;
pub const IP_TOS: u32 = 3;
pub const IP_TTL: u32 = 4;
pub const IP_RECVOPTS: u32 = 5;
pub const IP_RECVRETOPTS: u32 = 6;
pub const IP_RECVDSTADDR: u32 = 7;
pub const IP_RETOPTS: u32 = 8;
pub const IP_MULTICAST_IF: u32 = 9;
pub const IP_MULTICAST_TTL: u32 = 10;
pub const IP_MULTICAST_LOOP: u32 = 11;
pub const IP_ADD_MEMBERSHIP: u32 = 12;
pub const IP_DROP_MEMBERSHIP: u32 = 13;
pub const IP_MULTICAST_VIF: u32 = 14;
pub const IP_RSVP_ON: u32 = 15;
pub const IP_RSVP_OFF: u32 = 16;
pub const IP_RSVP_VIF_ON: u32 = 17;
pub const IP_RSVP_VIF_OFF: u32 = 18;
pub const IP_PORTRANGE: u32 = 19;
pub const IP_RECVIF: u32 = 20;
pub const IP_IPSEC_POLICY: u32 = 21;
pub const IP_FAITH: u32 = 22;
pub const IP_STRIPHDR: u32 = 23;
pub const IP_RECVTTL: u32 = 24;
pub const IP_BOUND_IF: u32 = 25;
pub const IP_PKTINFO: u32 = 26;
pub const IP_RECVPKTINFO: u32 = 26;
pub const IP_RECVTOS: u32 = 27;
pub const IP_DONTFRAG: u32 = 28;
pub const IP_FW_ADD: u32 = 40;
pub const IP_FW_DEL: u32 = 41;
pub const IP_FW_FLUSH: u32 = 42;
pub const IP_FW_ZERO: u32 = 43;
pub const IP_FW_GET: u32 = 44;
pub const IP_FW_RESETLOG: u32 = 45;
pub const IP_OLD_FW_ADD: u32 = 50;
pub const IP_OLD_FW_DEL: u32 = 51;
pub const IP_OLD_FW_FLUSH: u32 = 52;
pub const IP_OLD_FW_ZERO: u32 = 53;
pub const IP_OLD_FW_GET: u32 = 54;
pub const IP_NAT__XXX: u32 = 55;
pub const IP_OLD_FW_RESETLOG: u32 = 56;
pub const IP_DUMMYNET_CONFIGURE: u32 = 60;
pub const IP_DUMMYNET_DEL: u32 = 61;
pub const IP_DUMMYNET_FLUSH: u32 = 62;
pub const IP_DUMMYNET_GET: u32 = 64;
pub const IP_TRAFFIC_MGT_BACKGROUND: u32 = 65;
pub const IP_MULTICAST_IFINDEX: u32 = 66;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 70;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 71;
pub const IP_BLOCK_SOURCE: u32 = 72;
pub const IP_UNBLOCK_SOURCE: u32 = 73;
pub const IP_MSFILTER: u32 = 74;
pub const MCAST_JOIN_GROUP: u32 = 80;
pub const MCAST_LEAVE_GROUP: u32 = 81;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 82;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 83;
pub const MCAST_BLOCK_SOURCE: u32 = 84;
pub const MCAST_UNBLOCK_SOURCE: u32 = 85;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MIN_MEMBERSHIPS: u32 = 31;
pub const IP_MAX_MEMBERSHIPS: u32 = 4095;
pub const IP_MAX_GROUP_SRC_FILTER: u32 = 512;
pub const IP_MAX_SOCK_SRC_FILTER: u32 = 128;
pub const IP_MAX_SOCK_MUTE_FILTER: u32 = 128;
pub const MCAST_UNDEFINED: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const MCAST_EXCLUDE: u32 = 2;
pub const IP_PORTRANGE_DEFAULT: u32 = 0;
pub const IP_PORTRANGE_HIGH: u32 = 1;
pub const IP_PORTRANGE_LOW: u32 = 2;
pub const IPPROTO_MAXID: u32 = 52;
pub const IPCTL_FORWARDING: u32 = 1;
pub const IPCTL_SENDREDIRECTS: u32 = 2;
pub const IPCTL_DEFTTL: u32 = 3;
pub const IPCTL_RTEXPIRE: u32 = 5;
pub const IPCTL_RTMINEXPIRE: u32 = 6;
pub const IPCTL_RTMAXCACHE: u32 = 7;
pub const IPCTL_SOURCEROUTE: u32 = 8;
pub const IPCTL_DIRECTEDBROADCAST: u32 = 9;
pub const IPCTL_INTRQMAXLEN: u32 = 10;
pub const IPCTL_INTRQDROPS: u32 = 11;
pub const IPCTL_STATS: u32 = 12;
pub const IPCTL_ACCEPTSOURCEROUTE: u32 = 13;
pub const IPCTL_FASTFORWARDING: u32 = 14;
pub const IPCTL_KEEPFAITH: u32 = 15;
pub const IPCTL_GIF_TTL: u32 = 16;
pub const IPCTL_MAXID: u32 = 17;
pub const __KAME_VERSION: &[u8; 18usize] = b"2009/apple-darwin\0";
pub const IPV6PORT_RESERVED: u32 = 1024;
pub const IPV6PORT_ANONMIN: u32 = 49152;
pub const IPV6PORT_ANONMAX: u32 = 65535;
pub const IPV6PORT_RESERVEDMIN: u32 = 600;
pub const IPV6PORT_RESERVEDMAX: u32 = 1023;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const __IPV6_ADDR_SCOPE_NODELOCAL: u32 = 1;
pub const __IPV6_ADDR_SCOPE_INTFACELOCAL: u32 = 1;
pub const __IPV6_ADDR_SCOPE_LINKLOCAL: u32 = 2;
pub const __IPV6_ADDR_SCOPE_SITELOCAL: u32 = 5;
pub const __IPV6_ADDR_SCOPE_ORGLOCAL: u32 = 8;
pub const __IPV6_ADDR_SCOPE_GLOBAL: u32 = 14;
pub const IPV6_ADDR_MC_FLAGS_TRANSIENT: u32 = 16;
pub const IPV6_ADDR_MC_FLAGS_PREFIX: u32 = 32;
pub const IPV6_ADDR_MC_FLAGS_UNICAST_BASED: u32 = 48;
pub const IPV6_SOCKOPT_RESERVED1: u32 = 3;
pub const IPV6_UNICAST_HOPS: u32 = 4;
pub const IPV6_MULTICAST_IF: u32 = 9;
pub const IPV6_MULTICAST_HOPS: u32 = 10;
pub const IPV6_MULTICAST_LOOP: u32 = 11;
pub const IPV6_JOIN_GROUP: u32 = 12;
pub const IPV6_LEAVE_GROUP: u32 = 13;
pub const IPV6_PORTRANGE: u32 = 14;
pub const ICMP6_FILTER: u32 = 18;
pub const IPV6_2292PKTINFO: u32 = 19;
pub const IPV6_2292HOPLIMIT: u32 = 20;
pub const IPV6_2292NEXTHOP: u32 = 21;
pub const IPV6_2292HOPOPTS: u32 = 22;
pub const IPV6_2292DSTOPTS: u32 = 23;
pub const IPV6_2292RTHDR: u32 = 24;
pub const IPV6_2292PKTOPTIONS: u32 = 25;
pub const IPV6_CHECKSUM: u32 = 26;
pub const IPV6_V6ONLY: u32 = 27;
pub const IPV6_BINDV6ONLY: u32 = 27;
pub const IPV6_IPSEC_POLICY: u32 = 28;
pub const IPV6_FAITH: u32 = 29;
pub const IPV6_FW_ADD: u32 = 30;
pub const IPV6_FW_DEL: u32 = 31;
pub const IPV6_FW_FLUSH: u32 = 32;
pub const IPV6_FW_ZERO: u32 = 33;
pub const IPV6_FW_GET: u32 = 34;
pub const IPV6_RECVTCLASS: u32 = 35;
pub const IPV6_TCLASS: u32 = 36;
pub const IPV6_BOUND_IF: u32 = 125;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IPV6_DEFAULT_MULTICAST_HOPS: u32 = 1;
pub const IPV6_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IPV6_MIN_MEMBERSHIPS: u32 = 31;
pub const IPV6_MAX_MEMBERSHIPS: u32 = 4095;
pub const IPV6_MAX_GROUP_SRC_FILTER: u32 = 512;
pub const IPV6_MAX_SOCK_SRC_FILTER: u32 = 128;
pub const IPV6_PORTRANGE_DEFAULT: u32 = 0;
pub const IPV6_PORTRANGE_HIGH: u32 = 1;
pub const IPV6_PORTRANGE_LOW: u32 = 2;
pub const IPV6PROTO_MAXID: u32 = 104;
pub const IPV6CTL_FORWARDING: u32 = 1;
pub const IPV6CTL_SENDREDIRECTS: u32 = 2;
pub const IPV6CTL_DEFHLIM: u32 = 3;
pub const IPV6CTL_FORWSRCRT: u32 = 5;
pub const IPV6CTL_STATS: u32 = 6;
pub const IPV6CTL_MRTSTATS: u32 = 7;
pub const IPV6CTL_MRTPROTO: u32 = 8;
pub const IPV6CTL_MAXFRAGPACKETS: u32 = 9;
pub const IPV6CTL_SOURCECHECK: u32 = 10;
pub const IPV6CTL_SOURCECHECK_LOGINT: u32 = 11;
pub const IPV6CTL_ACCEPT_RTADV: u32 = 12;
pub const IPV6CTL_KEEPFAITH: u32 = 13;
pub const IPV6CTL_LOG_INTERVAL: u32 = 14;
pub const IPV6CTL_HDRNESTLIMIT: u32 = 15;
pub const IPV6CTL_DAD_COUNT: u32 = 16;
pub const IPV6CTL_AUTO_FLOWLABEL: u32 = 17;
pub const IPV6CTL_DEFMCASTHLIM: u32 = 18;
pub const IPV6CTL_GIF_HLIM: u32 = 19;
pub const IPV6CTL_KAME_VERSION: u32 = 20;
pub const IPV6CTL_USE_DEPRECATED: u32 = 21;
pub const IPV6CTL_RR_PRUNE: u32 = 22;
pub const IPV6CTL_V6ONLY: u32 = 24;
pub const IPV6CTL_RTEXPIRE: u32 = 25;
pub const IPV6CTL_RTMINEXPIRE: u32 = 26;
pub const IPV6CTL_RTMAXCACHE: u32 = 27;
pub const IPV6CTL_USETEMPADDR: u32 = 32;
pub const IPV6CTL_TEMPPLTIME: u32 = 33;
pub const IPV6CTL_TEMPVLTIME: u32 = 34;
pub const IPV6CTL_AUTO_LINKLOCAL: u32 = 35;
pub const IPV6CTL_RIP6STATS: u32 = 36;
pub const IPV6CTL_PREFER_TEMPADDR: u32 = 37;
pub const IPV6CTL_ADDRCTLPOLICY: u32 = 38;
pub const IPV6CTL_USE_DEFAULTZONE: u32 = 39;
pub const IPV6CTL_MAXFRAGS: u32 = 41;
pub const IPV6CTL_MCAST_PMTU: u32 = 44;
pub const IPV6CTL_NEIGHBORGCTHRESH: u32 = 46;
pub const IPV6CTL_MAXIFPREFIXES: u32 = 47;
pub const IPV6CTL_MAXIFDEFROUTERS: u32 = 48;
pub const IPV6CTL_MAXDYNROUTES: u32 = 49;
pub const ICMPV6CTL_ND6_ONLINKNSRFC4861: u32 = 50;
pub const IPV6CTL_ULA_USETEMPADDR: u32 = 51;
pub const IPV6CTL_MAXID: u32 = 51;
pub const __DARWIN_MAXNAMLEN: u32 = 255;
pub const __DARWIN_MAXPATHLEN: u32 = 1024;
pub const MAXNAMLEN: u32 = 255;
pub const DT_UNKNOWN: u32 = 0;
pub const DT_FIFO: u32 = 1;
pub const DT_CHR: u32 = 2;
pub const DT_DIR: u32 = 4;
pub const DT_BLK: u32 = 6;
pub const DT_REG: u32 = 8;
pub const DT_LNK: u32 = 10;
pub const DT_SOCK: u32 = 12;
pub const DT_WHT: u32 = 14;
pub const DIRBLKSIZ: u32 = 1024;
pub const DTF_HIDEW: u32 = 1;
pub const DTF_NODUP: u32 = 2;
pub const DTF_REWIND: u32 = 4;
pub const __DTF_READALL: u32 = 8;
pub const __DTF_SKIPREAD: u32 = 16;
pub const __DTF_ATEND: u32 = 32;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_ACCMODE: u32 = 3;
pub const FREAD: u32 = 1;
pub const FWRITE: u32 = 2;
pub const O_NONBLOCK: u32 = 4;
pub const O_APPEND: u32 = 8;
pub const O_SYNC: u32 = 128;
pub const O_SHLOCK: u32 = 16;
pub const O_EXLOCK: u32 = 32;
pub const O_ASYNC: u32 = 64;
pub const O_FSYNC: u32 = 128;
pub const O_NOFOLLOW: u32 = 256;
pub const O_CREAT: u32 = 512;
pub const O_TRUNC: u32 = 1024;
pub const O_EXCL: u32 = 2048;
pub const O_EVTONLY: u32 = 32768;
pub const O_NOCTTY: u32 = 131072;
pub const O_DIRECTORY: u32 = 1048576;
pub const O_SYMLINK: u32 = 2097152;
pub const O_DSYNC: u32 = 4194304;
pub const O_CLOEXEC: u32 = 16777216;
pub const O_NOFOLLOW_ANY: u32 = 536870912;
pub const AT_FDCWD: i32 = -2;
pub const AT_EACCESS: u32 = 16;
pub const AT_SYMLINK_NOFOLLOW: u32 = 32;
pub const AT_SYMLINK_FOLLOW: u32 = 64;
pub const AT_REMOVEDIR: u32 = 128;
pub const AT_REALDEV: u32 = 512;
pub const AT_FDONLY: u32 = 1024;
pub const AT_SYMLINK_NOFOLLOW_ANY: u32 = 2048;
pub const O_DP_GETRAWENCRYPTED: u32 = 1;
pub const O_DP_GETRAWUNENCRYPTED: u32 = 2;
pub const FAPPEND: u32 = 8;
pub const FASYNC: u32 = 64;
pub const FFSYNC: u32 = 128;
pub const FFDSYNC: u32 = 4194304;
pub const FNONBLOCK: u32 = 4;
pub const FNDELAY: u32 = 4;
pub const O_NDELAY: u32 = 4;
pub const CPF_OVERWRITE: u32 = 1;
pub const CPF_IGNORE_MODE: u32 = 2;
pub const CPF_MASK: u32 = 3;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const F_GETOWN: u32 = 5;
pub const F_SETOWN: u32 = 6;
pub const F_GETLK: u32 = 7;
pub const F_SETLK: u32 = 8;
pub const F_SETLKW: u32 = 9;
pub const F_SETLKWTIMEOUT: u32 = 10;
pub const F_FLUSH_DATA: u32 = 40;
pub const F_CHKCLEAN: u32 = 41;
pub const F_PREALLOCATE: u32 = 42;
pub const F_SETSIZE: u32 = 43;
pub const F_RDADVISE: u32 = 44;
pub const F_RDAHEAD: u32 = 45;
pub const F_NOCACHE: u32 = 48;
pub const F_LOG2PHYS: u32 = 49;
pub const F_GETPATH: u32 = 50;
pub const F_FULLFSYNC: u32 = 51;
pub const F_PATHPKG_CHECK: u32 = 52;
pub const F_FREEZE_FS: u32 = 53;
pub const F_THAW_FS: u32 = 54;
pub const F_GLOBAL_NOCACHE: u32 = 55;
pub const F_ADDSIGS: u32 = 59;
pub const F_ADDFILESIGS: u32 = 61;
pub const F_NODIRECT: u32 = 62;
pub const F_GETPROTECTIONCLASS: u32 = 63;
pub const F_SETPROTECTIONCLASS: u32 = 64;
pub const F_LOG2PHYS_EXT: u32 = 65;
pub const F_GETLKPID: u32 = 66;
pub const F_SETBACKINGSTORE: u32 = 70;
pub const F_GETPATH_MTMINFO: u32 = 71;
pub const F_GETCODEDIR: u32 = 72;
pub const F_SETNOSIGPIPE: u32 = 73;
pub const F_GETNOSIGPIPE: u32 = 74;
pub const F_TRANSCODEKEY: u32 = 75;
pub const F_SINGLE_WRITER: u32 = 76;
pub const F_GETPROTECTIONLEVEL: u32 = 77;
pub const F_FINDSIGS: u32 = 78;
pub const F_ADDFILESIGS_FOR_DYLD_SIM: u32 = 83;
pub const F_BARRIERFSYNC: u32 = 85;
pub const F_ADDFILESIGS_RETURN: u32 = 97;
pub const F_CHECK_LV: u32 = 98;
pub const F_PUNCHHOLE: u32 = 99;
pub const F_TRIM_ACTIVE_FILE: u32 = 100;
pub const F_SPECULATIVE_READ: u32 = 101;
pub const F_GETPATH_NOFIRMLINK: u32 = 102;
pub const F_ADDFILESIGS_INFO: u32 = 103;
pub const F_ADDFILESUPPL: u32 = 104;
pub const F_GETSIGSINFO: u32 = 105;
pub const F_FSRESERVED: u32 = 106;
pub const FCNTL_FS_SPECIFIC_BASE: u32 = 65536;
pub const F_DUPFD_CLOEXEC: u32 = 67;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_WRLCK: u32 = 3;
pub const SEEK_HOLE: u32 = 3;
pub const SEEK_DATA: u32 = 4;
pub const S_IFMT: u32 = 61440;
pub const S_IFIFO: u32 = 4096;
pub const S_IFCHR: u32 = 8192;
pub const S_IFDIR: u32 = 16384;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_IFWHT: u32 = 57344;
pub const S_IRWXU: u32 = 448;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXG: u32 = 56;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXO: u32 = 7;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_ISTXT: u32 = 512;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const F_ALLOCATECONTIG: u32 = 2;
pub const F_ALLOCATEALL: u32 = 4;
pub const F_PEOFPOSMODE: u32 = 3;
pub const F_VOLPOSMODE: u32 = 4;
pub const USER_FSIGNATURES_CDHASH_LEN: u32 = 20;
pub const GETSIGSINFO_PLATFORM_BINARY: u32 = 1;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const O_POPUP: u32 = 2147483648;
pub const O_ALERT: u32 = 536870912;
pub const API_TO_BE_DEPRECATED: u32 = 100000;
pub const _PATH_HEQUIV: &[u8; 17usize] = b"/etc/hosts.equiv\0";
pub const _PATH_HOSTS: &[u8; 11usize] = b"/etc/hosts\0";
pub const _PATH_NETWORKS: &[u8; 14usize] = b"/etc/networks\0";
pub const _PATH_PROTOCOLS: &[u8; 15usize] = b"/etc/protocols\0";
pub const _PATH_SERVICES: &[u8; 14usize] = b"/etc/services\0";
pub const NETDB_INTERNAL: i32 = -1;
pub const NETDB_SUCCESS: u32 = 0;
pub const HOST_NOT_FOUND: u32 = 1;
pub const TRY_AGAIN: u32 = 2;
pub const NO_RECOVERY: u32 = 3;
pub const NO_DATA: u32 = 4;
pub const NO_ADDRESS: u32 = 4;
pub const EAI_ADDRFAMILY: u32 = 1;
pub const EAI_AGAIN: u32 = 2;
pub const EAI_BADFLAGS: u32 = 3;
pub const EAI_FAIL: u32 = 4;
pub const EAI_FAMILY: u32 = 5;
pub const EAI_MEMORY: u32 = 6;
pub const EAI_NODATA: u32 = 7;
pub const EAI_NONAME: u32 = 8;
pub const EAI_SERVICE: u32 = 9;
pub const EAI_SOCKTYPE: u32 = 10;
pub const EAI_SYSTEM: u32 = 11;
pub const EAI_BADHINTS: u32 = 12;
pub const EAI_PROTOCOL: u32 = 13;
pub const EAI_OVERFLOW: u32 = 14;
pub const EAI_MAX: u32 = 15;
pub const AI_PASSIVE: u32 = 1;
pub const AI_CANONNAME: u32 = 2;
pub const AI_NUMERICHOST: u32 = 4;
pub const AI_NUMERICSERV: u32 = 4096;
pub const AI_ALL: u32 = 256;
pub const AI_V4MAPPED_CFG: u32 = 512;
pub const AI_ADDRCONFIG: u32 = 1024;
pub const AI_V4MAPPED: u32 = 2048;
pub const AI_DEFAULT: u32 = 1536;
pub const AI_UNUSABLE: u32 = 268435456;
pub const NI_MAXHOST: u32 = 1025;
pub const NI_MAXSERV: u32 = 32;
pub const NI_NOFQDN: u32 = 1;
pub const NI_NUMERICHOST: u32 = 2;
pub const NI_NAMEREQD: u32 = 4;
pub const NI_NUMERICSERV: u32 = 8;
pub const NI_NUMERICSCOPE: u32 = 256;
pub const NI_DGRAM: u32 = 16;
pub const NI_WITHSCOPEID: u32 = 32;
pub const SCOPE_DELIMITER: u8 = 37u8;
pub const POLLIN: u32 = 1;
pub const POLLPRI: u32 = 2;
pub const POLLOUT: u32 = 4;
pub const POLLRDNORM: u32 = 64;
pub const POLLWRNORM: u32 = 4;
pub const POLLRDBAND: u32 = 128;
pub const POLLWRBAND: u32 = 256;
pub const POLLEXTEND: u32 = 512;
pub const POLLATTRIB: u32 = 1024;
pub const POLLNLINK: u32 = 2048;
pub const POLLWRITE: u32 = 4096;
pub const POLLERR: u32 = 8;
pub const POLLHUP: u32 = 16;
pub const POLLNVAL: u32 = 32;
pub const POLLSTANDARD: u32 = 511;
pub const _PTHREAD_MUTEX_SIG_init: u32 = 850045863;
pub const _PTHREAD_ERRORCHECK_MUTEX_SIG_init: u32 = 850045857;
pub const _PTHREAD_RECURSIVE_MUTEX_SIG_init: u32 = 850045858;
pub const _PTHREAD_FIRSTFIT_MUTEX_SIG_init: u32 = 850045859;
pub const _PTHREAD_COND_SIG_init: u32 = 1018212795;
pub const _PTHREAD_ONCE_SIG_init: u32 = 816954554;
pub const _PTHREAD_RWLOCK_SIG_init: u32 = 766030772;
pub const SCHED_OTHER: u32 = 1;
pub const SCHED_FIFO: u32 = 4;
pub const SCHED_RR: u32 = 2;
pub const __SCHED_PARAM_SIZE__: u32 = 4;
pub const QOS_MIN_RELATIVE_PRIORITY: i32 = -15;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const PTHREAD_CREATE_DETACHED: u32 = 2;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CANCEL_ENABLE: u32 = 1;
pub const PTHREAD_CANCEL_DISABLE: u32 = 0;
pub const PTHREAD_CANCEL_DEFERRED: u32 = 2;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_SCOPE_PROCESS: u32 = 2;
pub const PTHREAD_PROCESS_SHARED: u32 = 1;
pub const PTHREAD_PROCESS_PRIVATE: u32 = 2;
pub const PTHREAD_PRIO_NONE: u32 = 0;
pub const PTHREAD_PRIO_INHERIT: u32 = 1;
pub const PTHREAD_PRIO_PROTECT: u32 = 2;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 1;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 0;
pub const PTHREAD_MUTEX_POLICY_FAIRSHARE_NP: u32 = 1;
pub const PTHREAD_MUTEX_POLICY_FIRSTFIT_NP: u32 = 3;
pub const SEM_VALUE_MAX: u32 = 32767;
pub const _PATH_LOG: &[u8; 16usize] = b"/var/run/syslog\0";
pub const LOG_EMERG: u32 = 0;
pub const LOG_ALERT: u32 = 1;
pub const LOG_CRIT: u32 = 2;
pub const LOG_ERR: u32 = 3;
pub const LOG_WARNING: u32 = 4;
pub const LOG_NOTICE: u32 = 5;
pub const LOG_INFO: u32 = 6;
pub const LOG_DEBUG: u32 = 7;
pub const LOG_PRIMASK: u32 = 7;
pub const LOG_KERN: u32 = 0;
pub const LOG_USER: u32 = 8;
pub const LOG_MAIL: u32 = 16;
pub const LOG_DAEMON: u32 = 24;
pub const LOG_AUTH: u32 = 32;
pub const LOG_SYSLOG: u32 = 40;
pub const LOG_LPR: u32 = 48;
pub const LOG_NEWS: u32 = 56;
pub const LOG_UUCP: u32 = 64;
pub const LOG_CRON: u32 = 72;
pub const LOG_AUTHPRIV: u32 = 80;
pub const LOG_FTP: u32 = 88;
pub const LOG_NETINFO: u32 = 96;
pub const LOG_REMOTEAUTH: u32 = 104;
pub const LOG_INSTALL: u32 = 112;
pub const LOG_RAS: u32 = 120;
pub const LOG_LOCAL0: u32 = 128;
pub const LOG_LOCAL1: u32 = 136;
pub const LOG_LOCAL2: u32 = 144;
pub const LOG_LOCAL3: u32 = 152;
pub const LOG_LOCAL4: u32 = 160;
pub const LOG_LOCAL5: u32 = 168;
pub const LOG_LOCAL6: u32 = 176;
pub const LOG_LOCAL7: u32 = 184;
pub const LOG_LAUNCHD: u32 = 192;
pub const LOG_NFACILITIES: u32 = 25;
pub const LOG_FACMASK: u32 = 1016;
pub const LOG_PID: u32 = 1;
pub const LOG_CONS: u32 = 2;
pub const LOG_ODELAY: u32 = 4;
pub const LOG_NDELAY: u32 = 8;
pub const LOG_NOWAIT: u32 = 16;
pub const LOG_PERROR: u32 = 32;
pub const VEOF: u32 = 0;
pub const VEOL: u32 = 1;
pub const VEOL2: u32 = 2;
pub const VERASE: u32 = 3;
pub const VWERASE: u32 = 4;
pub const VKILL: u32 = 5;
pub const VREPRINT: u32 = 6;
pub const VINTR: u32 = 8;
pub const VQUIT: u32 = 9;
pub const VSUSP: u32 = 10;
pub const VDSUSP: u32 = 11;
pub const VSTART: u32 = 12;
pub const VSTOP: u32 = 13;
pub const VLNEXT: u32 = 14;
pub const VDISCARD: u32 = 15;
pub const VMIN: u32 = 16;
pub const VTIME: u32 = 17;
pub const VSTATUS: u32 = 18;
pub const NCCS: u32 = 20;
pub const IGNBRK: u32 = 1;
pub const BRKINT: u32 = 2;
pub const IGNPAR: u32 = 4;
pub const PARMRK: u32 = 8;
pub const INPCK: u32 = 16;
pub const ISTRIP: u32 = 32;
pub const INLCR: u32 = 64;
pub const IGNCR: u32 = 128;
pub const ICRNL: u32 = 256;
pub const IXON: u32 = 512;
pub const IXOFF: u32 = 1024;
pub const IXANY: u32 = 2048;
pub const IMAXBEL: u32 = 8192;
pub const IUTF8: u32 = 16384;
pub const OPOST: u32 = 1;
pub const ONLCR: u32 = 2;
pub const OXTABS: u32 = 4;
pub const ONOEOT: u32 = 8;
pub const OCRNL: u32 = 16;
pub const ONOCR: u32 = 32;
pub const ONLRET: u32 = 64;
pub const OFILL: u32 = 128;
pub const NLDLY: u32 = 768;
pub const TABDLY: u32 = 3076;
pub const CRDLY: u32 = 12288;
pub const FFDLY: u32 = 16384;
pub const BSDLY: u32 = 32768;
pub const VTDLY: u32 = 65536;
pub const OFDEL: u32 = 131072;
pub const NL0: u32 = 0;
pub const NL1: u32 = 256;
pub const NL2: u32 = 512;
pub const NL3: u32 = 768;
pub const TAB0: u32 = 0;
pub const TAB1: u32 = 1024;
pub const TAB2: u32 = 2048;
pub const TAB3: u32 = 4;
pub const CR0: u32 = 0;
pub const CR1: u32 = 4096;
pub const CR2: u32 = 8192;
pub const CR3: u32 = 12288;
pub const FF0: u32 = 0;
pub const FF1: u32 = 16384;
pub const BS0: u32 = 0;
pub const BS1: u32 = 32768;
pub const VT0: u32 = 0;
pub const VT1: u32 = 65536;
pub const CIGNORE: u32 = 1;
pub const CSIZE: u32 = 768;
pub const CS5: u32 = 0;
pub const CS6: u32 = 256;
pub const CS7: u32 = 512;
pub const CS8: u32 = 768;
pub const CSTOPB: u32 = 1024;
pub const CREAD: u32 = 2048;
pub const PARENB: u32 = 4096;
pub const PARODD: u32 = 8192;
pub const HUPCL: u32 = 16384;
pub const CLOCAL: u32 = 32768;
pub const CCTS_OFLOW: u32 = 65536;
pub const CRTS_IFLOW: u32 = 131072;
pub const CDTR_IFLOW: u32 = 262144;
pub const CDSR_OFLOW: u32 = 524288;
pub const CCAR_OFLOW: u32 = 1048576;
pub const MDMBUF: u32 = 1048576;
pub const ECHOKE: u32 = 1;
pub const ECHOE: u32 = 2;
pub const ECHOK: u32 = 4;
pub const ECHO: u32 = 8;
pub const ECHONL: u32 = 16;
pub const ECHOPRT: u32 = 32;
pub const ECHOCTL: u32 = 64;
pub const ISIG: u32 = 128;
pub const ICANON: u32 = 256;
pub const ALTWERASE: u32 = 512;
pub const IEXTEN: u32 = 1024;
pub const EXTPROC: u32 = 2048;
pub const TOSTOP: u32 = 4194304;
pub const FLUSHO: u32 = 8388608;
pub const NOKERNINFO: u32 = 33554432;
pub const PENDIN: u32 = 536870912;
pub const NOFLSH: u32 = 2147483648;
pub const TCSANOW: u32 = 0;
pub const TCSADRAIN: u32 = 1;
pub const TCSAFLUSH: u32 = 2;
pub const TCSASOFT: u32 = 16;
pub const B0: u32 = 0;
pub const B50: u32 = 50;
pub const B75: u32 = 75;
pub const B110: u32 = 110;
pub const B134: u32 = 134;
pub const B150: u32 = 150;
pub const B200: u32 = 200;
pub const B300: u32 = 300;
pub const B600: u32 = 600;
pub const B1200: u32 = 1200;
pub const B1800: u32 = 1800;
pub const B2400: u32 = 2400;
pub const B4800: u32 = 4800;
pub const B9600: u32 = 9600;
pub const B19200: u32 = 19200;
pub const B38400: u32 = 38400;
pub const B7200: u32 = 7200;
pub const B14400: u32 = 14400;
pub const B28800: u32 = 28800;
pub const B57600: u32 = 57600;
pub const B76800: u32 = 76800;
pub const B115200: u32 = 115200;
pub const B230400: u32 = 230400;
pub const EXTA: u32 = 19200;
pub const EXTB: u32 = 38400;
pub const TCIFLUSH: u32 = 1;
pub const TCOFLUSH: u32 = 2;
pub const TCIOFLUSH: u32 = 3;
pub const TCOOFF: u32 = 1;
pub const TCOON: u32 = 2;
pub const TCIOFF: u32 = 3;
pub const TCION: u32 = 4;
pub const IOCPARM_MASK: u32 = 8191;
pub const IOCPARM_MAX: u32 = 8192;
pub const TIOCM_LE: u32 = 1;
pub const TIOCM_DTR: u32 = 2;
pub const TIOCM_RTS: u32 = 4;
pub const TIOCM_ST: u32 = 8;
pub const TIOCM_SR: u32 = 16;
pub const TIOCM_CTS: u32 = 32;
pub const TIOCM_CAR: u32 = 64;
pub const TIOCM_CD: u32 = 64;
pub const TIOCM_RNG: u32 = 128;
pub const TIOCM_RI: u32 = 128;
pub const TIOCM_DSR: u32 = 256;
pub const TIOCPKT_DATA: u32 = 0;
pub const TIOCPKT_FLUSHREAD: u32 = 1;
pub const TIOCPKT_FLUSHWRITE: u32 = 2;
pub const TIOCPKT_STOP: u32 = 4;
pub const TIOCPKT_START: u32 = 8;
pub const TIOCPKT_NOSTOP: u32 = 16;
pub const TIOCPKT_DOSTOP: u32 = 32;
pub const TIOCPKT_IOCTL: u32 = 64;
pub const TTYDISC: u32 = 0;
pub const TABLDISC: u32 = 3;
pub const SLIPDISC: u32 = 4;
pub const PPPDISC: u32 = 5;
pub const TTYDEF_IFLAG: u32 = 11010;
pub const TTYDEF_OFLAG: u32 = 3;
pub const TTYDEF_LFLAG: u32 = 1483;
pub const TTYDEF_CFLAG: u32 = 19200;
pub const TTYDEF_SPEED: u32 = 9600;
pub const CEOL: u32 = 255;
pub const CERASE: u32 = 127;
pub const CMIN: u32 = 1;
pub const CQUIT: u32 = 28;
pub const CTIME: u32 = 0;
pub const CBRK: u32 = 255;
pub const _POSIX_VERSION: u32 = 200112;
pub const _POSIX2_VERSION: u32 = 200112;
pub const F_OK: u32 = 0;
pub const X_OK: u32 = 1;
pub const W_OK: u32 = 2;
pub const R_OK: u32 = 4;
pub const _READ_OK: u32 = 512;
pub const _WRITE_OK: u32 = 1024;
pub const _EXECUTE_OK: u32 = 2048;
pub const _DELETE_OK: u32 = 4096;
pub const _APPEND_OK: u32 = 8192;
pub const _RMFILE_OK: u32 = 16384;
pub const _RATTR_OK: u32 = 32768;
pub const _WATTR_OK: u32 = 65536;
pub const _REXT_OK: u32 = 131072;
pub const _WEXT_OK: u32 = 262144;
pub const _RPERM_OK: u32 = 524288;
pub const _WPERM_OK: u32 = 1048576;
pub const _CHOWN_OK: u32 = 2097152;
pub const _ACCESS_EXTENDED_MASK: u32 = 4193792;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const ACCESSX_MAX_DESCRIPTORS: u32 = 100;
pub const ACCESSX_MAX_TABLESIZE: u32 = 16384;
pub const _PC_LINK_MAX: u32 = 1;
pub const _PC_MAX_CANON: u32 = 2;
pub const _PC_MAX_INPUT: u32 = 3;
pub const _PC_NAME_MAX: u32 = 4;
pub const _PC_PATH_MAX: u32 = 5;
pub const _PC_PIPE_BUF: u32 = 6;
pub const _PC_CHOWN_RESTRICTED: u32 = 7;
pub const _PC_NO_TRUNC: u32 = 8;
pub const _PC_VDISABLE: u32 = 9;
pub const _PC_NAME_CHARS_MAX: u32 = 10;
pub const _PC_CASE_SENSITIVE: u32 = 11;
pub const _PC_CASE_PRESERVING: u32 = 12;
pub const _PC_EXTENDED_SECURITY_NP: u32 = 13;
pub const _PC_AUTH_OPAQUE_NP: u32 = 14;
pub const _PC_2_SYMLINKS: u32 = 15;
pub const _PC_ALLOC_SIZE_MIN: u32 = 16;
pub const _PC_ASYNC_IO: u32 = 17;
pub const _PC_FILESIZEBITS: u32 = 18;
pub const _PC_PRIO_IO: u32 = 19;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 20;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 21;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 22;
pub const _PC_REC_XFER_ALIGN: u32 = 23;
pub const _PC_SYMLINK_MAX: u32 = 24;
pub const _PC_SYNC_IO: u32 = 25;
pub const _PC_XATTR_SIZE_BITS: u32 = 26;
pub const _PC_MIN_HOLE_SIZE: u32 = 27;
pub const _CS_PATH: u32 = 1;
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const _XOPEN_VERSION: u32 = 600;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _POSIX_ADVISORY_INFO: i32 = -1;
pub const _POSIX_ASYNCHRONOUS_IO: i32 = -1;
pub const _POSIX_BARRIERS: i32 = -1;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: i32 = -1;
pub const _POSIX_CPUTIME: i32 = -1;
pub const _POSIX_FSYNC: u32 = 200112;
pub const _POSIX_IPV6: u32 = 200112;
pub const _POSIX_JOB_CONTROL: u32 = 200112;
pub const _POSIX_MAPPED_FILES: u32 = 200112;
pub const _POSIX_MEMLOCK: i32 = -1;
pub const _POSIX_MEMLOCK_RANGE: i32 = -1;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200112;
pub const _POSIX_MESSAGE_PASSING: i32 = -1;
pub const _POSIX_MONOTONIC_CLOCK: i32 = -1;
pub const _POSIX_NO_TRUNC: u32 = 200112;
pub const _POSIX_PRIORITIZED_IO: i32 = -1;
pub const _POSIX_PRIORITY_SCHEDULING: i32 = -1;
pub const _POSIX_RAW_SOCKETS: i32 = -1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200112;
pub const _POSIX_REALTIME_SIGNALS: i32 = -1;
pub const _POSIX_REGEXP: u32 = 200112;
pub const _POSIX_SAVED_IDS: u32 = 200112;
pub const _POSIX_SEMAPHORES: i32 = -1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_SHELL: u32 = 200112;
pub const _POSIX_SPAWN: i32 = -1;
pub const _POSIX_SPIN_LOCKS: i32 = -1;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_SYNCHRONIZED_IO: i32 = -1;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200112;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200112;
pub const _POSIX_THREAD_CPUTIME: i32 = -1;
pub const _POSIX_THREAD_PRIO_INHERIT: i32 = -1;
pub const _POSIX_THREAD_PRIO_PROTECT: i32 = -1;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: i32 = -1;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200112;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200112;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREADS: u32 = 200112;
pub const _POSIX_TIMEOUTS: i32 = -1;
pub const _POSIX_TIMERS: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX2_C_BIND: u32 = 200112;
pub const _POSIX2_C_DEV: u32 = 200112;
pub const _POSIX2_CHAR_TERM: u32 = 200112;
pub const _POSIX2_FORT_DEV: i32 = -1;
pub const _POSIX2_FORT_RUN: u32 = 200112;
pub const _POSIX2_LOCALEDEF: u32 = 200112;
pub const _POSIX2_PBS: i32 = -1;
pub const _POSIX2_PBS_ACCOUNTING: i32 = -1;
pub const _POSIX2_PBS_CHECKPOINT: i32 = -1;
pub const _POSIX2_PBS_LOCATE: i32 = -1;
pub const _POSIX2_PBS_MESSAGE: i32 = -1;
pub const _POSIX2_PBS_TRACK: i32 = -1;
pub const _POSIX2_SW_DEV: u32 = 200112;
pub const _POSIX2_UPE: u32 = 200112;
pub const __ILP32_OFF32: i32 = -1;
pub const __ILP32_OFFBIG: i32 = -1;
pub const __LP64_OFF64: u32 = 1;
pub const __LPBIG_OFFBIG: u32 = 1;
pub const _POSIX_V6_ILP32_OFF32: i32 = -1;
pub const _POSIX_V6_ILP32_OFFBIG: i32 = -1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LPBIG_OFFBIG: u32 = 1;
pub const _POSIX_V7_ILP32_OFF32: i32 = -1;
pub const _POSIX_V7_ILP32_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V7_LPBIG_OFFBIG: u32 = 1;
pub const _V6_ILP32_OFF32: i32 = -1;
pub const _V6_ILP32_OFFBIG: i32 = -1;
pub const _V6_LP64_OFF64: u32 = 1;
pub const _V6_LPBIG_OFFBIG: u32 = 1;
pub const _XBS5_ILP32_OFF32: i32 = -1;
pub const _XBS5_ILP32_OFFBIG: i32 = -1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const _XBS5_LPBIG_OFFBIG: u32 = 1;
pub const _XOPEN_CRYPT: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: i32 = -1;
pub const _XOPEN_REALTIME: i32 = -1;
pub const _XOPEN_REALTIME_THREADS: i32 = -1;
pub const _XOPEN_SHM: u32 = 1;
pub const _XOPEN_STREAMS: i32 = -1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _SC_ARG_MAX: u32 = 1;
pub const _SC_CHILD_MAX: u32 = 2;
pub const _SC_CLK_TCK: u32 = 3;
pub const _SC_NGROUPS_MAX: u32 = 4;
pub const _SC_OPEN_MAX: u32 = 5;
pub const _SC_JOB_CONTROL: u32 = 6;
pub const _SC_SAVED_IDS: u32 = 7;
pub const _SC_VERSION: u32 = 8;
pub const _SC_BC_BASE_MAX: u32 = 9;
pub const _SC_BC_DIM_MAX: u32 = 10;
pub const _SC_BC_SCALE_MAX: u32 = 11;
pub const _SC_BC_STRING_MAX: u32 = 12;
pub const _SC_COLL_WEIGHTS_MAX: u32 = 13;
pub const _SC_EXPR_NEST_MAX: u32 = 14;
pub const _SC_LINE_MAX: u32 = 15;
pub const _SC_RE_DUP_MAX: u32 = 16;
pub const _SC_2_VERSION: u32 = 17;
pub const _SC_2_C_BIND: u32 = 18;
pub const _SC_2_C_DEV: u32 = 19;
pub const _SC_2_CHAR_TERM: u32 = 20;
pub const _SC_2_FORT_DEV: u32 = 21;
pub const _SC_2_FORT_RUN: u32 = 22;
pub const _SC_2_LOCALEDEF: u32 = 23;
pub const _SC_2_SW_DEV: u32 = 24;
pub const _SC_2_UPE: u32 = 25;
pub const _SC_STREAM_MAX: u32 = 26;
pub const _SC_TZNAME_MAX: u32 = 27;
pub const _SC_ASYNCHRONOUS_IO: u32 = 28;
pub const _SC_PAGESIZE: u32 = 29;
pub const _SC_MEMLOCK: u32 = 30;
pub const _SC_MEMLOCK_RANGE: u32 = 31;
pub const _SC_MEMORY_PROTECTION: u32 = 32;
pub const _SC_MESSAGE_PASSING: u32 = 33;
pub const _SC_PRIORITIZED_IO: u32 = 34;
pub const _SC_PRIORITY_SCHEDULING: u32 = 35;
pub const _SC_REALTIME_SIGNALS: u32 = 36;
pub const _SC_SEMAPHORES: u32 = 37;
pub const _SC_FSYNC: u32 = 38;
pub const _SC_SHARED_MEMORY_OBJECTS: u32 = 39;
pub const _SC_SYNCHRONIZED_IO: u32 = 40;
pub const _SC_TIMERS: u32 = 41;
pub const _SC_AIO_LISTIO_MAX: u32 = 42;
pub const _SC_AIO_MAX: u32 = 43;
pub const _SC_AIO_PRIO_DELTA_MAX: u32 = 44;
pub const _SC_DELAYTIMER_MAX: u32 = 45;
pub const _SC_MQ_OPEN_MAX: u32 = 46;
pub const _SC_MAPPED_FILES: u32 = 47;
pub const _SC_RTSIG_MAX: u32 = 48;
pub const _SC_SEM_NSEMS_MAX: u32 = 49;
pub const _SC_SEM_VALUE_MAX: u32 = 50;
pub const _SC_SIGQUEUE_MAX: u32 = 51;
pub const _SC_TIMER_MAX: u32 = 52;
pub const _SC_NPROCESSORS_CONF: u32 = 57;
pub const _SC_NPROCESSORS_ONLN: u32 = 58;
pub const _SC_2_PBS: u32 = 59;
pub const _SC_2_PBS_ACCOUNTING: u32 = 60;
pub const _SC_2_PBS_CHECKPOINT: u32 = 61;
pub const _SC_2_PBS_LOCATE: u32 = 62;
pub const _SC_2_PBS_MESSAGE: u32 = 63;
pub const _SC_2_PBS_TRACK: u32 = 64;
pub const _SC_ADVISORY_INFO: u32 = 65;
pub const _SC_BARRIERS: u32 = 66;
pub const _SC_CLOCK_SELECTION: u32 = 67;
pub const _SC_CPUTIME: u32 = 68;
pub const _SC_FILE_LOCKING: u32 = 69;
pub const _SC_GETGR_R_SIZE_MAX: u32 = 70;
pub const _SC_GETPW_R_SIZE_MAX: u32 = 71;
pub const _SC_HOST_NAME_MAX: u32 = 72;
pub const _SC_LOGIN_NAME_MAX: u32 = 73;
pub const _SC_MONOTONIC_CLOCK: u32 = 74;
pub const _SC_MQ_PRIO_MAX: u32 = 75;
pub const _SC_READER_WRITER_LOCKS: u32 = 76;
pub const _SC_REGEXP: u32 = 77;
pub const _SC_SHELL: u32 = 78;
pub const _SC_SPAWN: u32 = 79;
pub const _SC_SPIN_LOCKS: u32 = 80;
pub const _SC_SPORADIC_SERVER: u32 = 81;
pub const _SC_THREAD_ATTR_STACKADDR: u32 = 82;
pub const _SC_THREAD_ATTR_STACKSIZE: u32 = 83;
pub const _SC_THREAD_CPUTIME: u32 = 84;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u32 = 85;
pub const _SC_THREAD_KEYS_MAX: u32 = 86;
pub const _SC_THREAD_PRIO_INHERIT: u32 = 87;
pub const _SC_THREAD_PRIO_PROTECT: u32 = 88;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u32 = 89;
pub const _SC_THREAD_PROCESS_SHARED: u32 = 90;
pub const _SC_THREAD_SAFE_FUNCTIONS: u32 = 91;
pub const _SC_THREAD_SPORADIC_SERVER: u32 = 92;
pub const _SC_THREAD_STACK_MIN: u32 = 93;
pub const _SC_THREAD_THREADS_MAX: u32 = 94;
pub const _SC_TIMEOUTS: u32 = 95;
pub const _SC_THREADS: u32 = 96;
pub const _SC_TRACE: u32 = 97;
pub const _SC_TRACE_EVENT_FILTER: u32 = 98;
pub const _SC_TRACE_INHERIT: u32 = 99;
pub const _SC_TRACE_LOG: u32 = 100;
pub const _SC_TTY_NAME_MAX: u32 = 101;
pub const _SC_TYPED_MEMORY_OBJECTS: u32 = 102;
pub const _SC_V6_ILP32_OFF32: u32 = 103;
pub const _SC_V6_ILP32_OFFBIG: u32 = 104;
pub const _SC_V6_LP64_OFF64: u32 = 105;
pub const _SC_V6_LPBIG_OFFBIG: u32 = 106;
pub const _SC_IPV6: u32 = 118;
pub const _SC_RAW_SOCKETS: u32 = 119;
pub const _SC_SYMLOOP_MAX: u32 = 120;
pub const _SC_ATEXIT_MAX: u32 = 107;
pub const _SC_IOV_MAX: u32 = 56;
pub const _SC_PAGE_SIZE: u32 = 29;
pub const _SC_XOPEN_CRYPT: u32 = 108;
pub const _SC_XOPEN_ENH_I18N: u32 = 109;
pub const _SC_XOPEN_LEGACY: u32 = 110;
pub const _SC_XOPEN_REALTIME: u32 = 111;
pub const _SC_XOPEN_REALTIME_THREADS: u32 = 112;
pub const _SC_XOPEN_SHM: u32 = 113;
pub const _SC_XOPEN_STREAMS: u32 = 114;
pub const _SC_XOPEN_UNIX: u32 = 115;
pub const _SC_XOPEN_VERSION: u32 = 116;
pub const _SC_XOPEN_XCU_VERSION: u32 = 121;
pub const _SC_XBS5_ILP32_OFF32: u32 = 122;
pub const _SC_XBS5_ILP32_OFFBIG: u32 = 123;
pub const _SC_XBS5_LP64_OFF64: u32 = 124;
pub const _SC_XBS5_LPBIG_OFFBIG: u32 = 125;
pub const _SC_SS_REPL_MAX: u32 = 126;
pub const _SC_TRACE_EVENT_NAME_MAX: u32 = 127;
pub const _SC_TRACE_NAME_MAX: u32 = 128;
pub const _SC_TRACE_SYS_MAX: u32 = 129;
pub const _SC_TRACE_USER_EVENT_MAX: u32 = 130;
pub const _SC_PASS_MAX: u32 = 131;
pub const _SC_PHYS_PAGES: u32 = 200;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: u32 = 2;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: u32 = 3;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: u32 = 4;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: u32 = 5;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: u32 = 6;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: u32 = 7;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: u32 = 8;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: u32 = 9;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: u32 = 10;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: u32 = 11;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: u32 = 12;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: u32 = 13;
pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS: u32 = 14;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: u32 = 20;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: u32 = 21;
pub const _CS_XBS5_ILP32_OFF32_LIBS: u32 = 22;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: u32 = 23;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: u32 = 24;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: u32 = 25;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: u32 = 26;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: u32 = 27;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: u32 = 28;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: u32 = 29;
pub const _CS_XBS5_LP64_OFF64_LIBS: u32 = 30;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: u32 = 31;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: u32 = 32;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: u32 = 33;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: u32 = 34;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: u32 = 35;
pub const _CS_DARWIN_USER_DIR: u32 = 65536;
pub const _CS_DARWIN_USER_TEMP_DIR: u32 = 65537;
pub const _CS_DARWIN_USER_CACHE_DIR: u32 = 65538;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const SYNC_VOLUME_FULLSYNC: u32 = 1;
pub const SYNC_VOLUME_WAIT: u32 = 2;
pub const IF_NAMESIZE: u32 = 16;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const APPLE_IF_FAM_LOOPBACK: u32 = 1;
pub const APPLE_IF_FAM_ETHERNET: u32 = 2;
pub const APPLE_IF_FAM_SLIP: u32 = 3;
pub const APPLE_IF_FAM_TUN: u32 = 4;
pub const APPLE_IF_FAM_VLAN: u32 = 5;
pub const APPLE_IF_FAM_PPP: u32 = 6;
pub const APPLE_IF_FAM_PVC: u32 = 7;
pub const APPLE_IF_FAM_DISC: u32 = 8;
pub const APPLE_IF_FAM_MDECAP: u32 = 9;
pub const APPLE_IF_FAM_GIF: u32 = 10;
pub const APPLE_IF_FAM_FAITH: u32 = 11;
pub const APPLE_IF_FAM_STF: u32 = 12;
pub const APPLE_IF_FAM_FIREWIRE: u32 = 13;
pub const APPLE_IF_FAM_BOND: u32 = 14;
pub const APPLE_IF_FAM_CELLULAR: u32 = 15;
pub const APPLE_IF_FAM_6LOWPAN: u32 = 16;
pub const APPLE_IF_FAM_UTUN: u32 = 17;
pub const APPLE_IF_FAM_IPSEC: u32 = 18;
pub const IF_MINMTU: u32 = 72;
pub const IF_MAXMTU: u32 = 65535;
pub const IFNAMSIZ: u32 = 16;
pub const IFF_UP: u32 = 1;
pub const IFF_BROADCAST: u32 = 2;
pub const IFF_DEBUG: u32 = 4;
pub const IFF_LOOPBACK: u32 = 8;
pub const IFF_POINTOPOINT: u32 = 16;
pub const IFF_NOTRAILERS: u32 = 32;
pub const IFF_RUNNING: u32 = 64;
pub const IFF_NOARP: u32 = 128;
pub const IFF_PROMISC: u32 = 256;
pub const IFF_ALLMULTI: u32 = 512;
pub const IFF_OACTIVE: u32 = 1024;
pub const IFF_SIMPLEX: u32 = 2048;
pub const IFF_LINK0: u32 = 4096;
pub const IFF_LINK1: u32 = 8192;
pub const IFF_LINK2: u32 = 16384;
pub const IFF_ALTPHYS: u32 = 16384;
pub const IFF_MULTICAST: u32 = 32768;
pub const IFCAP_RXCSUM: u32 = 1;
pub const IFCAP_TXCSUM: u32 = 2;
pub const IFCAP_VLAN_MTU: u32 = 4;
pub const IFCAP_VLAN_HWTAGGING: u32 = 8;
pub const IFCAP_JUMBO_MTU: u32 = 16;
pub const IFCAP_TSO4: u32 = 32;
pub const IFCAP_TSO6: u32 = 64;
pub const IFCAP_LRO: u32 = 128;
pub const IFCAP_AV: u32 = 256;
pub const IFCAP_TXSTATUS: u32 = 512;
pub const IFCAP_SKYWALK: u32 = 1024;
pub const IFCAP_HW_TIMESTAMP: u32 = 2048;
pub const IFCAP_SW_TIMESTAMP: u32 = 4096;
pub const IFCAP_CSUM_PARTIAL: u32 = 8192;
pub const IFCAP_CSUM_ZERO_INVERT: u32 = 16384;
pub const IFCAP_HWCSUM: u32 = 3;
pub const IFCAP_TSO: u32 = 96;
pub const IFCAP_VALID: u32 = 32767;
pub const IFQ_MAXLEN: u32 = 128;
pub const IFNET_SLOWHZ: u32 = 1;
pub const IFQ_TARGET_DELAY: u32 = 10000000;
pub const IFQ_UPDATE_INTERVAL: u32 = 100000000;
pub const IF_WAKE_ON_MAGIC_PACKET: u32 = 1;
pub const IFRTYPE_FUNCTIONAL_UNKNOWN: u32 = 0;
pub const IFRTYPE_FUNCTIONAL_LOOPBACK: u32 = 1;
pub const IFRTYPE_FUNCTIONAL_WIRED: u32 = 2;
pub const IFRTYPE_FUNCTIONAL_WIFI_INFRA: u32 = 3;
pub const IFRTYPE_FUNCTIONAL_WIFI_AWDL: u32 = 4;
pub const IFRTYPE_FUNCTIONAL_CELLULAR: u32 = 5;
pub const IFRTYPE_FUNCTIONAL_INTCOPROC: u32 = 6;
pub const IFRTYPE_FUNCTIONAL_COMPANIONLINK: u32 = 7;
pub const IFRTYPE_FUNCTIONAL_LAST: u32 = 7;
pub const IFSTATMAX: u32 = 800;
pub const TH_FIN: u32 = 1;
pub const TH_SYN: u32 = 2;
pub const TH_RST: u32 = 4;
pub const TH_PUSH: u32 = 8;
pub const TH_ACK: u32 = 16;
pub const TH_URG: u32 = 32;
pub const TH_ECE: u32 = 64;
pub const TH_CWR: u32 = 128;
pub const TH_FLAGS: u32 = 247;
pub const TH_ACCEPT: u32 = 23;
pub const TCPOPT_EOL: u32 = 0;
pub const TCPOPT_NOP: u32 = 1;
pub const TCPOPT_MAXSEG: u32 = 2;
pub const TCPOLEN_MAXSEG: u32 = 4;
pub const TCPOPT_WINDOW: u32 = 3;
pub const TCPOLEN_WINDOW: u32 = 3;
pub const TCPOPT_SACK_PERMITTED: u32 = 4;
pub const TCPOLEN_SACK_PERMITTED: u32 = 2;
pub const TCPOPT_SACK: u32 = 5;
pub const TCPOLEN_SACK: u32 = 8;
pub const TCPOPT_TIMESTAMP: u32 = 8;
pub const TCPOLEN_TIMESTAMP: u32 = 10;
pub const TCPOLEN_TSTAMP_APPA: u32 = 12;
pub const TCPOPT_TSTAMP_HDR: u32 = 16844810;
pub const MAX_TCPOPTLEN: u32 = 40;
pub const TCPOPT_CC: u32 = 11;
pub const TCPOPT_CCNEW: u32 = 12;
pub const TCPOPT_CCECHO: u32 = 13;
pub const TCPOLEN_CC: u32 = 6;
pub const TCPOLEN_CC_APPA: u32 = 8;
pub const TCPOPT_SIGNATURE: u32 = 19;
pub const TCPOLEN_SIGNATURE: u32 = 18;
pub const TCPOPT_FASTOPEN: u32 = 34;
pub const TCPOLEN_FASTOPEN_REQ: u32 = 2;
pub const TCPOPT_SACK_HDR: u32 = 16844032;
pub const MAX_SACK_BLKS: u32 = 6;
pub const TCP_MAX_SACK: u32 = 4;
pub const TCP_MSS: u32 = 512;
pub const TCP_MINMSS: u32 = 216;
pub const TCP6_MSS: u32 = 1024;
pub const TCP_MAXWIN: u32 = 65535;
pub const TTCP_CLIENT_SND_WND: u32 = 4096;
pub const TCP_MAX_WINSHIFT: u32 = 14;
pub const TCP_MAXHLEN: u32 = 60;
pub const TCP_NODELAY: u32 = 1;
pub const TCP_MAXSEG: u32 = 2;
pub const TCP_NOPUSH: u32 = 4;
pub const TCP_NOOPT: u32 = 8;
pub const TCP_KEEPALIVE: u32 = 16;
pub const TCP_CONNECTIONTIMEOUT: u32 = 32;
pub const PERSIST_TIMEOUT: u32 = 64;
pub const TCP_RXT_CONNDROPTIME: u32 = 128;
pub const TCP_RXT_FINDROP: u32 = 256;
pub const TCP_KEEPINTVL: u32 = 257;
pub const TCP_KEEPCNT: u32 = 258;
pub const TCP_SENDMOREACKS: u32 = 259;
pub const TCP_ENABLE_ECN: u32 = 260;
pub const TCP_FASTOPEN: u32 = 261;
pub const TCP_CONNECTION_INFO: u32 = 262;
pub const TCP_NOTSENT_LOWAT: u32 = 513;
pub const TCPCI_OPT_TIMESTAMPS: u32 = 1;
pub const TCPCI_OPT_SACK: u32 = 2;
pub const TCPCI_OPT_WSCALE: u32 = 4;
pub const TCPCI_OPT_ECN: u32 = 8;
pub const TCPCI_FLAG_LOSSRECOVERY: u32 = 1;
pub const TCPCI_FLAG_REORDERING_DETECTED: u32 = 2;
pub const PROT_NONE: u32 = 0;
pub const PROT_READ: u32 = 1;
pub const PROT_WRITE: u32 = 2;
pub const PROT_EXEC: u32 = 4;
pub const MAP_SHARED: u32 = 1;
pub const MAP_PRIVATE: u32 = 2;
pub const MAP_COPY: u32 = 2;
pub const MAP_FIXED: u32 = 16;
pub const MAP_RENAME: u32 = 32;
pub const MAP_NORESERVE: u32 = 64;
pub const MAP_RESERVED0080: u32 = 128;
pub const MAP_NOEXTEND: u32 = 256;
pub const MAP_HASSEMAPHORE: u32 = 512;
pub const MAP_NOCACHE: u32 = 1024;
pub const MAP_JIT: u32 = 2048;
pub const MAP_FILE: u32 = 0;
pub const MAP_ANON: u32 = 4096;
pub const MAP_ANONYMOUS: u32 = 4096;
pub const MAP_RESILIENT_CODESIGN: u32 = 8192;
pub const MAP_RESILIENT_MEDIA: u32 = 16384;
pub const MAP_32BIT: u32 = 32768;
pub const MAP_TRANSLATED_ALLOW_EXECUTE: u32 = 131072;
pub const MAP_UNIX03: u32 = 262144;
pub const MCL_CURRENT: u32 = 1;
pub const MCL_FUTURE: u32 = 2;
pub const MS_ASYNC: u32 = 1;
pub const MS_INVALIDATE: u32 = 2;
pub const MS_SYNC: u32 = 16;
pub const MS_KILLPAGES: u32 = 4;
pub const MS_DEACTIVATE: u32 = 8;
pub const POSIX_MADV_NORMAL: u32 = 0;
pub const POSIX_MADV_RANDOM: u32 = 1;
pub const POSIX_MADV_SEQUENTIAL: u32 = 2;
pub const POSIX_MADV_WILLNEED: u32 = 3;
pub const POSIX_MADV_DONTNEED: u32 = 4;
pub const MADV_NORMAL: u32 = 0;
pub const MADV_RANDOM: u32 = 1;
pub const MADV_SEQUENTIAL: u32 = 2;
pub const MADV_WILLNEED: u32 = 3;
pub const MADV_DONTNEED: u32 = 4;
pub const MADV_FREE: u32 = 5;
pub const MADV_ZERO_WIRED_PAGES: u32 = 6;
pub const MADV_FREE_REUSABLE: u32 = 7;
pub const MADV_FREE_REUSE: u32 = 8;
pub const MADV_CAN_REUSE: u32 = 9;
pub const MADV_PAGEOUT: u32 = 10;
pub const MINCORE_INCORE: u32 = 1;
pub const MINCORE_REFERENCED: u32 = 2;
pub const MINCORE_MODIFIED: u32 = 4;
pub const MINCORE_REFERENCED_OTHER: u32 = 8;
pub const MINCORE_MODIFIED_OTHER: u32 = 16;
pub const MINCORE_PAGED_OUT: u32 = 32;
pub const MINCORE_COPIED: u32 = 64;
pub const MINCORE_ANONYMOUS: u32 = 128;
pub const ACCESSPERMS: u32 = 511;
pub const ALLPERMS: u32 = 4095;
pub const DEFFILEMODE: u32 = 438;
pub const S_BLKSIZE: u32 = 512;
pub const UF_SETTABLE: u32 = 65535;
pub const UF_NODUMP: u32 = 1;
pub const UF_IMMUTABLE: u32 = 2;
pub const UF_APPEND: u32 = 4;
pub const UF_OPAQUE: u32 = 8;
pub const UF_COMPRESSED: u32 = 32;
pub const UF_TRACKED: u32 = 64;
pub const UF_DATAVAULT: u32 = 128;
pub const UF_HIDDEN: u32 = 32768;
pub const SF_SUPPORTED: u32 = 10420224;
pub const SF_SETTABLE: u32 = 1073676288;
pub const SF_SYNTHETIC: u32 = 3221225472;
pub const SF_ARCHIVED: u32 = 65536;
pub const SF_IMMUTABLE: u32 = 131072;
pub const SF_APPEND: u32 = 262144;
pub const SF_RESTRICTED: u32 = 524288;
pub const SF_NOUNLINK: u32 = 1048576;
pub const SF_FIRMLINK: u32 = 8388608;
pub const SF_DATALESS: u32 = 1073741824;
pub const EF_MAY_SHARE_BLOCKS: u32 = 1;
pub const EF_NO_XATTRS: u32 = 2;
pub const EF_IS_SYNC_ROOT: u32 = 4;
pub const EF_IS_PURGEABLE: u32 = 8;
pub const EF_IS_SPARSE: u32 = 16;
pub const EF_IS_SYNTHETIC: u32 = 32;
pub const UTIME_NOW: i32 = -1;
pub const UTIME_OMIT: i32 = -2;
pub const SOL_LOCAL: u32 = 0;
pub const LOCAL_PEERCRED: u32 = 1;
pub const LOCAL_PEERPID: u32 = 2;
pub const LOCAL_PEEREPID: u32 = 3;
pub const LOCAL_PEERUUID: u32 = 4;
pub const LOCAL_PEEREUUID: u32 = 5;
pub const LOCAL_PEERTOKEN: u32 = 6;
pub const BSD: u32 = 199506;
pub const BSD4_3: u32 = 1;
pub const BSD4_4: u32 = 1;
pub const NeXTBSD: u32 = 1995064;
pub const NeXTBSD4_0: u32 = 0;
pub const MAXCOMLEN: u32 = 16;
pub const MAXINTERP: u32 = 64;
pub const MAXLOGNAME: u32 = 255;
pub const MAXUPRC: u32 = 266;
pub const NCARGS: u32 = 1048576;
pub const NGROUPS: u32 = 16;
pub const NOFILE: u32 = 256;
pub const NOGROUP: u32 = 65535;
pub const MAXHOSTNAMELEN: u32 = 256;
pub const MAXDOMNAMELEN: u32 = 256;
pub const NBPG: u32 = 4096;
pub const PGOFSET: u32 = 4095;
pub const PGSHIFT: u32 = 12;
pub const DEV_BSIZE: u32 = 512;
pub const DEV_BSHIFT: u32 = 9;
pub const BLKDEV_IOSIZE: u32 = 2048;
pub const MAXPHYS: u32 = 65536;
pub const CLSIZE: u32 = 1;
pub const CLSIZELOG2: u32 = 0;
pub const MSIZESHIFT: u32 = 8;
pub const MSIZE: u32 = 256;
pub const MCLSHIFT: u32 = 11;
pub const MCLBYTES: u32 = 2048;
pub const MBIGCLSHIFT: u32 = 12;
pub const MBIGCLBYTES: u32 = 4096;
pub const M16KCLSHIFT: u32 = 14;
pub const M16KCLBYTES: u32 = 16384;
pub const MCLOFSET: u32 = 2047;
pub const PSWP: u32 = 0;
pub const PVM: u32 = 4;
pub const PINOD: u32 = 8;
pub const PRIBIO: u32 = 16;
pub const PVFS: u32 = 20;
pub const PZERO: u32 = 22;
pub const PSOCK: u32 = 24;
pub const PWAIT: u32 = 32;
pub const PLOCK: u32 = 36;
pub const PPAUSE: u32 = 40;
pub const PUSER: u32 = 50;
pub const MAXPRI: u32 = 127;
pub const PRIMASK: u32 = 255;
pub const PCATCH: u32 = 256;
pub const PTTYBLOCK: u32 = 512;
pub const PDROP: u32 = 1024;
pub const PSPIN: u32 = 2048;
pub const CMASK: u32 = 18;
pub const CLBYTES: u32 = 4096;
pub const CLOFSET: u32 = 4095;
pub const CLOFF: u32 = 4095;
pub const CLSHIFT: u32 = 12;
pub const CBLOCK: u32 = 64;
pub const CBQSIZE: u32 = 8;
pub const CROUND: u32 = 63;
pub const MAXBSIZE: u32 = 1048576;
pub const MAXPHYSIO: u32 = 65536;
pub const MAXFRAG: u32 = 8;
pub const MAXPHYSIO_WIRED: u32 = 16777216;
pub const MAXPATHLEN: u32 = 1024;
pub const MAXSYMLINKS: u32 = 32;
pub const FSHIFT: u32 = 11;
pub const FSCALE: u32 = 2048;
pub const AUDIT_RECORD_MAGIC: u32 = 2190085915;
pub const MAX_AUDIT_RECORDS: u32 = 20;
pub const MAXAUDITDATA: u32 = 32767;
pub const MAX_AUDIT_RECORD_SIZE: u32 = 32767;
pub const MIN_AUDIT_FILE_SIZE: u32 = 524288;
pub const AUDIT_HARD_LIMIT_FREE_BLOCKS: u32 = 4;
pub const AUDIT_TRIGGER_MIN: u32 = 1;
pub const AUDIT_TRIGGER_LOW_SPACE: u32 = 1;
pub const AUDIT_TRIGGER_ROTATE_KERNEL: u32 = 2;
pub const AUDIT_TRIGGER_READ_FILE: u32 = 3;
pub const AUDIT_TRIGGER_CLOSE_AND_DIE: u32 = 4;
pub const AUDIT_TRIGGER_NO_SPACE: u32 = 5;
pub const AUDIT_TRIGGER_ROTATE_USER: u32 = 6;
pub const AUDIT_TRIGGER_INITIALIZE: u32 = 7;
pub const AUDIT_TRIGGER_EXPIRE_TRAILS: u32 = 8;
pub const AUDIT_TRIGGER_MAX: u32 = 8;
pub const AUDITDEV_FILENAME: &[u8; 6usize] = b"audit\0";
pub const AUDIT_TRIGGER_FILE: &[u8; 11usize] = b"/dev/audit\0";
pub const AU_DEFAUDITSID: u32 = 0;
pub const AU_ASSIGN_ASID: i32 = -1;
pub const AUC_UNSET: u32 = 0;
pub const AUC_AUDITING: u32 = 1;
pub const AUC_NOAUDIT: u32 = 2;
pub const AUC_DISABLED: i32 = -1;
pub const A_OLDGETPOLICY: u32 = 2;
pub const A_OLDSETPOLICY: u32 = 3;
pub const A_GETKMASK: u32 = 4;
pub const A_SETKMASK: u32 = 5;
pub const A_OLDGETQCTRL: u32 = 6;
pub const A_OLDSETQCTRL: u32 = 7;
pub const A_GETCWD: u32 = 8;
pub const A_GETCAR: u32 = 9;
pub const A_GETSTAT: u32 = 12;
pub const A_SETSTAT: u32 = 13;
pub const A_SETUMASK: u32 = 14;
pub const A_SETSMASK: u32 = 15;
pub const A_OLDGETCOND: u32 = 20;
pub const A_OLDSETCOND: u32 = 21;
pub const A_GETCLASS: u32 = 22;
pub const A_SETCLASS: u32 = 23;
pub const A_GETPINFO: u32 = 24;
pub const A_SETPMASK: u32 = 25;
pub const A_SETFSIZE: u32 = 26;
pub const A_GETFSIZE: u32 = 27;
pub const A_GETPINFO_ADDR: u32 = 28;
pub const A_GETKAUDIT: u32 = 29;
pub const A_SETKAUDIT: u32 = 30;
pub const A_SENDTRIGGER: u32 = 31;
pub const A_GETSINFO_ADDR: u32 = 32;
pub const A_GETPOLICY: u32 = 33;
pub const A_SETPOLICY: u32 = 34;
pub const A_GETQCTRL: u32 = 35;
pub const A_SETQCTRL: u32 = 36;
pub const A_GETCOND: u32 = 37;
pub const A_SETCOND: u32 = 38;
pub const A_GETSFLAGS: u32 = 39;
pub const A_SETSFLAGS: u32 = 40;
pub const A_GETCTLMODE: u32 = 41;
pub const A_SETCTLMODE: u32 = 42;
pub const A_GETEXPAFTER: u32 = 43;
pub const A_SETEXPAFTER: u32 = 44;
pub const AUDIT_CNT: u32 = 1;
pub const AUDIT_AHLT: u32 = 2;
pub const AUDIT_ARGV: u32 = 4;
pub const AUDIT_ARGE: u32 = 8;
pub const AUDIT_SEQ: u32 = 16;
pub const AUDIT_WINDATA: u32 = 32;
pub const AUDIT_USER: u32 = 64;
pub const AUDIT_GROUP: u32 = 128;
pub const AUDIT_TRAIL: u32 = 256;
pub const AUDIT_PATH: u32 = 512;
pub const AUDIT_SCNT: u32 = 1024;
pub const AUDIT_PUBLIC: u32 = 2048;
pub const AUDIT_ZONENAME: u32 = 4096;
pub const AUDIT_PERZONE: u32 = 8192;
pub const AQ_HIWATER: u32 = 100;
pub const AQ_MAXHIGH: u32 = 10000;
pub const AQ_LOWATER: u32 = 10;
pub const AQ_BUFSZ: u32 = 32767;
pub const AQ_MAXBUFSZ: u32 = 1048576;
pub const AU_FS_MINFREE: u32 = 20;
pub const AU_IPv4: u32 = 4;
pub const AU_IPv6: u32 = 16;
pub const AU_CLASS_MASK_RESERVED: u32 = 268435456;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const MACH_PORT_NULL: u32 = 0;
pub const MACH_PORT_TYPE_DNREQUEST: u32 = 2147483648;
pub const MACH_PORT_TYPE_SPREQUEST: u32 = 1073741824;
pub const MACH_PORT_TYPE_SPREQUEST_DELAYED: u32 = 536870912;
pub const MACH_PORT_SRIGHTS_NONE: u32 = 0;
pub const MACH_PORT_SRIGHTS_PRESENT: u32 = 1;
pub const MACH_PORT_QLIMIT_ZERO: u32 = 0;
pub const MACH_PORT_QLIMIT_BASIC: u32 = 5;
pub const MACH_PORT_QLIMIT_SMALL: u32 = 16;
pub const MACH_PORT_QLIMIT_LARGE: u32 = 1024;
pub const MACH_PORT_QLIMIT_KERNEL: u32 = 65534;
pub const MACH_PORT_QLIMIT_MIN: u32 = 0;
pub const MACH_PORT_QLIMIT_DEFAULT: u32 = 5;
pub const MACH_PORT_QLIMIT_MAX: u32 = 1024;
pub const MACH_PORT_STATUS_FLAG_TEMPOWNER: u32 = 1;
pub const MACH_PORT_STATUS_FLAG_GUARDED: u32 = 2;
pub const MACH_PORT_STATUS_FLAG_STRICT_GUARD: u32 = 4;
pub const MACH_PORT_STATUS_FLAG_IMP_DONATION: u32 = 8;
pub const MACH_PORT_STATUS_FLAG_REVIVE: u32 = 16;
pub const MACH_PORT_STATUS_FLAG_TASKPTR: u32 = 32;
pub const MACH_PORT_STATUS_FLAG_GUARD_IMMOVABLE_RECEIVE: u32 = 64;
pub const MACH_PORT_STATUS_FLAG_NO_GRANT: u32 = 128;
pub const MACH_PORT_LIMITS_INFO: u32 = 1;
pub const MACH_PORT_RECEIVE_STATUS: u32 = 2;
pub const MACH_PORT_DNREQUESTS_SIZE: u32 = 3;
pub const MACH_PORT_TEMPOWNER: u32 = 4;
pub const MACH_PORT_IMPORTANCE_RECEIVER: u32 = 5;
pub const MACH_PORT_DENAP_RECEIVER: u32 = 6;
pub const MACH_PORT_INFO_EXT: u32 = 7;
pub const MACH_PORT_GUARD_INFO: u32 = 8;
pub const MACH_PORT_DNREQUESTS_SIZE_COUNT: u32 = 1;
pub const MACH_SERVICE_PORT_INFO_STRING_NAME_MAX_BUF_LEN: u32 = 255;
pub const MPO_CONTEXT_AS_GUARD: u32 = 1;
pub const MPO_QLIMIT: u32 = 2;
pub const MPO_TEMPOWNER: u32 = 4;
pub const MPO_IMPORTANCE_RECEIVER: u32 = 8;
pub const MPO_INSERT_SEND_RIGHT: u32 = 16;
pub const MPO_STRICT: u32 = 32;
pub const MPO_DENAP_RECEIVER: u32 = 64;
pub const MPO_IMMOVABLE_RECEIVE: u32 = 128;
pub const MPO_FILTER_MSG: u32 = 256;
pub const MPO_TG_BLOCK_TRACKING: u32 = 512;
pub const MPO_SERVICE_PORT: u32 = 1024;
pub const MPO_CONNECTION_PORT: u32 = 2048;
pub const GUARD_TYPE_MACH_PORT: u32 = 1;
pub const MAX_FATAL_kGUARD_EXC_CODE: u32 = 128;
pub const MPG_FLAGS_NONE: u32 = 0;
pub const MAX_OPTIONAL_kGUARD_EXC_CODE: u32 = 524288;
pub const MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP: u64 = 72057594037927936;
pub const MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT: u64 = 144115188075855872;
pub const MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER: u64 = 288230376151711744;
pub const MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR: u64 = 576460752303423488;
pub const MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA: u64 = 1152921504606846976;
pub const MPG_FLAGS_STRICT_REPLY_MASK: i64 = -72057594037927936;
pub const MPG_FLAGS_MOD_REFS_PINNED_DEALLOC: u64 = 72057594037927936;
pub const MPG_FLAGS_MOD_REFS_PINNED_DESTROY: u64 = 144115188075855872;
pub const MPG_FLAGS_MOD_REFS_PINNED_COPYIN: u64 = 288230376151711744;
pub const MPG_FLAGS_IMMOVABLE_PINNED: u64 = 72057594037927936;
pub const MPG_STRICT: u32 = 1;
pub const MPG_IMMOVABLE_RECEIVE: u32 = 2;
pub const CRF_NOMEMBERD: u32 = 1;
pub const CRF_MAC_ENFORCE: u32 = 2;
pub const XUCRED_VERSION: u32 = 0;
pub const EVFILT_READ: i32 = -1;
pub const EVFILT_WRITE: i32 = -2;
pub const EVFILT_AIO: i32 = -3;
pub const EVFILT_VNODE: i32 = -4;
pub const EVFILT_PROC: i32 = -5;
pub const EVFILT_SIGNAL: i32 = -6;
pub const EVFILT_TIMER: i32 = -7;
pub const EVFILT_MACHPORT: i32 = -8;
pub const EVFILT_FS: i32 = -9;
pub const EVFILT_USER: i32 = -10;
pub const EVFILT_VM: i32 = -12;
pub const EVFILT_EXCEPT: i32 = -15;
pub const EVFILT_SYSCOUNT: u32 = 17;
pub const EVFILT_THREADMARKER: u32 = 17;
pub const KEVENT_FLAG_NONE: u32 = 0;
pub const KEVENT_FLAG_IMMEDIATE: u32 = 1;
pub const KEVENT_FLAG_ERROR_EVENTS: u32 = 2;
pub const EV_ADD: u32 = 1;
pub const EV_DELETE: u32 = 2;
pub const EV_ENABLE: u32 = 4;
pub const EV_DISABLE: u32 = 8;
pub const EV_ONESHOT: u32 = 16;
pub const EV_CLEAR: u32 = 32;
pub const EV_RECEIPT: u32 = 64;
pub const EV_DISPATCH: u32 = 128;
pub const EV_UDATA_SPECIFIC: u32 = 256;
pub const EV_DISPATCH2: u32 = 384;
pub const EV_VANISHED: u32 = 512;
pub const EV_SYSFLAGS: u32 = 61440;
pub const EV_FLAG0: u32 = 4096;
pub const EV_FLAG1: u32 = 8192;
pub const EV_EOF: u32 = 32768;
pub const EV_ERROR: u32 = 16384;
pub const EV_POLL: u32 = 4096;
pub const EV_OOBAND: u32 = 8192;
pub const NOTE_TRIGGER: u32 = 16777216;
pub const NOTE_FFNOP: u32 = 0;
pub const NOTE_FFAND: u32 = 1073741824;
pub const NOTE_FFOR: u32 = 2147483648;
pub const NOTE_FFCOPY: u32 = 3221225472;
pub const NOTE_FFCTRLMASK: u32 = 3221225472;
pub const NOTE_FFLAGSMASK: u32 = 16777215;
pub const NOTE_LOWAT: u32 = 1;
pub const NOTE_OOB: u32 = 2;
pub const NOTE_DELETE: u32 = 1;
pub const NOTE_WRITE: u32 = 2;
pub const NOTE_EXTEND: u32 = 4;
pub const NOTE_ATTRIB: u32 = 8;
pub const NOTE_LINK: u32 = 16;
pub const NOTE_RENAME: u32 = 32;
pub const NOTE_REVOKE: u32 = 64;
pub const NOTE_NONE: u32 = 128;
pub const NOTE_FUNLOCK: u32 = 256;
pub const NOTE_EXIT: u32 = 2147483648;
pub const NOTE_FORK: u32 = 1073741824;
pub const NOTE_EXEC: u32 = 536870912;
pub const NOTE_SIGNAL: u32 = 134217728;
pub const NOTE_EXITSTATUS: u32 = 67108864;
pub const NOTE_EXIT_DETAIL: u32 = 33554432;
pub const NOTE_PDATAMASK: u32 = 1048575;
pub const NOTE_PCTRLMASK: i32 = -1048576;
pub const NOTE_EXIT_DETAIL_MASK: u32 = 458752;
pub const NOTE_EXIT_DECRYPTFAIL: u32 = 65536;
pub const NOTE_EXIT_MEMORY: u32 = 131072;
pub const NOTE_EXIT_CSERROR: u32 = 262144;
pub const NOTE_VM_PRESSURE: u32 = 2147483648;
pub const NOTE_VM_PRESSURE_TERMINATE: u32 = 1073741824;
pub const NOTE_VM_PRESSURE_SUDDEN_TERMINATE: u32 = 536870912;
pub const NOTE_VM_ERROR: u32 = 268435456;
pub const NOTE_SECONDS: u32 = 1;
pub const NOTE_USECONDS: u32 = 2;
pub const NOTE_NSECONDS: u32 = 4;
pub const NOTE_ABSOLUTE: u32 = 8;
pub const NOTE_LEEWAY: u32 = 16;
pub const NOTE_CRITICAL: u32 = 32;
pub const NOTE_BACKGROUND: u32 = 64;
pub const NOTE_MACH_CONTINUOUS_TIME: u32 = 128;
pub const NOTE_MACHTIME: u32 = 256;
pub const NOTE_TRACK: u32 = 1;
pub const NOTE_TRACKERR: u32 = 2;
pub const NOTE_CHILD: u32 = 4;
pub const SIDL: u32 = 1;
pub const SRUN: u32 = 2;
pub const SSLEEP: u32 = 3;
pub const SSTOP: u32 = 4;
pub const SZOMB: u32 = 5;
pub const P_ADVLOCK: u32 = 1;
pub const P_CONTROLT: u32 = 2;
pub const P_LP64: u32 = 4;
pub const P_NOCLDSTOP: u32 = 8;
pub const P_PPWAIT: u32 = 16;
pub const P_PROFIL: u32 = 32;
pub const P_SELECT: u32 = 64;
pub const P_CONTINUED: u32 = 128;
pub const P_SUGID: u32 = 256;
pub const P_SYSTEM: u32 = 512;
pub const P_TIMEOUT: u32 = 1024;
pub const P_TRACED: u32 = 2048;
pub const P_DISABLE_ASLR: u32 = 4096;
pub const P_WEXIT: u32 = 8192;
pub const P_EXEC: u32 = 16384;
pub const P_OWEUPC: u32 = 32768;
pub const P_AFFINITY: u32 = 65536;
pub const P_TRANSLATED: u32 = 131072;
pub const P_CLASSIC: u32 = 131072;
pub const P_DELAYIDLESLEEP: u32 = 262144;
pub const P_CHECKOPENEVT: u32 = 524288;
pub const P_DEPENDENCY_CAPABLE: u32 = 1048576;
pub const P_REBOOT: u32 = 2097152;
pub const P_RESV6: u32 = 4194304;
pub const P_RESV7: u32 = 8388608;
pub const P_THCWD: u32 = 16777216;
pub const P_RESV9: u32 = 33554432;
pub const P_ADOPTPERSONA: u32 = 67108864;
pub const P_RESV11: u32 = 134217728;
pub const P_NOSHLIB: u32 = 268435456;
pub const P_FORCEQUOTA: u32 = 536870912;
pub const P_NOCLDWAIT: u32 = 1073741824;
pub const P_NOREMOTEHANG: u32 = 2147483648;
pub const P_INMEM: u32 = 0;
pub const P_NOSWAP: u32 = 0;
pub const P_PHYSIO: u32 = 0;
pub const P_FSTRACE: u32 = 0;
pub const P_SSTEP: u32 = 0;
pub const P_DIRTY_TRACK: u32 = 1;
pub const P_DIRTY_ALLOW_IDLE_EXIT: u32 = 2;
pub const P_DIRTY_DEFER: u32 = 4;
pub const P_DIRTY: u32 = 8;
pub const P_DIRTY_SHUTDOWN: u32 = 16;
pub const P_DIRTY_TERMINATED: u32 = 32;
pub const P_DIRTY_BUSY: u32 = 64;
pub const P_DIRTY_MARKED: u32 = 128;
pub const P_DIRTY_AGING_IN_PROGRESS: u32 = 256;
pub const P_DIRTY_LAUNCH_IN_PROGRESS: u32 = 512;
pub const P_DIRTY_DEFER_ALWAYS: u32 = 1024;
pub const P_DIRTY_IS_DIRTY: u32 = 24;
pub const P_DIRTY_IDLE_EXIT_ENABLED: u32 = 3;
pub const CTL_MAXNAME: u32 = 12;
pub const CTLTYPE: u32 = 15;
pub const CTLTYPE_NODE: u32 = 1;
pub const CTLTYPE_INT: u32 = 2;
pub const CTLTYPE_STRING: u32 = 3;
pub const CTLTYPE_QUAD: u32 = 4;
pub const CTLTYPE_OPAQUE: u32 = 5;
pub const CTLTYPE_STRUCT: u32 = 5;
pub const CTLFLAG_RD: u32 = 2147483648;
pub const CTLFLAG_WR: u32 = 1073741824;
pub const CTLFLAG_RW: u32 = 3221225472;
pub const CTLFLAG_NOLOCK: u32 = 536870912;
pub const CTLFLAG_ANYBODY: u32 = 268435456;
pub const CTLFLAG_SECURE: u32 = 134217728;
pub const CTLFLAG_MASKED: u32 = 67108864;
pub const CTLFLAG_NOAUTO: u32 = 33554432;
pub const CTLFLAG_KERN: u32 = 16777216;
pub const CTLFLAG_LOCKED: u32 = 8388608;
pub const CTLFLAG_OID2: u32 = 4194304;
pub const CTLFLAG_EXPERIMENT: u32 = 1048576;
pub const OID_AUTO: i32 = -1;
pub const OID_AUTO_START: u32 = 100;
pub const CTL_UNSPEC: u32 = 0;
pub const CTL_KERN: u32 = 1;
pub const CTL_VM: u32 = 2;
pub const CTL_VFS: u32 = 3;
pub const CTL_NET: u32 = 4;
pub const CTL_DEBUG: u32 = 5;
pub const CTL_HW: u32 = 6;
pub const CTL_MACHDEP: u32 = 7;
pub const CTL_USER: u32 = 8;
pub const CTL_MAXID: u32 = 9;
pub const KERN_OSTYPE: u32 = 1;
pub const KERN_OSRELEASE: u32 = 2;
pub const KERN_OSREV: u32 = 3;
pub const KERN_VERSION: u32 = 4;
pub const KERN_MAXVNODES: u32 = 5;
pub const KERN_MAXPROC: u32 = 6;
pub const KERN_MAXFILES: u32 = 7;
pub const KERN_ARGMAX: u32 = 8;
pub const KERN_SECURELVL: u32 = 9;
pub const KERN_HOSTNAME: u32 = 10;
pub const KERN_HOSTID: u32 = 11;
pub const KERN_CLOCKRATE: u32 = 12;
pub const KERN_VNODE: u32 = 13;
pub const KERN_PROC: u32 = 14;
pub const KERN_FILE: u32 = 15;
pub const KERN_PROF: u32 = 16;
pub const KERN_POSIX1: u32 = 17;
pub const KERN_NGROUPS: u32 = 18;
pub const KERN_JOB_CONTROL: u32 = 19;
pub const KERN_SAVED_IDS: u32 = 20;
pub const KERN_BOOTTIME: u32 = 21;
pub const KERN_NISDOMAINNAME: u32 = 22;
pub const KERN_DOMAINNAME: u32 = 22;
pub const KERN_MAXPARTITIONS: u32 = 23;
pub const KERN_KDEBUG: u32 = 24;
pub const KERN_UPDATEINTERVAL: u32 = 25;
pub const KERN_OSRELDATE: u32 = 26;
pub const KERN_NTP_PLL: u32 = 27;
pub const KERN_BOOTFILE: u32 = 28;
pub const KERN_MAXFILESPERPROC: u32 = 29;
pub const KERN_MAXPROCPERUID: u32 = 30;
pub const KERN_DUMPDEV: u32 = 31;
pub const KERN_IPC: u32 = 32;
pub const KERN_DUMMY: u32 = 33;
pub const KERN_PS_STRINGS: u32 = 34;
pub const KERN_USRSTACK32: u32 = 35;
pub const KERN_LOGSIGEXIT: u32 = 36;
pub const KERN_SYMFILE: u32 = 37;
pub const KERN_PROCARGS: u32 = 38;
pub const KERN_NETBOOT: u32 = 40;
pub const KERN_SYSV: u32 = 42;
pub const KERN_AFFINITY: u32 = 43;
pub const KERN_TRANSLATE: u32 = 44;
pub const KERN_CLASSIC: u32 = 44;
pub const KERN_EXEC: u32 = 45;
pub const KERN_CLASSICHANDLER: u32 = 45;
pub const KERN_AIOMAX: u32 = 46;
pub const KERN_AIOPROCMAX: u32 = 47;
pub const KERN_AIOTHREADS: u32 = 48;
pub const KERN_PROCARGS2: u32 = 49;
pub const KERN_COREFILE: u32 = 50;
pub const KERN_COREDUMP: u32 = 51;
pub const KERN_SUGID_COREDUMP: u32 = 52;
pub const KERN_PROCDELAYTERM: u32 = 53;
pub const KERN_SHREG_PRIVATIZABLE: u32 = 54;
pub const KERN_LOW_PRI_WINDOW: u32 = 56;
pub const KERN_LOW_PRI_DELAY: u32 = 57;
pub const KERN_POSIX: u32 = 58;
pub const KERN_USRSTACK64: u32 = 59;
pub const KERN_NX_PROTECTION: u32 = 60;
pub const KERN_TFP: u32 = 61;
pub const KERN_PROCNAME: u32 = 62;
pub const KERN_THALTSTACK: u32 = 63;
pub const KERN_SPECULATIVE_READS: u32 = 64;
pub const KERN_OSVERSION: u32 = 65;
pub const KERN_SAFEBOOT: u32 = 66;
pub const KERN_RAGEVNODE: u32 = 68;
pub const KERN_TTY: u32 = 69;
pub const KERN_CHECKOPENEVT: u32 = 70;
pub const KERN_THREADNAME: u32 = 71;
pub const KERN_MAXID: u32 = 72;
pub const KERN_USRSTACK: u32 = 59;
pub const KERN_RAGE_PROC: u32 = 1;
pub const KERN_RAGE_THREAD: u32 = 2;
pub const KERN_UNRAGE_PROC: u32 = 3;
pub const KERN_UNRAGE_THREAD: u32 = 4;
pub const KERN_OPENEVT_PROC: u32 = 1;
pub const KERN_UNOPENEVT_PROC: u32 = 2;
pub const KERN_TFP_POLICY: u32 = 1;
pub const KERN_TFP_POLICY_DENY: u32 = 0;
pub const KERN_TFP_POLICY_DEFAULT: u32 = 2;
pub const KERN_KDEFLAGS: u32 = 1;
pub const KERN_KDDFLAGS: u32 = 2;
pub const KERN_KDENABLE: u32 = 3;
pub const KERN_KDSETBUF: u32 = 4;
pub const KERN_KDGETBUF: u32 = 5;
pub const KERN_KDSETUP: u32 = 6;
pub const KERN_KDREMOVE: u32 = 7;
pub const KERN_KDSETREG: u32 = 8;
pub const KERN_KDGETREG: u32 = 9;
pub const KERN_KDREADTR: u32 = 10;
pub const KERN_KDPIDTR: u32 = 11;
pub const KERN_KDTHRMAP: u32 = 12;
pub const KERN_KDPIDEX: u32 = 14;
pub const KERN_KDSETRTCDEC: u32 = 15;
pub const KERN_KDGETENTROPY: u32 = 16;
pub const KERN_KDWRITETR: u32 = 17;
pub const KERN_KDWRITEMAP: u32 = 18;
pub const KERN_KDTEST: u32 = 19;
pub const KERN_KDREADCURTHRMAP: u32 = 21;
pub const KERN_KDSET_TYPEFILTER: u32 = 22;
pub const KERN_KDBUFWAIT: u32 = 23;
pub const KERN_KDCPUMAP: u32 = 24;
pub const KERN_KDCPUMAP_EXT: u32 = 25;
pub const KERN_KDSET_EDM: u32 = 26;
pub const KERN_KDGET_EDM: u32 = 27;
pub const KERN_KDWRITETR_V3: u32 = 28;
pub const KERN_PROC_ALL: u32 = 0;
pub const KERN_PROC_PID: u32 = 1;
pub const KERN_PROC_PGRP: u32 = 2;
pub const KERN_PROC_SESSION: u32 = 3;
pub const KERN_PROC_TTY: u32 = 4;
pub const KERN_PROC_UID: u32 = 5;
pub const KERN_PROC_RUID: u32 = 6;
pub const KERN_PROC_LCID: u32 = 7;
pub const KERN_VFSNSPACE_HANDLE_PROC: u32 = 1;
pub const KERN_VFSNSPACE_UNHANDLE_PROC: u32 = 2;
pub const WMESGLEN: u32 = 7;
pub const EPROC_CTTY: u32 = 1;
pub const EPROC_SLEADER: u32 = 2;
pub const COMAPT_MAXLOGNAME: u32 = 12;
pub const KIPC_MAXSOCKBUF: u32 = 1;
pub const KIPC_SOCKBUF_WASTE: u32 = 2;
pub const KIPC_SOMAXCONN: u32 = 3;
pub const KIPC_MAX_LINKHDR: u32 = 4;
pub const KIPC_MAX_PROTOHDR: u32 = 5;
pub const KIPC_MAX_HDR: u32 = 6;
pub const KIPC_MAX_DATALEN: u32 = 7;
pub const KIPC_MBSTAT: u32 = 8;
pub const KIPC_NMBCLUSTERS: u32 = 9;
pub const KIPC_SOQLIMITCOMPAT: u32 = 10;
pub const VM_METER: u32 = 1;
pub const VM_LOADAVG: u32 = 2;
pub const VM_MACHFACTOR: u32 = 4;
pub const VM_SWAPUSAGE: u32 = 5;
pub const VM_MAXID: u32 = 6;
pub const LSCALE: u32 = 1000;
pub const HW_MACHINE: u32 = 1;
pub const HW_MODEL: u32 = 2;
pub const HW_NCPU: u32 = 3;
pub const HW_BYTEORDER: u32 = 4;
pub const HW_PHYSMEM: u32 = 5;
pub const HW_USERMEM: u32 = 6;
pub const HW_PAGESIZE: u32 = 7;
pub const HW_DISKNAMES: u32 = 8;
pub const HW_DISKSTATS: u32 = 9;
pub const HW_EPOCH: u32 = 10;
pub const HW_FLOATINGPT: u32 = 11;
pub const HW_MACHINE_ARCH: u32 = 12;
pub const HW_VECTORUNIT: u32 = 13;
pub const HW_BUS_FREQ: u32 = 14;
pub const HW_CPU_FREQ: u32 = 15;
pub const HW_CACHELINE: u32 = 16;
pub const HW_L1ICACHESIZE: u32 = 17;
pub const HW_L1DCACHESIZE: u32 = 18;
pub const HW_L2SETTINGS: u32 = 19;
pub const HW_L2CACHESIZE: u32 = 20;
pub const HW_L3SETTINGS: u32 = 21;
pub const HW_L3CACHESIZE: u32 = 22;
pub const HW_TB_FREQ: u32 = 23;
pub const HW_MEMSIZE: u32 = 24;
pub const HW_AVAILCPU: u32 = 25;
pub const HW_TARGET: u32 = 26;
pub const HW_PRODUCT: u32 = 27;
pub const HW_MAXID: u32 = 28;
pub const USER_CS_PATH: u32 = 1;
pub const USER_BC_BASE_MAX: u32 = 2;
pub const USER_BC_DIM_MAX: u32 = 3;
pub const USER_BC_SCALE_MAX: u32 = 4;
pub const USER_BC_STRING_MAX: u32 = 5;
pub const USER_COLL_WEIGHTS_MAX: u32 = 6;
pub const USER_EXPR_NEST_MAX: u32 = 7;
pub const USER_LINE_MAX: u32 = 8;
pub const USER_RE_DUP_MAX: u32 = 9;
pub const USER_POSIX2_VERSION: u32 = 10;
pub const USER_POSIX2_C_BIND: u32 = 11;
pub const USER_POSIX2_C_DEV: u32 = 12;
pub const USER_POSIX2_CHAR_TERM: u32 = 13;
pub const USER_POSIX2_FORT_DEV: u32 = 14;
pub const USER_POSIX2_FORT_RUN: u32 = 15;
pub const USER_POSIX2_LOCALEDEF: u32 = 16;
pub const USER_POSIX2_SW_DEV: u32 = 17;
pub const USER_POSIX2_UPE: u32 = 18;
pub const USER_STREAM_MAX: u32 = 19;
pub const USER_TZNAME_MAX: u32 = 20;
pub const USER_MAXID: u32 = 21;
pub const CTL_DEBUG_NAME: u32 = 0;
pub const CTL_DEBUG_VALUE: u32 = 1;
pub const CTL_DEBUG_MAXID: u32 = 20;
pub const REG_BASIC: u32 = 0;
pub const REG_EXTENDED: u32 = 1;
pub const REG_ICASE: u32 = 2;
pub const REG_NOSUB: u32 = 4;
pub const REG_NEWLINE: u32 = 8;
pub const REG_NOSPEC: u32 = 16;
pub const REG_LITERAL: u32 = 16;
pub const REG_PEND: u32 = 32;
pub const REG_MINIMAL: u32 = 64;
pub const REG_UNGREEDY: u32 = 64;
pub const REG_DUMP: u32 = 128;
pub const REG_ENHANCED: u32 = 256;
pub const REG_ENOSYS: i32 = -1;
pub const REG_NOMATCH: u32 = 1;
pub const REG_BADPAT: u32 = 2;
pub const REG_ECOLLATE: u32 = 3;
pub const REG_ECTYPE: u32 = 4;
pub const REG_EESCAPE: u32 = 5;
pub const REG_ESUBREG: u32 = 6;
pub const REG_EBRACK: u32 = 7;
pub const REG_EPAREN: u32 = 8;
pub const REG_EBRACE: u32 = 9;
pub const REG_BADBR: u32 = 10;
pub const REG_ERANGE: u32 = 11;
pub const REG_ESPACE: u32 = 12;
pub const REG_BADRPT: u32 = 13;
pub const REG_EMPTY: u32 = 14;
pub const REG_ASSERT: u32 = 15;
pub const REG_INVARG: u32 = 16;
pub const REG_ILLSEQ: u32 = 17;
pub const REG_ATOI: u32 = 255;
pub const REG_ITOA: u32 = 256;
pub const REG_NOTBOL: u32 = 1;
pub const REG_NOTEOL: u32 = 2;
pub const REG_STARTEND: u32 = 4;
pub const REG_TRACE: u32 = 256;
pub const REG_LARGE: u32 = 512;
pub const REG_BACKR: u32 = 1024;
pub const REG_BACKTRACKING_MATCHER: u32 = 1024;
pub const no_argument: u32 = 0;
pub const required_argument: u32 = 1;
pub const optional_argument: u32 = 2;
pub const SPDK_CPUSET_SIZE: u32 = 1024;
pub const SPDK_DEFAULT_RPC_ADDR: &[u8; 19usize] = b"/var/tmp/spdk.sock\0";
pub const SPDK_APP_GETOPT_STRING: &[u8; 31usize] = b"c:de:ghi:m:n:p:r:s:uvA:B:L:RW:\0";
extern "C" {
    pub fn __assert_rtn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    );
}
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    fn test_field___mbstate8() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__mbstate8)
            )
        );
    }
    test_field___mbstate8();
    fn test_field__mbstateL() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(_mbstateL)
            )
        );
    }
    test_field__mbstateL();
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    fn test_field___routine() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_pthread_handler_rec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_pthread_handler_rec),
                "::",
                stringify!(__routine)
            )
        );
    }
    test_field___routine();
    fn test_field___arg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_pthread_handler_rec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_pthread_handler_rec),
                "::",
                stringify!(__arg)
            )
        );
    }
    test_field___arg();
    fn test_field___next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_pthread_handler_rec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_pthread_handler_rec),
                "::",
                stringify!(__next)
            )
        );
    }
    test_field___next();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_attr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_attr_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_attr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_attr_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_cond_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_cond_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_condattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_condattr_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_condattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_condattr_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_mutex_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_mutex_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_mutexattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_mutexattr_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_mutexattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_mutexattr_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_once_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_once_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_once_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_once_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_rwlock_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_rwlock_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_rwlockattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_rwlockattr_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_rwlockattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_rwlockattr_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___cleanup_stack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_t),
                "::",
                stringify!(__cleanup_stack)
            )
        );
    }
    test_field___cleanup_stack();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type size_t = __darwin_size_t;
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
pub type wint_t = __darwin_wint_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneEntry {
    pub __min: __darwin_rune_t,
    pub __max: __darwin_rune_t,
    pub __map: __darwin_rune_t,
    pub __types: *mut __uint32_t,
}
#[test]
fn bindgen_test_layout__RuneEntry() {
    assert_eq!(
        ::std::mem::size_of::<_RuneEntry>(),
        24usize,
        concat!("Size of: ", stringify!(_RuneEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneEntry))
    );
    fn test_field___min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__min) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneEntry),
                "::",
                stringify!(__min)
            )
        );
    }
    test_field___min();
    fn test_field___max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__max) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneEntry),
                "::",
                stringify!(__max)
            )
        );
    }
    test_field___max();
    fn test_field___map() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__map) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneEntry),
                "::",
                stringify!(__map)
            )
        );
    }
    test_field___map();
    fn test_field___types() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__types) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneEntry),
                "::",
                stringify!(__types)
            )
        );
    }
    test_field___types();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneRange {
    pub __nranges: ::std::os::raw::c_int,
    pub __ranges: *mut _RuneEntry,
}
#[test]
fn bindgen_test_layout__RuneRange() {
    assert_eq!(
        ::std::mem::size_of::<_RuneRange>(),
        16usize,
        concat!("Size of: ", stringify!(_RuneRange))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneRange>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneRange))
    );
    fn test_field___nranges() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneRange>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__nranges) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneRange),
                "::",
                stringify!(__nranges)
            )
        );
    }
    test_field___nranges();
    fn test_field___ranges() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneRange>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ranges) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneRange),
                "::",
                stringify!(__ranges)
            )
        );
    }
    test_field___ranges();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneCharClass {
    pub __name: [::std::os::raw::c_char; 14usize],
    pub __mask: __uint32_t,
}
#[test]
fn bindgen_test_layout__RuneCharClass() {
    assert_eq!(
        ::std::mem::size_of::<_RuneCharClass>(),
        20usize,
        concat!("Size of: ", stringify!(_RuneCharClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneCharClass>(),
        4usize,
        concat!("Alignment of ", stringify!(_RuneCharClass))
    );
    fn test_field___name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneCharClass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneCharClass),
                "::",
                stringify!(__name)
            )
        );
    }
    test_field___name();
    fn test_field___mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneCharClass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneCharClass),
                "::",
                stringify!(__mask)
            )
        );
    }
    test_field___mask();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneLocale {
    pub __magic: [::std::os::raw::c_char; 8usize],
    pub __encoding: [::std::os::raw::c_char; 32usize],
    pub __sgetrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: __darwin_size_t,
            arg3: *mut *const ::std::os::raw::c_char,
        ) -> __darwin_rune_t,
    >,
    pub __sputrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: __darwin_rune_t,
            arg2: *mut ::std::os::raw::c_char,
            arg3: __darwin_size_t,
            arg4: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub __invalid_rune: __darwin_rune_t,
    pub __runetype: [__uint32_t; 256usize],
    pub __maplower: [__darwin_rune_t; 256usize],
    pub __mapupper: [__darwin_rune_t; 256usize],
    pub __runetype_ext: _RuneRange,
    pub __maplower_ext: _RuneRange,
    pub __mapupper_ext: _RuneRange,
    pub __variable: *mut ::std::os::raw::c_void,
    pub __variable_len: ::std::os::raw::c_int,
    pub __ncharclasses: ::std::os::raw::c_int,
    pub __charclasses: *mut _RuneCharClass,
}
#[test]
fn bindgen_test_layout__RuneLocale() {
    assert_eq!(
        ::std::mem::size_of::<_RuneLocale>(),
        3208usize,
        concat!("Size of: ", stringify!(_RuneLocale))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneLocale>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneLocale))
    );
    fn test_field___magic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__magic) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__magic)
            )
        );
    }
    test_field___magic();
    fn test_field___encoding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__encoding) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__encoding)
            )
        );
    }
    test_field___encoding();
    fn test_field___sgetrune() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sgetrune) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__sgetrune)
            )
        );
    }
    test_field___sgetrune();
    fn test_field___sputrune() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sputrune) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__sputrune)
            )
        );
    }
    test_field___sputrune();
    fn test_field___invalid_rune() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__invalid_rune) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__invalid_rune)
            )
        );
    }
    test_field___invalid_rune();
    fn test_field___runetype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__runetype) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__runetype)
            )
        );
    }
    test_field___runetype();
    fn test_field___maplower() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__maplower) as usize - ptr as usize
            },
            1084usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__maplower)
            )
        );
    }
    test_field___maplower();
    fn test_field___mapupper() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mapupper) as usize - ptr as usize
            },
            2108usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__mapupper)
            )
        );
    }
    test_field___mapupper();
    fn test_field___runetype_ext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__runetype_ext) as usize - ptr as usize
            },
            3136usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__runetype_ext)
            )
        );
    }
    test_field___runetype_ext();
    fn test_field___maplower_ext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__maplower_ext) as usize - ptr as usize
            },
            3152usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__maplower_ext)
            )
        );
    }
    test_field___maplower_ext();
    fn test_field___mapupper_ext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mapupper_ext) as usize - ptr as usize
            },
            3168usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__mapupper_ext)
            )
        );
    }
    test_field___mapupper_ext();
    fn test_field___variable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__variable) as usize - ptr as usize
            },
            3184usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__variable)
            )
        );
    }
    test_field___variable();
    fn test_field___variable_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__variable_len) as usize - ptr as usize
            },
            3192usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__variable_len)
            )
        );
    }
    test_field___variable_len();
    fn test_field___ncharclasses() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ncharclasses) as usize - ptr as usize
            },
            3196usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__ncharclasses)
            )
        );
    }
    test_field___ncharclasses();
    fn test_field___charclasses() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__charclasses) as usize - ptr as usize
            },
            3200usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__charclasses)
            )
        );
    }
    test_field___charclasses();
}
extern "C" {
    pub static mut _DefaultRuneLocale: _RuneLocale;
}
extern "C" {
    pub static mut _CurrentRuneLocale: *mut _RuneLocale;
}
extern "C" {
    pub fn ___runetype(arg1: __darwin_ct_rune_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ___tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn ___toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn __maskrune(
        arg1: __darwin_ct_rune_t,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn __tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
pub type errno_t = ::std::os::raw::c_int;
extern "C" {
    pub fn __error() -> *mut ::std::os::raw::c_int;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<imaxdiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(imaxdiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<imaxdiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(imaxdiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type rsize_t = ::std::os::raw::c_ulong;
pub type max_align_t = f64;
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    fn test_field__base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sbuf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sbuf),
                "::",
                stringify!(_base)
            )
        );
    }
    test_field__base();
    fn test_field__size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sbuf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sbuf),
                "::",
                stringify!(_size)
            )
        );
    }
    test_field__size();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    fn test_field__p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._p) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_p)
            )
        );
    }
    test_field__p();
    fn test_field__r() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._r) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_r)
            )
        );
    }
    test_field__r();
    fn test_field__w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._w) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_w)
            )
        );
    }
    test_field__w();
    fn test_field__flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_flags)
            )
        );
    }
    test_field__flags();
    fn test_field__file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._file) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_file)
            )
        );
    }
    test_field__file();
    fn test_field__bf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_bf)
            )
        );
    }
    test_field__bf();
    fn test_field__lbfsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_lbfsize)
            )
        );
    }
    test_field__lbfsize();
    fn test_field__cookie() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_cookie)
            )
        );
    }
    test_field__cookie();
    fn test_field__close() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._close) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_close)
            )
        );
    }
    test_field__close();
    fn test_field__read() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._read) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_read)
            )
        );
    }
    test_field__read();
    fn test_field__seek() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_seek)
            )
        );
    }
    test_field__seek();
    fn test_field__write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._write) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_write)
            )
        );
    }
    test_field__write();
    fn test_field__ub() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_ub)
            )
        );
    }
    test_field__ub();
    fn test_field__extra() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._extra) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_extra)
            )
        );
    }
    test_field__extra();
    fn test_field__ur() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_ur)
            )
        );
    }
    test_field__ur();
    fn test_field__ubuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_ubuf)
            )
        );
    }
    test_field__ubuf();
    fn test_field__nbuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize
            },
            119usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_nbuf)
            )
        );
    }
    test_field__nbuf();
    fn test_field__lb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_lb)
            )
        );
    }
    test_field__lb();
    fn test_field__blksize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_blksize)
            )
        );
    }
    test_field__blksize();
    fn test_field__offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_offset)
            )
        );
    }
    test_field__offset();
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
pub type ssize_t = __darwin_ssize_t;
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut size_t,
        __stream: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: size_t,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: size_t,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
        arg5: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: size_t,
        arg4: *const ::std::os::raw::c_char,
        arg5: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
        arg5: *const ::std::os::raw::c_char,
        arg6: va_list,
    ) -> ::std::os::raw::c_int;
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state))
    );
    fn test_field___exception() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state),
                "::",
                stringify!(__exception)
            )
        );
    }
    test_field___exception();
    fn test_field___fsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fsr) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state),
                "::",
                stringify!(__fsr)
            )
        );
    }
    test_field___fsr();
    fn test_field___far() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state),
                "::",
                stringify!(__far)
            )
        );
    }
    test_field___far();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state64))
    );
    fn test_field___far() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state64),
                "::",
                stringify!(__far)
            )
        );
    }
    test_field___far();
    fn test_field___esr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__esr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state64),
                "::",
                stringify!(__esr)
            )
        );
    }
    test_field___esr();
    fn test_field___exception() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state64),
                "::",
                stringify!(__exception)
            )
        );
    }
    test_field___exception();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state>(),
        68usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state))
    );
    fn test_field___r() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state),
                "::",
                stringify!(__r)
            )
        );
    }
    test_field___r();
    fn test_field___sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state),
                "::",
                stringify!(__sp)
            )
        );
    }
    test_field___sp();
    fn test_field___lr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state),
                "::",
                stringify!(__lr)
            )
        );
    }
    test_field___lr();
    fn test_field___pc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state),
                "::",
                stringify!(__pc)
            )
        );
    }
    test_field___pc();
    fn test_field___cpsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state),
                "::",
                stringify!(__cpsr)
            )
        );
    }
    test_field___cpsr();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state64>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state64))
    );
    fn test_field___x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__x)
            )
        );
    }
    test_field___x();
    fn test_field___fp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fp) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__fp)
            )
        );
    }
    test_field___fp();
    fn test_field___lr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__lr)
            )
        );
    }
    test_field___lr();
    fn test_field___sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__sp)
            )
        );
    }
    test_field___sp();
    fn test_field___pc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__pc)
            )
        );
    }
    test_field___pc();
    fn test_field___cpsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__cpsr)
            )
        );
    }
    test_field___cpsr();
    fn test_field___pad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize
            },
            268usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__pad)
            )
        );
    }
    test_field___pad();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_vfp_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_vfp_state>(),
        260usize,
        concat!("Size of: ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_vfp_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_vfp_state))
    );
    fn test_field___r() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_vfp_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_vfp_state),
                "::",
                stringify!(__r)
            )
        );
    }
    test_field___r();
    fn test_field___fpscr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_vfp_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fpscr) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_vfp_state),
                "::",
                stringify!(__fpscr)
            )
        );
    }
    test_field___fpscr();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state64>(),
        528usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state64))
    );
    fn test_field___v() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state64),
                "::",
                stringify!(__v)
            )
        );
    }
    test_field___v();
    fn test_field___fpsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize
            },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state64),
                "::",
                stringify!(__fpsr)
            )
        );
    }
    test_field___fpsr();
    fn test_field___fpcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize
            },
            516usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state64),
                "::",
                stringify!(__fpcr)
            )
        );
    }
    test_field___fpcr();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state))
    );
    fn test_field___v() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state),
                "::",
                stringify!(__v)
            )
        );
    }
    test_field___v();
    fn test_field___fpsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state),
                "::",
                stringify!(__fpsr)
            )
        );
    }
    test_field___fpsr();
    fn test_field___fpcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize
            },
            260usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state),
                "::",
                stringify!(__fpcr)
            )
        );
    }
    test_field___fpcr();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___arm_pagein_state() {
    assert_eq!(
        ::std::mem::size_of::<__arm_pagein_state>(),
        4usize,
        concat!("Size of: ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_pagein_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_pagein_state))
    );
    fn test_field___pagein_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__arm_pagein_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pagein_error) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__arm_pagein_state),
                "::",
                stringify!(__pagein_error)
            )
        );
    }
    test_field___pagein_error();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[test]
fn bindgen_test_layout___arm_legacy_debug_state() {
    assert_eq!(
        ::std::mem::size_of::<__arm_legacy_debug_state>(),
        256usize,
        concat!("Size of: ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_legacy_debug_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_legacy_debug_state))
    );
    fn test_field___bvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__arm_legacy_debug_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__arm_legacy_debug_state),
                "::",
                stringify!(__bvr)
            )
        );
    }
    test_field___bvr();
    fn test_field___bcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__arm_legacy_debug_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(__arm_legacy_debug_state),
                "::",
                stringify!(__bcr)
            )
        );
    }
    test_field___bcr();
    fn test_field___wvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__arm_legacy_debug_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__arm_legacy_debug_state),
                "::",
                stringify!(__wvr)
            )
        );
    }
    test_field___wvr();
    fn test_field___wcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__arm_legacy_debug_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(__arm_legacy_debug_state),
                "::",
                stringify!(__wcr)
            )
        );
    }
    test_field___wcr();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state32>(),
        264usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state32>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state32))
    );
    fn test_field___bvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state32),
                "::",
                stringify!(__bvr)
            )
        );
    }
    test_field___bvr();
    fn test_field___bcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state32),
                "::",
                stringify!(__bcr)
            )
        );
    }
    test_field___bcr();
    fn test_field___wvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state32),
                "::",
                stringify!(__wvr)
            )
        );
    }
    test_field___wvr();
    fn test_field___wcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state32),
                "::",
                stringify!(__wcr)
            )
        );
    }
    test_field___wcr();
    fn test_field___mdscr_el1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state32),
                "::",
                stringify!(__mdscr_el1)
            )
        );
    }
    test_field___mdscr_el1();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state64>(),
        520usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state64))
    );
    fn test_field___bvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state64),
                "::",
                stringify!(__bvr)
            )
        );
    }
    test_field___bvr();
    fn test_field___bcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state64),
                "::",
                stringify!(__bcr)
            )
        );
    }
    test_field___bcr();
    fn test_field___wvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state64),
                "::",
                stringify!(__wvr)
            )
        );
    }
    test_field___wvr();
    fn test_field___wcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state64),
                "::",
                stringify!(__wcr)
            )
        );
    }
    test_field___wcr();
    fn test_field___mdscr_el1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize
            },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state64),
                "::",
                stringify!(__mdscr_el1)
            )
        );
    }
    test_field___mdscr_el1();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_arm_cpmu_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_cpmu_state64))
    );
    fn test_field___ctrs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_cpmu_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctrs) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_cpmu_state64),
                "::",
                stringify!(__ctrs)
            )
        );
    }
    test_field___ctrs();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_arm_exception_state,
    pub __ss: __darwin_arm_thread_state,
    pub __fs: __darwin_arm_vfp_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        340usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    fn test_field___es() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_mcontext32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_mcontext32),
                "::",
                stringify!(__es)
            )
        );
    }
    test_field___es();
    fn test_field___ss() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_mcontext32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_mcontext32),
                "::",
                stringify!(__ss)
            )
        );
    }
    test_field___ss();
    fn test_field___fs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_mcontext32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_mcontext32),
                "::",
                stringify!(__fs)
            )
        );
    }
    test_field___fs();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_arm_exception_state64,
    pub __ss: __darwin_arm_thread_state64,
    pub __ns: __darwin_arm_neon_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        816usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    fn test_field___es() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_mcontext64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_mcontext64),
                "::",
                stringify!(__es)
            )
        );
    }
    test_field___es();
    fn test_field___ss() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_mcontext64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_mcontext64),
                "::",
                stringify!(__ss)
            )
        );
    }
    test_field___ss();
    fn test_field___ns() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_mcontext64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ns) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_mcontext64),
                "::",
                stringify!(__ns)
            )
        );
    }
    test_field___ns();
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    fn test_field_ss_sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_sigaltstack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_sigaltstack),
                "::",
                stringify!(ss_sp)
            )
        );
    }
    test_field_ss_sp();
    fn test_field_ss_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_sigaltstack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_sigaltstack),
                "::",
                stringify!(ss_size)
            )
        );
    }
    test_field_ss_size();
    fn test_field_ss_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_sigaltstack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_sigaltstack),
                "::",
                stringify!(ss_flags)
            )
        );
    }
    test_field_ss_flags();
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    fn test_field_uc_onstack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_ucontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_onstack) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_ucontext),
                "::",
                stringify!(uc_onstack)
            )
        );
    }
    test_field_uc_onstack();
    fn test_field_uc_sigmask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_ucontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_sigmask) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_ucontext),
                "::",
                stringify!(uc_sigmask)
            )
        );
    }
    test_field_uc_sigmask();
    fn test_field_uc_stack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_ucontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_stack) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_ucontext),
                "::",
                stringify!(uc_stack)
            )
        );
    }
    test_field_uc_stack();
    fn test_field_uc_link() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_ucontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_link) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_ucontext),
                "::",
                stringify!(uc_link)
            )
        );
    }
    test_field_uc_link();
    fn test_field_uc_mcsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_ucontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_mcsize) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_ucontext),
                "::",
                stringify!(uc_mcsize)
            )
        );
    }
    test_field_uc_mcsize();
    fn test_field_uc_mcontext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_ucontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_mcontext) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_ucontext),
                "::",
                stringify!(uc_mcontext)
            )
        );
    }
    test_field_uc_mcontext();
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    fn test_field_sival_int() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigval),
                "::",
                stringify!(sival_int)
            )
        );
    }
    test_field_sival_int();
    fn test_field_sival_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigval),
                "::",
                stringify!(sival_ptr)
            )
        );
    }
    test_field_sival_ptr();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    fn test_field_sigev_notify() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sigev_notify) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent),
                "::",
                stringify!(sigev_notify)
            )
        );
    }
    test_field_sigev_notify();
    fn test_field_sigev_signo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sigev_signo) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent),
                "::",
                stringify!(sigev_signo)
            )
        );
    }
    test_field_sigev_signo();
    fn test_field_sigev_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sigev_value) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent),
                "::",
                stringify!(sigev_value)
            )
        );
    }
    test_field_sigev_value();
    fn test_field_sigev_notify_function() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sigev_notify_function) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent),
                "::",
                stringify!(sigev_notify_function)
            )
        );
    }
    test_field_sigev_notify_function();
    fn test_field_sigev_notify_attributes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sigev_notify_attributes) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent),
                "::",
                stringify!(sigev_notify_attributes)
            )
        );
    }
    test_field_sigev_notify_attributes();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    fn test_field_si_signo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_signo)
            )
        );
    }
    test_field_si_signo();
    fn test_field_si_errno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_errno)
            )
        );
    }
    test_field_si_errno();
    fn test_field_si_code() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_code)
            )
        );
    }
    test_field_si_code();
    fn test_field_si_pid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_pid)
            )
        );
    }
    test_field_si_pid();
    fn test_field_si_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_uid)
            )
        );
    }
    test_field_si_uid();
    fn test_field_si_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_status) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_status)
            )
        );
    }
    test_field_si_status();
    fn test_field_si_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_addr) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_addr)
            )
        );
    }
    test_field_si_addr();
    fn test_field_si_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_value) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_value)
            )
        );
    }
    test_field_si_value();
    fn test_field_si_band() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_band) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_band)
            )
        );
    }
    test_field_si_band();
    fn test_field___pad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(__pad)
            )
        );
    }
    test_field___pad();
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    fn test_field___sa_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigaction_u>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sa_handler) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigaction_u),
                "::",
                stringify!(__sa_handler)
            )
        );
    }
    test_field___sa_handler();
    fn test_field___sa_sigaction() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigaction_u>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sa_sigaction) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigaction_u),
                "::",
                stringify!(__sa_sigaction)
            )
        );
    }
    test_field___sa_sigaction();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    fn test_field___sigaction_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigaction),
                "::",
                stringify!(__sigaction_u)
            )
        );
    }
    test_field___sigaction_u();
    fn test_field_sa_tramp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_tramp) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigaction),
                "::",
                stringify!(sa_tramp)
            )
        );
    }
    test_field_sa_tramp();
    fn test_field_sa_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigaction),
                "::",
                stringify!(sa_mask)
            )
        );
    }
    test_field_sa_mask();
    fn test_field_sa_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigaction),
                "::",
                stringify!(sa_flags)
            )
        );
    }
    test_field_sa_flags();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    fn test_field___sigaction_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigaction),
                "::",
                stringify!(__sigaction_u)
            )
        );
    }
    test_field___sigaction_u();
    fn test_field_sa_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sigaction),
                "::",
                stringify!(sa_mask)
            )
        );
    }
    test_field_sa_mask();
    fn test_field_sa_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(sigaction),
                "::",
                stringify!(sa_flags)
            )
        );
    }
    test_field_sa_flags();
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    fn test_field_sv_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigvec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sv_handler) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigvec),
                "::",
                stringify!(sv_handler)
            )
        );
    }
    test_field_sv_handler();
    fn test_field_sv_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigvec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sv_mask) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sigvec),
                "::",
                stringify!(sv_mask)
            )
        );
    }
    test_field_sv_mask();
    fn test_field_sv_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigvec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sv_flags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(sigvec),
                "::",
                stringify!(sv_flags)
            )
        );
    }
    test_field_sv_flags();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    fn test_field_ss_sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigstack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigstack),
                "::",
                stringify!(ss_sp)
            )
        );
    }
    test_field_ss_sp();
    fn test_field_ss_onstack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigstack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_onstack) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sigstack),
                "::",
                stringify!(ss_onstack)
            )
        );
    }
    test_field_ss_onstack();
}
extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_usec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_usec)
            )
        );
    }
    test_field_tv_usec();
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    fn test_field_ru_utime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_utime) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_utime)
            )
        );
    }
    test_field_ru_utime();
    fn test_field_ru_stime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_stime) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_stime)
            )
        );
    }
    test_field_ru_stime();
    fn test_field_ru_maxrss() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_maxrss) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_maxrss)
            )
        );
    }
    test_field_ru_maxrss();
    fn test_field_ru_ixrss() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_ixrss) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_ixrss)
            )
        );
    }
    test_field_ru_ixrss();
    fn test_field_ru_idrss() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_idrss) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_idrss)
            )
        );
    }
    test_field_ru_idrss();
    fn test_field_ru_isrss() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_isrss) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_isrss)
            )
        );
    }
    test_field_ru_isrss();
    fn test_field_ru_minflt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_minflt) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_minflt)
            )
        );
    }
    test_field_ru_minflt();
    fn test_field_ru_majflt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_majflt) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_majflt)
            )
        );
    }
    test_field_ru_majflt();
    fn test_field_ru_nswap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_nswap) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_nswap)
            )
        );
    }
    test_field_ru_nswap();
    fn test_field_ru_inblock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_inblock) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_inblock)
            )
        );
    }
    test_field_ru_inblock();
    fn test_field_ru_oublock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_oublock) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_oublock)
            )
        );
    }
    test_field_ru_oublock();
    fn test_field_ru_msgsnd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_msgsnd) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_msgsnd)
            )
        );
    }
    test_field_ru_msgsnd();
    fn test_field_ru_msgrcv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_msgrcv) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_msgrcv)
            )
        );
    }
    test_field_ru_msgrcv();
    fn test_field_ru_nsignals() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_nsignals) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_nsignals)
            )
        );
    }
    test_field_ru_nsignals();
    fn test_field_ru_nvcsw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_nvcsw) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_nvcsw)
            )
        );
    }
    test_field_ru_nvcsw();
    fn test_field_ru_nivcsw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_nivcsw) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_nivcsw)
            )
        );
    }
    test_field_ru_nivcsw();
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v0>(),
        96usize,
        concat!("Size of: ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v0))
    );
    fn test_field_ri_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_uuid)
            )
        );
    }
    test_field_ri_uuid();
    fn test_field_ri_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_user_time)
            )
        );
    }
    test_field_ri_user_time();
    fn test_field_ri_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_system_time)
            )
        );
    }
    test_field_ri_system_time();
    fn test_field_ri_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_pkg_idle_wkups();
    fn test_field_ri_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_interrupt_wkups)
            )
        );
    }
    test_field_ri_interrupt_wkups();
    fn test_field_ri_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_pageins)
            )
        );
    }
    test_field_ri_pageins();
    fn test_field_ri_wired_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_wired_size)
            )
        );
    }
    test_field_ri_wired_size();
    fn test_field_ri_resident_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_resident_size)
            )
        );
    }
    test_field_ri_resident_size();
    fn test_field_ri_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_phys_footprint)
            )
        );
    }
    test_field_ri_phys_footprint();
    fn test_field_ri_proc_start_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_proc_start_abstime)
            )
        );
    }
    test_field_ri_proc_start_abstime();
    fn test_field_ri_proc_exit_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_proc_exit_abstime)
            )
        );
    }
    test_field_ri_proc_exit_abstime();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v1>(),
        144usize,
        concat!("Size of: ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v1))
    );
    fn test_field_ri_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_uuid)
            )
        );
    }
    test_field_ri_uuid();
    fn test_field_ri_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_user_time)
            )
        );
    }
    test_field_ri_user_time();
    fn test_field_ri_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_system_time)
            )
        );
    }
    test_field_ri_system_time();
    fn test_field_ri_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_pkg_idle_wkups();
    fn test_field_ri_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_interrupt_wkups)
            )
        );
    }
    test_field_ri_interrupt_wkups();
    fn test_field_ri_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_pageins)
            )
        );
    }
    test_field_ri_pageins();
    fn test_field_ri_wired_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_wired_size)
            )
        );
    }
    test_field_ri_wired_size();
    fn test_field_ri_resident_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_resident_size)
            )
        );
    }
    test_field_ri_resident_size();
    fn test_field_ri_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_phys_footprint)
            )
        );
    }
    test_field_ri_phys_footprint();
    fn test_field_ri_proc_start_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_proc_start_abstime)
            )
        );
    }
    test_field_ri_proc_start_abstime();
    fn test_field_ri_proc_exit_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_proc_exit_abstime)
            )
        );
    }
    test_field_ri_proc_exit_abstime();
    fn test_field_ri_child_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_child_user_time)
            )
        );
    }
    test_field_ri_child_user_time();
    fn test_field_ri_child_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_child_system_time)
            )
        );
    }
    test_field_ri_child_system_time();
    fn test_field_ri_child_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_child_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_child_pkg_idle_wkups();
    fn test_field_ri_child_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_child_interrupt_wkups)
            )
        );
    }
    test_field_ri_child_interrupt_wkups();
    fn test_field_ri_child_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_child_pageins)
            )
        );
    }
    test_field_ri_child_pageins();
    fn test_field_ri_child_elapsed_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_child_elapsed_abstime)
            )
        );
    }
    test_field_ri_child_elapsed_abstime();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v2>(),
        160usize,
        concat!("Size of: ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v2))
    );
    fn test_field_ri_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_uuid)
            )
        );
    }
    test_field_ri_uuid();
    fn test_field_ri_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_user_time)
            )
        );
    }
    test_field_ri_user_time();
    fn test_field_ri_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_system_time)
            )
        );
    }
    test_field_ri_system_time();
    fn test_field_ri_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_pkg_idle_wkups();
    fn test_field_ri_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_interrupt_wkups)
            )
        );
    }
    test_field_ri_interrupt_wkups();
    fn test_field_ri_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_pageins)
            )
        );
    }
    test_field_ri_pageins();
    fn test_field_ri_wired_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_wired_size)
            )
        );
    }
    test_field_ri_wired_size();
    fn test_field_ri_resident_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_resident_size)
            )
        );
    }
    test_field_ri_resident_size();
    fn test_field_ri_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_phys_footprint)
            )
        );
    }
    test_field_ri_phys_footprint();
    fn test_field_ri_proc_start_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_proc_start_abstime)
            )
        );
    }
    test_field_ri_proc_start_abstime();
    fn test_field_ri_proc_exit_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_proc_exit_abstime)
            )
        );
    }
    test_field_ri_proc_exit_abstime();
    fn test_field_ri_child_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_child_user_time)
            )
        );
    }
    test_field_ri_child_user_time();
    fn test_field_ri_child_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_child_system_time)
            )
        );
    }
    test_field_ri_child_system_time();
    fn test_field_ri_child_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_child_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_child_pkg_idle_wkups();
    fn test_field_ri_child_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_child_interrupt_wkups)
            )
        );
    }
    test_field_ri_child_interrupt_wkups();
    fn test_field_ri_child_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_child_pageins)
            )
        );
    }
    test_field_ri_child_pageins();
    fn test_field_ri_child_elapsed_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_child_elapsed_abstime)
            )
        );
    }
    test_field_ri_child_elapsed_abstime();
    fn test_field_ri_diskio_bytesread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_diskio_bytesread)
            )
        );
    }
    test_field_ri_diskio_bytesread();
    fn test_field_ri_diskio_byteswritten() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_diskio_byteswritten)
            )
        );
    }
    test_field_ri_diskio_byteswritten();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v3>(),
        232usize,
        concat!("Size of: ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v3))
    );
    fn test_field_ri_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_uuid)
            )
        );
    }
    test_field_ri_uuid();
    fn test_field_ri_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_user_time)
            )
        );
    }
    test_field_ri_user_time();
    fn test_field_ri_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_system_time)
            )
        );
    }
    test_field_ri_system_time();
    fn test_field_ri_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_pkg_idle_wkups();
    fn test_field_ri_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_interrupt_wkups)
            )
        );
    }
    test_field_ri_interrupt_wkups();
    fn test_field_ri_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_pageins)
            )
        );
    }
    test_field_ri_pageins();
    fn test_field_ri_wired_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_wired_size)
            )
        );
    }
    test_field_ri_wired_size();
    fn test_field_ri_resident_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_resident_size)
            )
        );
    }
    test_field_ri_resident_size();
    fn test_field_ri_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_phys_footprint)
            )
        );
    }
    test_field_ri_phys_footprint();
    fn test_field_ri_proc_start_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_proc_start_abstime)
            )
        );
    }
    test_field_ri_proc_start_abstime();
    fn test_field_ri_proc_exit_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_proc_exit_abstime)
            )
        );
    }
    test_field_ri_proc_exit_abstime();
    fn test_field_ri_child_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_child_user_time)
            )
        );
    }
    test_field_ri_child_user_time();
    fn test_field_ri_child_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_child_system_time)
            )
        );
    }
    test_field_ri_child_system_time();
    fn test_field_ri_child_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_child_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_child_pkg_idle_wkups();
    fn test_field_ri_child_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_child_interrupt_wkups)
            )
        );
    }
    test_field_ri_child_interrupt_wkups();
    fn test_field_ri_child_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_child_pageins)
            )
        );
    }
    test_field_ri_child_pageins();
    fn test_field_ri_child_elapsed_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_child_elapsed_abstime)
            )
        );
    }
    test_field_ri_child_elapsed_abstime();
    fn test_field_ri_diskio_bytesread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_diskio_bytesread)
            )
        );
    }
    test_field_ri_diskio_bytesread();
    fn test_field_ri_diskio_byteswritten() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_diskio_byteswritten)
            )
        );
    }
    test_field_ri_diskio_byteswritten();
    fn test_field_ri_cpu_time_qos_default() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_cpu_time_qos_default)
            )
        );
    }
    test_field_ri_cpu_time_qos_default();
    fn test_field_ri_cpu_time_qos_maintenance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_cpu_time_qos_maintenance)
            )
        );
    }
    test_field_ri_cpu_time_qos_maintenance();
    fn test_field_ri_cpu_time_qos_background() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_cpu_time_qos_background)
            )
        );
    }
    test_field_ri_cpu_time_qos_background();
    fn test_field_ri_cpu_time_qos_utility() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_cpu_time_qos_utility)
            )
        );
    }
    test_field_ri_cpu_time_qos_utility();
    fn test_field_ri_cpu_time_qos_legacy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_cpu_time_qos_legacy)
            )
        );
    }
    test_field_ri_cpu_time_qos_legacy();
    fn test_field_ri_cpu_time_qos_user_initiated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_cpu_time_qos_user_initiated)
            )
        );
    }
    test_field_ri_cpu_time_qos_user_initiated();
    fn test_field_ri_cpu_time_qos_user_interactive() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize
                    - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_cpu_time_qos_user_interactive)
            )
        );
    }
    test_field_ri_cpu_time_qos_user_interactive();
    fn test_field_ri_billed_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_billed_system_time)
            )
        );
    }
    test_field_ri_billed_system_time();
    fn test_field_ri_serviced_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_serviced_system_time)
            )
        );
    }
    test_field_ri_serviced_system_time();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v4>(),
        296usize,
        concat!("Size of: ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v4>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v4))
    );
    fn test_field_ri_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_uuid)
            )
        );
    }
    test_field_ri_uuid();
    fn test_field_ri_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_user_time)
            )
        );
    }
    test_field_ri_user_time();
    fn test_field_ri_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_system_time)
            )
        );
    }
    test_field_ri_system_time();
    fn test_field_ri_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_pkg_idle_wkups();
    fn test_field_ri_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_interrupt_wkups)
            )
        );
    }
    test_field_ri_interrupt_wkups();
    fn test_field_ri_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_pageins)
            )
        );
    }
    test_field_ri_pageins();
    fn test_field_ri_wired_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_wired_size)
            )
        );
    }
    test_field_ri_wired_size();
    fn test_field_ri_resident_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_resident_size)
            )
        );
    }
    test_field_ri_resident_size();
    fn test_field_ri_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_phys_footprint)
            )
        );
    }
    test_field_ri_phys_footprint();
    fn test_field_ri_proc_start_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_proc_start_abstime)
            )
        );
    }
    test_field_ri_proc_start_abstime();
    fn test_field_ri_proc_exit_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_proc_exit_abstime)
            )
        );
    }
    test_field_ri_proc_exit_abstime();
    fn test_field_ri_child_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_child_user_time)
            )
        );
    }
    test_field_ri_child_user_time();
    fn test_field_ri_child_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_child_system_time)
            )
        );
    }
    test_field_ri_child_system_time();
    fn test_field_ri_child_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_child_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_child_pkg_idle_wkups();
    fn test_field_ri_child_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_child_interrupt_wkups)
            )
        );
    }
    test_field_ri_child_interrupt_wkups();
    fn test_field_ri_child_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_child_pageins)
            )
        );
    }
    test_field_ri_child_pageins();
    fn test_field_ri_child_elapsed_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_child_elapsed_abstime)
            )
        );
    }
    test_field_ri_child_elapsed_abstime();
    fn test_field_ri_diskio_bytesread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_diskio_bytesread)
            )
        );
    }
    test_field_ri_diskio_bytesread();
    fn test_field_ri_diskio_byteswritten() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_diskio_byteswritten)
            )
        );
    }
    test_field_ri_diskio_byteswritten();
    fn test_field_ri_cpu_time_qos_default() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cpu_time_qos_default)
            )
        );
    }
    test_field_ri_cpu_time_qos_default();
    fn test_field_ri_cpu_time_qos_maintenance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cpu_time_qos_maintenance)
            )
        );
    }
    test_field_ri_cpu_time_qos_maintenance();
    fn test_field_ri_cpu_time_qos_background() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cpu_time_qos_background)
            )
        );
    }
    test_field_ri_cpu_time_qos_background();
    fn test_field_ri_cpu_time_qos_utility() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cpu_time_qos_utility)
            )
        );
    }
    test_field_ri_cpu_time_qos_utility();
    fn test_field_ri_cpu_time_qos_legacy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cpu_time_qos_legacy)
            )
        );
    }
    test_field_ri_cpu_time_qos_legacy();
    fn test_field_ri_cpu_time_qos_user_initiated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cpu_time_qos_user_initiated)
            )
        );
    }
    test_field_ri_cpu_time_qos_user_initiated();
    fn test_field_ri_cpu_time_qos_user_interactive() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize
                    - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cpu_time_qos_user_interactive)
            )
        );
    }
    test_field_ri_cpu_time_qos_user_interactive();
    fn test_field_ri_billed_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_billed_system_time)
            )
        );
    }
    test_field_ri_billed_system_time();
    fn test_field_ri_serviced_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_serviced_system_time)
            )
        );
    }
    test_field_ri_serviced_system_time();
    fn test_field_ri_logical_writes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_logical_writes)
            )
        );
    }
    test_field_ri_logical_writes();
    fn test_field_ri_lifetime_max_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_lifetime_max_phys_footprint)
            )
        );
    }
    test_field_ri_lifetime_max_phys_footprint();
    fn test_field_ri_instructions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_instructions)
            )
        );
    }
    test_field_ri_instructions();
    fn test_field_ri_cycles() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cycles)
            )
        );
    }
    test_field_ri_cycles();
    fn test_field_ri_billed_energy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_billed_energy)
            )
        );
    }
    test_field_ri_billed_energy();
    fn test_field_ri_serviced_energy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_serviced_energy)
            )
        );
    }
    test_field_ri_serviced_energy();
    fn test_field_ri_interval_max_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_interval_max_phys_footprint)
            )
        );
    }
    test_field_ri_interval_max_phys_footprint();
    fn test_field_ri_runnable_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_runnable_time)
            )
        );
    }
    test_field_ri_runnable_time();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v5() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v5>(),
        304usize,
        concat!("Size of: ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v5>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v5))
    );
    fn test_field_ri_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_uuid)
            )
        );
    }
    test_field_ri_uuid();
    fn test_field_ri_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_user_time)
            )
        );
    }
    test_field_ri_user_time();
    fn test_field_ri_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_system_time)
            )
        );
    }
    test_field_ri_system_time();
    fn test_field_ri_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_pkg_idle_wkups();
    fn test_field_ri_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_interrupt_wkups)
            )
        );
    }
    test_field_ri_interrupt_wkups();
    fn test_field_ri_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_pageins)
            )
        );
    }
    test_field_ri_pageins();
    fn test_field_ri_wired_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_wired_size)
            )
        );
    }
    test_field_ri_wired_size();
    fn test_field_ri_resident_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_resident_size)
            )
        );
    }
    test_field_ri_resident_size();
    fn test_field_ri_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_phys_footprint)
            )
        );
    }
    test_field_ri_phys_footprint();
    fn test_field_ri_proc_start_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_proc_start_abstime)
            )
        );
    }
    test_field_ri_proc_start_abstime();
    fn test_field_ri_proc_exit_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_proc_exit_abstime)
            )
        );
    }
    test_field_ri_proc_exit_abstime();
    fn test_field_ri_child_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_child_user_time)
            )
        );
    }
    test_field_ri_child_user_time();
    fn test_field_ri_child_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_child_system_time)
            )
        );
    }
    test_field_ri_child_system_time();
    fn test_field_ri_child_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_child_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_child_pkg_idle_wkups();
    fn test_field_ri_child_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_child_interrupt_wkups)
            )
        );
    }
    test_field_ri_child_interrupt_wkups();
    fn test_field_ri_child_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_child_pageins)
            )
        );
    }
    test_field_ri_child_pageins();
    fn test_field_ri_child_elapsed_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_child_elapsed_abstime)
            )
        );
    }
    test_field_ri_child_elapsed_abstime();
    fn test_field_ri_diskio_bytesread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_diskio_bytesread)
            )
        );
    }
    test_field_ri_diskio_bytesread();
    fn test_field_ri_diskio_byteswritten() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_diskio_byteswritten)
            )
        );
    }
    test_field_ri_diskio_byteswritten();
    fn test_field_ri_cpu_time_qos_default() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cpu_time_qos_default)
            )
        );
    }
    test_field_ri_cpu_time_qos_default();
    fn test_field_ri_cpu_time_qos_maintenance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cpu_time_qos_maintenance)
            )
        );
    }
    test_field_ri_cpu_time_qos_maintenance();
    fn test_field_ri_cpu_time_qos_background() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cpu_time_qos_background)
            )
        );
    }
    test_field_ri_cpu_time_qos_background();
    fn test_field_ri_cpu_time_qos_utility() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cpu_time_qos_utility)
            )
        );
    }
    test_field_ri_cpu_time_qos_utility();
    fn test_field_ri_cpu_time_qos_legacy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cpu_time_qos_legacy)
            )
        );
    }
    test_field_ri_cpu_time_qos_legacy();
    fn test_field_ri_cpu_time_qos_user_initiated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cpu_time_qos_user_initiated)
            )
        );
    }
    test_field_ri_cpu_time_qos_user_initiated();
    fn test_field_ri_cpu_time_qos_user_interactive() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize
                    - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cpu_time_qos_user_interactive)
            )
        );
    }
    test_field_ri_cpu_time_qos_user_interactive();
    fn test_field_ri_billed_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_billed_system_time)
            )
        );
    }
    test_field_ri_billed_system_time();
    fn test_field_ri_serviced_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_serviced_system_time)
            )
        );
    }
    test_field_ri_serviced_system_time();
    fn test_field_ri_logical_writes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_logical_writes)
            )
        );
    }
    test_field_ri_logical_writes();
    fn test_field_ri_lifetime_max_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_lifetime_max_phys_footprint)
            )
        );
    }
    test_field_ri_lifetime_max_phys_footprint();
    fn test_field_ri_instructions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_instructions)
            )
        );
    }
    test_field_ri_instructions();
    fn test_field_ri_cycles() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cycles)
            )
        );
    }
    test_field_ri_cycles();
    fn test_field_ri_billed_energy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_billed_energy)
            )
        );
    }
    test_field_ri_billed_energy();
    fn test_field_ri_serviced_energy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_serviced_energy)
            )
        );
    }
    test_field_ri_serviced_energy();
    fn test_field_ri_interval_max_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_interval_max_phys_footprint)
            )
        );
    }
    test_field_ri_interval_max_phys_footprint();
    fn test_field_ri_runnable_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_runnable_time)
            )
        );
    }
    test_field_ri_runnable_time();
    fn test_field_ri_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_flags)
            )
        );
    }
    test_field_ri_flags();
}
pub type rusage_info_current = rusage_info_v5;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    fn test_field_rlim_cur() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rlimit>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rlim_cur) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rlimit),
                "::",
                stringify!(rlim_cur)
            )
        );
    }
    test_field_rlim_cur();
    fn test_field_rlim_max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rlimit>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rlim_max) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rlimit),
                "::",
                stringify!(rlim_max)
            )
        );
    }
    test_field_rlim_max();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    assert_eq!(
        ::std::mem::size_of::<proc_rlimit_control_wakeupmon>(),
        8usize,
        concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        ::std::mem::align_of::<proc_rlimit_control_wakeupmon>(),
        4usize,
        concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
    );
    fn test_field_wm_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<proc_rlimit_control_wakeupmon>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wm_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(proc_rlimit_control_wakeupmon),
                "::",
                stringify!(wm_flags)
            )
        );
    }
    test_field_wm_flags();
    fn test_field_wm_rate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<proc_rlimit_control_wakeupmon>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wm_rate) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(proc_rlimit_control_wakeupmon),
                "::",
                stringify!(wm_rate)
            )
        );
    }
    test_field_wm_rate();
}
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU16 {
    pub __val: u16,
}
#[test]
fn bindgen_test_layout__OSUnalignedU16() {
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU16>(),
        2usize,
        concat!("Size of: ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU16>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU16))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_OSUnalignedU16>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_OSUnalignedU16),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU32 {
    pub __val: u32,
}
#[test]
fn bindgen_test_layout__OSUnalignedU32() {
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU32>(),
        4usize,
        concat!("Size of: ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU32>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU32))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_OSUnalignedU32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_OSUnalignedU32),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU64 {
    pub __val: u64,
}
#[test]
fn bindgen_test_layout__OSUnalignedU64() {
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU64>(),
        8usize,
        concat!("Size of: ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU64>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU64))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_OSUnalignedU64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_OSUnalignedU64),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    fn test_field_w_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<wait>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w_status) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(wait),
                "::",
                stringify!(w_status)
            )
        );
    }
    test_field_w_status();
    fn test_field_w_T() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<wait>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w_T) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
        );
    }
    test_field_w_T();
    fn test_field_w_S() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<wait>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w_S) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
        );
    }
    test_field_w_S();
}
extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn alloca(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<div_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(div_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<div_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(div_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ldiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ldiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lldiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(lldiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __count: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(arg1: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const wchar_t,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: size_t);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strtonum(
        __numstr: *const ::std::os::raw::c_char,
        __minval: ::std::os::raw::c_longlong,
        __maxval: ::std::os::raw::c_longlong,
        __errstrp: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __b: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strncat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtok_r(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
        __lasts: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __s1: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: size_t) -> size_t;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memset_s(
        __s: *mut ::std::os::raw::c_void,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn memmem(
        __big: *const ::std::os::raw::c_void,
        __big_len: size_t,
        __little: *const ::std::os::raw::c_void,
        __little_len: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset_pattern4(
        __b: *mut ::std::os::raw::c_void,
        __pattern4: *const ::std::os::raw::c_void,
        __len: size_t,
    );
}
extern "C" {
    pub fn memset_pattern8(
        __b: *mut ::std::os::raw::c_void,
        __pattern8: *const ::std::os::raw::c_void,
        __len: size_t,
    );
}
extern "C" {
    pub fn memset_pattern16(
        __b: *mut ::std::os::raw::c_void,
        __pattern16: *const ::std::os::raw::c_void,
        __len: size_t,
    );
}
extern "C" {
    pub fn strcasestr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
        __len: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ssize_t,
    );
}
extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const ::std::os::raw::c_void,
        __b2: *const ::std::os::raw::c_void,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsignal_r(
        __sig: ::std::os::raw::c_int,
        __strsignalbuf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_nsec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_nsec)
            )
        );
    }
    test_field_tv_nsec();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    fn test_field_tm_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_sec)
            )
        );
    }
    test_field_tm_sec();
    fn test_field_tm_min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_min)
            )
        );
    }
    test_field_tm_min();
    fn test_field_tm_hour() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_hour)
            )
        );
    }
    test_field_tm_hour();
    fn test_field_tm_mday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_mday)
            )
        );
    }
    test_field_tm_mday();
    fn test_field_tm_mon() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_mon)
            )
        );
    }
    test_field_tm_mon();
    fn test_field_tm_year() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_year)
            )
        );
    }
    test_field_tm_year();
    fn test_field_tm_wday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_wday)
            )
        );
    }
    test_field_tm_wday();
    fn test_field_tm_yday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_yday)
            )
        );
    }
    test_field_tm_yday();
    fn test_field_tm_isdst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_isdst)
            )
        );
    }
    test_field_tm_isdst();
    fn test_field_tm_gmtoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_gmtoff)
            )
        );
    }
    test_field_tm_gmtoff();
    fn test_field_tm_zone() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_zone)
            )
        );
    }
    test_field_tm_zone();
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(ts: *mut timespec, base: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type nlink_t = __uint16_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    fn test_field_fds_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fd_set>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fd_set),
                "::",
                stringify!(fds_bits)
            )
        );
    }
    test_field_fds_bits();
}
extern "C" {
    pub fn __darwin_check_fd_set_overflow(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type fd_mask = __int32_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub type sa_family_t = __uint8_t;
pub type socklen_t = __darwin_socklen_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    fn test_field_iov_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iovec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iovec),
                "::",
                stringify!(iov_base)
            )
        );
    }
    test_field_iov_base();
    fn test_field_iov_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iovec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(iovec),
                "::",
                stringify!(iov_len)
            )
        );
    }
    test_field_iov_len();
}
pub type sae_associd_t = __uint32_t;
pub type sae_connid_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sa_endpoints {
    pub sae_srcif: ::std::os::raw::c_uint,
    pub sae_srcaddr: *const sockaddr,
    pub sae_srcaddrlen: socklen_t,
    pub sae_dstaddr: *const sockaddr,
    pub sae_dstaddrlen: socklen_t,
}
#[test]
fn bindgen_test_layout_sa_endpoints() {
    assert_eq!(
        ::std::mem::size_of::<sa_endpoints>(),
        40usize,
        concat!("Size of: ", stringify!(sa_endpoints))
    );
    assert_eq!(
        ::std::mem::align_of::<sa_endpoints>(),
        8usize,
        concat!("Alignment of ", stringify!(sa_endpoints))
    );
    fn test_field_sae_srcif() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sa_endpoints>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sae_srcif) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sa_endpoints),
                "::",
                stringify!(sae_srcif)
            )
        );
    }
    test_field_sae_srcif();
    fn test_field_sae_srcaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sa_endpoints>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sae_srcaddr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sa_endpoints),
                "::",
                stringify!(sae_srcaddr)
            )
        );
    }
    test_field_sae_srcaddr();
    fn test_field_sae_srcaddrlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sa_endpoints>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sae_srcaddrlen) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sa_endpoints),
                "::",
                stringify!(sae_srcaddrlen)
            )
        );
    }
    test_field_sae_srcaddrlen();
    fn test_field_sae_dstaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sa_endpoints>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sae_dstaddr) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sa_endpoints),
                "::",
                stringify!(sae_dstaddr)
            )
        );
    }
    test_field_sae_dstaddr();
    fn test_field_sae_dstaddrlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sa_endpoints>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sae_dstaddrlen) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(sa_endpoints),
                "::",
                stringify!(sae_dstaddrlen)
            )
        );
    }
    test_field_sae_dstaddrlen();
}
pub type sa_endpoints_t = sa_endpoints;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    fn test_field_l_onoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<linger>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_onoff) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(linger),
                "::",
                stringify!(l_onoff)
            )
        );
    }
    test_field_l_onoff();
    fn test_field_l_linger() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<linger>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_linger) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(linger),
                "::",
                stringify!(l_linger)
            )
        );
    }
    test_field_l_linger();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct so_np_extensions {
    pub npx_flags: u_int32_t,
    pub npx_mask: u_int32_t,
}
#[test]
fn bindgen_test_layout_so_np_extensions() {
    assert_eq!(
        ::std::mem::size_of::<so_np_extensions>(),
        8usize,
        concat!("Size of: ", stringify!(so_np_extensions))
    );
    assert_eq!(
        ::std::mem::align_of::<so_np_extensions>(),
        4usize,
        concat!("Alignment of ", stringify!(so_np_extensions))
    );
    fn test_field_npx_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<so_np_extensions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).npx_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(so_np_extensions),
                "::",
                stringify!(npx_flags)
            )
        );
    }
    test_field_npx_flags();
    fn test_field_npx_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<so_np_extensions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).npx_mask) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(so_np_extensions),
                "::",
                stringify!(npx_mask)
            )
        );
    }
    test_field_npx_mask();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        1usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    fn test_field_sa_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr),
                "::",
                stringify!(sa_len)
            )
        );
    }
    test_field_sa_len();
    fn test_field_sa_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr),
                "::",
                stringify!(sa_family)
            )
        );
    }
    test_field_sa_family();
    fn test_field_sa_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr),
                "::",
                stringify!(sa_data)
            )
        );
    }
    test_field_sa_data();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockproto {
    pub sp_family: __uint16_t,
    pub sp_protocol: __uint16_t,
}
#[test]
fn bindgen_test_layout_sockproto() {
    assert_eq!(
        ::std::mem::size_of::<sockproto>(),
        4usize,
        concat!("Size of: ", stringify!(sockproto))
    );
    assert_eq!(
        ::std::mem::align_of::<sockproto>(),
        2usize,
        concat!("Alignment of ", stringify!(sockproto))
    );
    fn test_field_sp_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockproto>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sp_family) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockproto),
                "::",
                stringify!(sp_family)
            )
        );
    }
    test_field_sp_family();
    fn test_field_sp_protocol() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockproto>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sp_protocol) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sockproto),
                "::",
                stringify!(sp_protocol)
            )
        );
    }
    test_field_sp_protocol();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_len: __uint8_t,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::std::os::raw::c_char; 6usize],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::std::os::raw::c_char; 112usize],
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    fn test_field_ss_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_storage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_storage),
                "::",
                stringify!(ss_len)
            )
        );
    }
    test_field_ss_len();
    fn test_field_ss_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_storage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_family) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_storage),
                "::",
                stringify!(ss_family)
            )
        );
    }
    test_field_ss_family();
    fn test_field___ss_pad1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_storage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ss_pad1) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_storage),
                "::",
                stringify!(__ss_pad1)
            )
        );
    }
    test_field___ss_pad1();
    fn test_field___ss_align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_storage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ss_align) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_storage),
                "::",
                stringify!(__ss_align)
            )
        );
    }
    test_field___ss_align();
    fn test_field___ss_pad2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_storage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ss_pad2) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_storage),
                "::",
                stringify!(__ss_pad2)
            )
        );
    }
    test_field___ss_pad2();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::std::os::raw::c_int,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        48usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    fn test_field_msg_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msg_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_name)
            )
        );
    }
    test_field_msg_name();
    fn test_field_msg_namelen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msg_namelen) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_namelen)
            )
        );
    }
    test_field_msg_namelen();
    fn test_field_msg_iov() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msg_iov) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_iov)
            )
        );
    }
    test_field_msg_iov();
    fn test_field_msg_iovlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msg_iovlen) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_iovlen)
            )
        );
    }
    test_field_msg_iovlen();
    fn test_field_msg_control() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msg_control) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_control)
            )
        );
    }
    test_field_msg_control();
    fn test_field_msg_controllen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msg_controllen) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_controllen)
            )
        );
    }
    test_field_msg_controllen();
    fn test_field_msg_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msg_flags) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_flags)
            )
        );
    }
    test_field_msg_flags();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        12usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    fn test_field_cmsg_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cmsghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmsg_len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cmsghdr),
                "::",
                stringify!(cmsg_len)
            )
        );
    }
    test_field_cmsg_len();
    fn test_field_cmsg_level() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cmsghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmsg_level) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cmsghdr),
                "::",
                stringify!(cmsg_level)
            )
        );
    }
    test_field_cmsg_level();
    fn test_field_cmsg_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cmsghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmsg_type) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cmsghdr),
                "::",
                stringify!(cmsg_type)
            )
        );
    }
    test_field_cmsg_type();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sf_hdtr {
    pub headers: *mut iovec,
    pub hdr_cnt: ::std::os::raw::c_int,
    pub trailers: *mut iovec,
    pub trl_cnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sf_hdtr() {
    assert_eq!(
        ::std::mem::size_of::<sf_hdtr>(),
        32usize,
        concat!("Size of: ", stringify!(sf_hdtr))
    );
    assert_eq!(
        ::std::mem::align_of::<sf_hdtr>(),
        8usize,
        concat!("Alignment of ", stringify!(sf_hdtr))
    );
    fn test_field_headers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sf_hdtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).headers) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sf_hdtr),
                "::",
                stringify!(headers)
            )
        );
    }
    test_field_headers();
    fn test_field_hdr_cnt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sf_hdtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hdr_cnt) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sf_hdtr),
                "::",
                stringify!(hdr_cnt)
            )
        );
    }
    test_field_hdr_cnt();
    fn test_field_trailers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sf_hdtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).trailers) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sf_hdtr),
                "::",
                stringify!(trailers)
            )
        );
    }
    test_field_trailers();
    fn test_field_trl_cnt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sf_hdtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).trl_cnt) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sf_hdtr),
                "::",
                stringify!(trl_cnt)
            )
        );
    }
    test_field_trl_cnt();
}
extern "C" {
    pub fn accept(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn recv(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
        arg4: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn recvfrom(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
        arg4: ::std::os::raw::c_int,
        arg5: *mut sockaddr,
        arg6: *mut socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn recvmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *mut msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn send(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
        arg4: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn sendmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *const msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn sendto(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
        arg4: ::std::os::raw::c_int,
        arg5: *const sockaddr,
        arg6: socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn setsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_void,
        arg5: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socket(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sendfile(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
        arg4: *mut off_t,
        arg5: *mut sf_hdtr,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pfctlinput(arg1: ::std::os::raw::c_int, arg2: *mut sockaddr);
}
extern "C" {
    pub fn connectx(
        arg1: ::std::os::raw::c_int,
        arg2: *const sa_endpoints_t,
        arg3: sae_associd_t,
        arg4: ::std::os::raw::c_uint,
        arg5: *const iovec,
        arg6: ::std::os::raw::c_uint,
        arg7: *mut size_t,
        arg8: *mut sae_connid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn disconnectx(
        arg1: ::std::os::raw::c_int,
        arg2: sae_associd_t,
        arg3: sae_connid_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    fn test_field_s_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<in_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).s_addr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in_addr),
                "::",
                stringify!(s_addr)
            )
        );
    }
    test_field_s_addr();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_len: __uint8_t,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    fn test_field_sin_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin_len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in),
                "::",
                stringify!(sin_len)
            )
        );
    }
    test_field_sin_len();
    fn test_field_sin_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin_family) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in),
                "::",
                stringify!(sin_family)
            )
        );
    }
    test_field_sin_family();
    fn test_field_sin_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin_port) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in),
                "::",
                stringify!(sin_port)
            )
        );
    }
    test_field_sin_port();
    fn test_field_sin_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin_addr) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in),
                "::",
                stringify!(sin_addr)
            )
        );
    }
    test_field_sin_addr();
    fn test_field_sin_zero() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin_zero) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in),
                "::",
                stringify!(sin_zero)
            )
        );
    }
    test_field_sin_zero();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    assert_eq!(
        ::std::mem::size_of::<ip_opts>(),
        44usize,
        concat!("Size of: ", stringify!(ip_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_opts>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_opts))
    );
    fn test_field_ip_dst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ip_dst) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_opts),
                "::",
                stringify!(ip_dst)
            )
        );
    }
    test_field_ip_dst();
    fn test_field_ip_opts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ip_opts) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_opts),
                "::",
                stringify!(ip_opts)
            )
        );
    }
    test_field_ip_opts();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    fn test_field_imr_multiaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip_mreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_mreq),
                "::",
                stringify!(imr_multiaddr)
            )
        );
    }
    test_field_imr_multiaddr();
    fn test_field_imr_interface() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip_mreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imr_interface) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_mreq),
                "::",
                stringify!(imr_interface)
            )
        );
    }
    test_field_imr_interface();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreqn))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreqn))
    );
    fn test_field_imr_multiaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip_mreqn>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_mreqn),
                "::",
                stringify!(imr_multiaddr)
            )
        );
    }
    test_field_imr_multiaddr();
    fn test_field_imr_address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip_mreqn>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imr_address) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_mreqn),
                "::",
                stringify!(imr_address)
            )
        );
    }
    test_field_imr_address();
    fn test_field_imr_ifindex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip_mreqn>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imr_ifindex) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_mreqn),
                "::",
                stringify!(imr_ifindex)
            )
        );
    }
    test_field_imr_ifindex();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_sourceaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq_source))
    );
    fn test_field_imr_multiaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip_mreq_source>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_mreq_source),
                "::",
                stringify!(imr_multiaddr)
            )
        );
    }
    test_field_imr_multiaddr();
    fn test_field_imr_sourceaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip_mreq_source>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imr_sourceaddr) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_mreq_source),
                "::",
                stringify!(imr_sourceaddr)
            )
        );
    }
    test_field_imr_sourceaddr();
    fn test_field_imr_interface() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip_mreq_source>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imr_interface) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_mreq_source),
                "::",
                stringify!(imr_interface)
            )
        );
    }
    test_field_imr_interface();
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    assert_eq!(
        ::std::mem::size_of::<group_req>(),
        132usize,
        concat!("Size of: ", stringify!(group_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_req>(),
        4usize,
        concat!("Alignment of ", stringify!(group_req))
    );
    fn test_field_gr_interface() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<group_req>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gr_interface) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(group_req),
                "::",
                stringify!(gr_interface)
            )
        );
    }
    test_field_gr_interface();
    fn test_field_gr_group() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<group_req>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gr_group) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(group_req),
                "::",
                stringify!(gr_group)
            )
        );
    }
    test_field_gr_group();
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    assert_eq!(
        ::std::mem::size_of::<group_source_req>(),
        260usize,
        concat!("Size of: ", stringify!(group_source_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_source_req>(),
        4usize,
        concat!("Alignment of ", stringify!(group_source_req))
    );
    fn test_field_gsr_interface() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<group_source_req>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gsr_interface) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(group_source_req),
                "::",
                stringify!(gsr_interface)
            )
        );
    }
    test_field_gsr_interface();
    fn test_field_gsr_group() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<group_source_req>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gsr_group) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(group_source_req),
                "::",
                stringify!(gsr_group)
            )
        );
    }
    test_field_gsr_group();
    fn test_field_gsr_source() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<group_source_req>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gsr_source) as usize - ptr as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(group_source_req),
                "::",
                stringify!(gsr_source)
            )
        );
    }
    test_field_gsr_source();
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct __msfilterreq {
    pub msfr_ifindex: u32,
    pub msfr_fmode: u32,
    pub msfr_nsrcs: u32,
    pub __msfr_align: u32,
    pub msfr_group: sockaddr_storage,
    pub msfr_srcs: *mut sockaddr_storage,
}
#[test]
fn bindgen_test_layout___msfilterreq() {
    assert_eq!(
        ::std::mem::size_of::<__msfilterreq>(),
        152usize,
        concat!("Size of: ", stringify!(__msfilterreq))
    );
    assert_eq!(
        ::std::mem::align_of::<__msfilterreq>(),
        4usize,
        concat!("Alignment of ", stringify!(__msfilterreq))
    );
    fn test_field_msfr_ifindex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__msfilterreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msfr_ifindex) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__msfilterreq),
                "::",
                stringify!(msfr_ifindex)
            )
        );
    }
    test_field_msfr_ifindex();
    fn test_field_msfr_fmode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__msfilterreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msfr_fmode) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__msfilterreq),
                "::",
                stringify!(msfr_fmode)
            )
        );
    }
    test_field_msfr_fmode();
    fn test_field_msfr_nsrcs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__msfilterreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msfr_nsrcs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__msfilterreq),
                "::",
                stringify!(msfr_nsrcs)
            )
        );
    }
    test_field_msfr_nsrcs();
    fn test_field___msfr_align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__msfilterreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__msfr_align) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__msfilterreq),
                "::",
                stringify!(__msfr_align)
            )
        );
    }
    test_field___msfr_align();
    fn test_field_msfr_group() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__msfilterreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msfr_group) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__msfilterreq),
                "::",
                stringify!(msfr_group)
            )
        );
    }
    test_field_msfr_group();
    fn test_field_msfr_srcs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__msfilterreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msfr_srcs) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(__msfilterreq),
                "::",
                stringify!(msfr_srcs)
            )
        );
    }
    test_field_msfr_srcs();
}
extern "C" {
    pub fn setipv4sourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: u32,
        arg5: u32,
        arg6: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getipv4sourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: *mut u32,
        arg5: *mut u32,
        arg6: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: u32,
        arg6: u32,
        arg7: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: *mut u32,
        arg6: *mut u32,
        arg7: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_uint,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<in_pktinfo>(),
        12usize,
        concat!("Size of: ", stringify!(in_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in_pktinfo))
    );
    fn test_field_ipi_ifindex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<in_pktinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ipi_ifindex) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in_pktinfo),
                "::",
                stringify!(ipi_ifindex)
            )
        );
    }
    test_field_ipi_ifindex();
    fn test_field_ipi_spec_dst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<in_pktinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ipi_spec_dst) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(in_pktinfo),
                "::",
                stringify!(ipi_spec_dst)
            )
        );
    }
    test_field_ipi_spec_dst();
    fn test_field_ipi_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<in_pktinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ipi_addr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(in_pktinfo),
                "::",
                stringify!(ipi_addr)
            )
        );
    }
    test_field_ipi_addr();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __u6_addr: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [__uint8_t; 16usize],
    pub __u6_addr16: [__uint16_t; 8usize],
    pub __u6_addr32: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    fn test_field___u6_addr8() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<in6_addr__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__u6_addr8) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in6_addr__bindgen_ty_1),
                "::",
                stringify!(__u6_addr8)
            )
        );
    }
    test_field___u6_addr8();
    fn test_field___u6_addr16() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<in6_addr__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__u6_addr16) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in6_addr__bindgen_ty_1),
                "::",
                stringify!(__u6_addr16)
            )
        );
    }
    test_field___u6_addr16();
    fn test_field___u6_addr32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<in6_addr__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__u6_addr32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in6_addr__bindgen_ty_1),
                "::",
                stringify!(__u6_addr32)
            )
        );
    }
    test_field___u6_addr32();
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    fn test_field___u6_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<in6_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__u6_addr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in6_addr),
                "::",
                stringify!(__u6_addr)
            )
        );
    }
    test_field___u6_addr();
}
pub type in6_addr_t = in6_addr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_len: __uint8_t,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: __uint32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: __uint32_t,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    fn test_field_sin6_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin6_len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in6),
                "::",
                stringify!(sin6_len)
            )
        );
    }
    test_field_sin6_len();
    fn test_field_sin6_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin6_family) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in6),
                "::",
                stringify!(sin6_family)
            )
        );
    }
    test_field_sin6_family();
    fn test_field_sin6_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin6_port) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in6),
                "::",
                stringify!(sin6_port)
            )
        );
    }
    test_field_sin6_port();
    fn test_field_sin6_flowinfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin6_flowinfo) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in6),
                "::",
                stringify!(sin6_flowinfo)
            )
        );
    }
    test_field_sin6_flowinfo();
    fn test_field_sin6_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin6_addr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in6),
                "::",
                stringify!(sin6_addr)
            )
        );
    }
    test_field_sin6_addr();
    fn test_field_sin6_scope_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin6_scope_id) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in6),
                "::",
                stringify!(sin6_scope_id)
            )
        );
    }
    test_field_sin6_scope_id();
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
extern "C" {
    pub static in6addr_nodelocal_allnodes: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allnodes: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allrouters: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allv2routers: in6_addr;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    fn test_field_ipv6mr_multiaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ipv6_mreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ipv6mr_multiaddr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_mreq),
                "::",
                stringify!(ipv6mr_multiaddr)
            )
        );
    }
    test_field_ipv6mr_multiaddr();
    fn test_field_ipv6mr_interface() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ipv6_mreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ipv6mr_interface) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_mreq),
                "::",
                stringify!(ipv6mr_interface)
            )
        );
    }
    test_field_ipv6mr_interface();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_in6_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<in6_pktinfo>(),
        20usize,
        concat!("Size of: ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_pktinfo))
    );
    fn test_field_ipi6_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<in6_pktinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ipi6_addr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in6_pktinfo),
                "::",
                stringify!(ipi6_addr)
            )
        );
    }
    test_field_ipi6_addr();
    fn test_field_ipi6_ifindex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<in6_pktinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ipi6_ifindex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(in6_pktinfo),
                "::",
                stringify!(ipi6_ifindex)
            )
        );
    }
    test_field_ipi6_ifindex();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: u32,
}
#[test]
fn bindgen_test_layout_ip6_mtuinfo() {
    assert_eq!(
        ::std::mem::size_of::<ip6_mtuinfo>(),
        32usize,
        concat!("Size of: ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_mtuinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ip6_mtuinfo))
    );
    fn test_field_ip6m_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip6_mtuinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ip6m_addr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ip6_mtuinfo),
                "::",
                stringify!(ip6m_addr)
            )
        );
    }
    test_field_ip6m_addr();
    fn test_field_ip6m_mtu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip6_mtuinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ip6m_mtu) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(ip6_mtuinfo),
                "::",
                stringify!(ip6m_mtu)
            )
        );
    }
    test_field_ip6m_mtu();
}
extern "C" {
    pub fn inet6_option_space(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut *mut cmsghdr,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_append(
        arg1: *mut cmsghdr,
        arg2: *const __uint8_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_alloc(
        arg1: *mut cmsghdr,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut __uint8_t;
}
extern "C" {
    pub fn inet6_option_next(
        arg1: *const cmsghdr,
        arg2: *mut *mut __uint8_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_find(
        arg1: *const cmsghdr,
        arg2: *mut *mut __uint8_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_space(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> size_t;
}
extern "C" {
    pub fn inet6_rthdr_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *mut cmsghdr;
}
extern "C" {
    pub fn inet6_rthdr_add(
        arg1: *mut cmsghdr,
        arg2: *const in6_addr,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_lasthop(
        arg1: *mut cmsghdr,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_segments(arg1: *const cmsghdr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_getaddr(arg1: *mut cmsghdr, arg2: ::std::os::raw::c_int) -> *mut in6_addr;
}
extern "C" {
    pub fn inet6_rthdr_getflags(
        arg1: *const cmsghdr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_append(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: __uint8_t,
        arg5: socklen_t,
        arg6: __uint8_t,
        arg7: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_finish(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_set_val(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_next(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut __uint8_t,
        arg5: *mut socklen_t,
        arg6: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_find(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: __uint8_t,
        arg5: *mut socklen_t,
        arg6: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_get_val(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_space(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> socklen_t;
}
extern "C" {
    pub fn inet6_rth_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn inet6_rth_add(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const in6_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_reverse(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_segments(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_getaddr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *mut in6_addr;
}
extern "C" {
    pub fn bindresvport(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bindresvport_sa(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_addr(arg1: *const ::std::os::raw::c_char) -> in_addr_t;
}
extern "C" {
    pub fn inet_ntoa(arg1: in_addr) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_ntop(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_char,
        arg4: socklen_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_pton(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ascii2addr(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn addr2ascii(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_aton(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_lnaof(arg1: in_addr) -> in_addr_t;
}
extern "C" {
    pub fn inet_makeaddr(arg1: in_addr_t, arg2: in_addr_t) -> in_addr;
}
extern "C" {
    pub fn inet_netof(arg1: in_addr) -> in_addr_t;
}
extern "C" {
    pub fn inet_network(arg1: *const ::std::os::raw::c_char) -> in_addr_t;
}
extern "C" {
    pub fn inet_net_ntop(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_char,
        arg5: __darwin_size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_net_pton(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: __darwin_size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_neta(
        arg1: in_addr_t,
        arg2: *mut ::std::os::raw::c_char,
        arg3: __darwin_size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_nsap_addr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn inet_nsap_ntoa(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_uchar,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent {
    pub d_ino: __uint64_t,
    pub d_seekoff: __uint64_t,
    pub d_reclen: __uint16_t,
    pub d_namlen: __uint16_t,
    pub d_type: __uint8_t,
    pub d_name: [::std::os::raw::c_char; 1024usize],
}
#[test]
fn bindgen_test_layout_dirent() {
    assert_eq!(
        ::std::mem::size_of::<dirent>(),
        1048usize,
        concat!("Size of: ", stringify!(dirent))
    );
    assert_eq!(
        ::std::mem::align_of::<dirent>(),
        8usize,
        concat!("Alignment of ", stringify!(dirent))
    );
    fn test_field_d_ino() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).d_ino) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dirent),
                "::",
                stringify!(d_ino)
            )
        );
    }
    test_field_d_ino();
    fn test_field_d_seekoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).d_seekoff) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dirent),
                "::",
                stringify!(d_seekoff)
            )
        );
    }
    test_field_d_seekoff();
    fn test_field_d_reclen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).d_reclen) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(dirent),
                "::",
                stringify!(d_reclen)
            )
        );
    }
    test_field_d_reclen();
    fn test_field_d_namlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).d_namlen) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(dirent),
                "::",
                stringify!(d_namlen)
            )
        );
    }
    test_field_d_namlen();
    fn test_field_d_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).d_type) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(dirent),
                "::",
                stringify!(d_type)
            )
        );
    }
    test_field_d_type();
    fn test_field_d_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).d_name) as usize - ptr as usize
            },
            21usize,
            concat!(
                "Offset of field: ",
                stringify!(dirent),
                "::",
                stringify!(d_name)
            )
        );
    }
    test_field_d_name();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _telldir {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DIR {
    pub __dd_fd: ::std::os::raw::c_int,
    pub __dd_loc: ::std::os::raw::c_long,
    pub __dd_size: ::std::os::raw::c_long,
    pub __dd_buf: *mut ::std::os::raw::c_char,
    pub __dd_len: ::std::os::raw::c_int,
    pub __dd_seek: ::std::os::raw::c_long,
    pub __padding: ::std::os::raw::c_long,
    pub __dd_flags: ::std::os::raw::c_int,
    pub __dd_lock: __darwin_pthread_mutex_t,
    pub __dd_td: *mut _telldir,
}
#[test]
fn bindgen_test_layout_DIR() {
    assert_eq!(
        ::std::mem::size_of::<DIR>(),
        136usize,
        concat!("Size of: ", stringify!(DIR))
    );
    assert_eq!(
        ::std::mem::align_of::<DIR>(),
        8usize,
        concat!("Alignment of ", stringify!(DIR))
    );
    fn test_field___dd_fd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DIR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__dd_fd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(DIR),
                "::",
                stringify!(__dd_fd)
            )
        );
    }
    test_field___dd_fd();
    fn test_field___dd_loc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DIR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__dd_loc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(DIR),
                "::",
                stringify!(__dd_loc)
            )
        );
    }
    test_field___dd_loc();
    fn test_field___dd_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DIR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__dd_size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(DIR),
                "::",
                stringify!(__dd_size)
            )
        );
    }
    test_field___dd_size();
    fn test_field___dd_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DIR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__dd_buf) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(DIR),
                "::",
                stringify!(__dd_buf)
            )
        );
    }
    test_field___dd_buf();
    fn test_field___dd_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DIR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__dd_len) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(DIR),
                "::",
                stringify!(__dd_len)
            )
        );
    }
    test_field___dd_len();
    fn test_field___dd_seek() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DIR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__dd_seek) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(DIR),
                "::",
                stringify!(__dd_seek)
            )
        );
    }
    test_field___dd_seek();
    fn test_field___padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DIR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__padding) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(DIR),
                "::",
                stringify!(__padding)
            )
        );
    }
    test_field___padding();
    fn test_field___dd_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DIR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__dd_flags) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(DIR),
                "::",
                stringify!(__dd_flags)
            )
        );
    }
    test_field___dd_flags();
    fn test_field___dd_lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DIR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__dd_lock) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(DIR),
                "::",
                stringify!(__dd_lock)
            )
        );
    }
    test_field___dd_lock();
    fn test_field___dd_td() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DIR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__dd_td) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(DIR),
                "::",
                stringify!(__dd_td)
            )
        );
    }
    test_field___dd_td();
}
extern "C" {
    pub fn closedir(arg1: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn opendir(arg1: *const ::std::os::raw::c_char) -> *mut DIR;
}
extern "C" {
    pub fn readdir(arg1: *mut DIR) -> *mut dirent;
}
extern "C" {
    pub fn readdir_r(
        arg1: *mut DIR,
        arg2: *mut dirent,
        arg3: *mut *mut dirent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewinddir(arg1: *mut DIR);
}
extern "C" {
    pub fn seekdir(arg1: *mut DIR, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn telldir(arg1: *mut DIR) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fdopendir(arg1: ::std::os::raw::c_int) -> *mut DIR;
}
extern "C" {
    pub fn alphasort(arg1: *mut *const dirent, arg2: *mut *const dirent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dirfd(dirp: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scandir(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut *mut dirent,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent,
                arg2: *mut *const dirent,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scandir_b(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut *mut dirent,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getdirentries_is_not_available_when_64_bit_inodes_are_in_effect"]
    pub fn getdirentries(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __opendir2(arg1: *const ::std::os::raw::c_char, arg2: ::std::os::raw::c_int)
        -> *mut DIR;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock {
    pub l_start: off_t,
    pub l_len: off_t,
    pub l_pid: pid_t,
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_flock() {
    assert_eq!(
        ::std::mem::size_of::<flock>(),
        24usize,
        concat!("Size of: ", stringify!(flock))
    );
    assert_eq!(
        ::std::mem::align_of::<flock>(),
        8usize,
        concat!("Alignment of ", stringify!(flock))
    );
    fn test_field_l_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<flock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_start) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(flock),
                "::",
                stringify!(l_start)
            )
        );
    }
    test_field_l_start();
    fn test_field_l_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<flock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_len) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(flock),
                "::",
                stringify!(l_len)
            )
        );
    }
    test_field_l_len();
    fn test_field_l_pid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<flock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_pid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(flock),
                "::",
                stringify!(l_pid)
            )
        );
    }
    test_field_l_pid();
    fn test_field_l_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<flock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_type) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(flock),
                "::",
                stringify!(l_type)
            )
        );
    }
    test_field_l_type();
    fn test_field_l_whence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<flock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_whence) as usize - ptr as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(flock),
                "::",
                stringify!(l_whence)
            )
        );
    }
    test_field_l_whence();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flocktimeout {
    pub fl: flock,
    pub timeout: timespec,
}
#[test]
fn bindgen_test_layout_flocktimeout() {
    assert_eq!(
        ::std::mem::size_of::<flocktimeout>(),
        40usize,
        concat!("Size of: ", stringify!(flocktimeout))
    );
    assert_eq!(
        ::std::mem::align_of::<flocktimeout>(),
        8usize,
        concat!("Alignment of ", stringify!(flocktimeout))
    );
    fn test_field_fl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<flocktimeout>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fl) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(flocktimeout),
                "::",
                stringify!(fl)
            )
        );
    }
    test_field_fl();
    fn test_field_timeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<flocktimeout>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(flocktimeout),
                "::",
                stringify!(timeout)
            )
        );
    }
    test_field_timeout();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct radvisory {
    pub ra_offset: off_t,
    pub ra_count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_radvisory() {
    assert_eq!(
        ::std::mem::size_of::<radvisory>(),
        16usize,
        concat!("Size of: ", stringify!(radvisory))
    );
    assert_eq!(
        ::std::mem::align_of::<radvisory>(),
        8usize,
        concat!("Alignment of ", stringify!(radvisory))
    );
    fn test_field_ra_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<radvisory>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ra_offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(radvisory),
                "::",
                stringify!(ra_offset)
            )
        );
    }
    test_field_ra_offset();
    fn test_field_ra_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<radvisory>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ra_count) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(radvisory),
                "::",
                stringify!(ra_count)
            )
        );
    }
    test_field_ra_count();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsignatures {
    pub fs_file_start: off_t,
    pub fs_blob_start: *mut ::std::os::raw::c_void,
    pub fs_blob_size: size_t,
    pub fs_fsignatures_size: size_t,
    pub fs_cdhash: [::std::os::raw::c_char; 20usize],
    pub fs_hash_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_fsignatures() {
    assert_eq!(
        ::std::mem::size_of::<fsignatures>(),
        56usize,
        concat!("Size of: ", stringify!(fsignatures))
    );
    assert_eq!(
        ::std::mem::align_of::<fsignatures>(),
        8usize,
        concat!("Alignment of ", stringify!(fsignatures))
    );
    fn test_field_fs_file_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fsignatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fs_file_start) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fsignatures),
                "::",
                stringify!(fs_file_start)
            )
        );
    }
    test_field_fs_file_start();
    fn test_field_fs_blob_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fsignatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fs_blob_start) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fsignatures),
                "::",
                stringify!(fs_blob_start)
            )
        );
    }
    test_field_fs_blob_start();
    fn test_field_fs_blob_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fsignatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fs_blob_size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fsignatures),
                "::",
                stringify!(fs_blob_size)
            )
        );
    }
    test_field_fs_blob_size();
    fn test_field_fs_fsignatures_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fsignatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fs_fsignatures_size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fsignatures),
                "::",
                stringify!(fs_fsignatures_size)
            )
        );
    }
    test_field_fs_fsignatures_size();
    fn test_field_fs_cdhash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fsignatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fs_cdhash) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fsignatures),
                "::",
                stringify!(fs_cdhash)
            )
        );
    }
    test_field_fs_cdhash();
    fn test_field_fs_hash_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fsignatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fs_hash_type) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(fsignatures),
                "::",
                stringify!(fs_hash_type)
            )
        );
    }
    test_field_fs_hash_type();
}
pub type fsignatures_t = fsignatures;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsupplement {
    pub fs_file_start: off_t,
    pub fs_blob_start: off_t,
    pub fs_blob_size: size_t,
    pub fs_orig_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_fsupplement() {
    assert_eq!(
        ::std::mem::size_of::<fsupplement>(),
        32usize,
        concat!("Size of: ", stringify!(fsupplement))
    );
    assert_eq!(
        ::std::mem::align_of::<fsupplement>(),
        8usize,
        concat!("Alignment of ", stringify!(fsupplement))
    );
    fn test_field_fs_file_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fsupplement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fs_file_start) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fsupplement),
                "::",
                stringify!(fs_file_start)
            )
        );
    }
    test_field_fs_file_start();
    fn test_field_fs_blob_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fsupplement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fs_blob_start) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fsupplement),
                "::",
                stringify!(fs_blob_start)
            )
        );
    }
    test_field_fs_blob_start();
    fn test_field_fs_blob_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fsupplement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fs_blob_size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fsupplement),
                "::",
                stringify!(fs_blob_size)
            )
        );
    }
    test_field_fs_blob_size();
    fn test_field_fs_orig_fd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fsupplement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fs_orig_fd) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fsupplement),
                "::",
                stringify!(fs_orig_fd)
            )
        );
    }
    test_field_fs_orig_fd();
}
pub type fsupplement_t = fsupplement;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fchecklv {
    pub lv_file_start: off_t,
    pub lv_error_message_size: size_t,
    pub lv_error_message: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_fchecklv() {
    assert_eq!(
        ::std::mem::size_of::<fchecklv>(),
        24usize,
        concat!("Size of: ", stringify!(fchecklv))
    );
    assert_eq!(
        ::std::mem::align_of::<fchecklv>(),
        8usize,
        concat!("Alignment of ", stringify!(fchecklv))
    );
    fn test_field_lv_file_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fchecklv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lv_file_start) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fchecklv),
                "::",
                stringify!(lv_file_start)
            )
        );
    }
    test_field_lv_file_start();
    fn test_field_lv_error_message_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fchecklv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lv_error_message_size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fchecklv),
                "::",
                stringify!(lv_error_message_size)
            )
        );
    }
    test_field_lv_error_message_size();
    fn test_field_lv_error_message() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fchecklv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lv_error_message) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fchecklv),
                "::",
                stringify!(lv_error_message)
            )
        );
    }
    test_field_lv_error_message();
}
pub type fchecklv_t = fchecklv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fgetsigsinfo {
    pub fg_file_start: off_t,
    pub fg_info_request: ::std::os::raw::c_int,
    pub fg_sig_is_platform: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_fgetsigsinfo() {
    assert_eq!(
        ::std::mem::size_of::<fgetsigsinfo>(),
        16usize,
        concat!("Size of: ", stringify!(fgetsigsinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<fgetsigsinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(fgetsigsinfo))
    );
    fn test_field_fg_file_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fgetsigsinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fg_file_start) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fgetsigsinfo),
                "::",
                stringify!(fg_file_start)
            )
        );
    }
    test_field_fg_file_start();
    fn test_field_fg_info_request() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fgetsigsinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fg_info_request) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fgetsigsinfo),
                "::",
                stringify!(fg_info_request)
            )
        );
    }
    test_field_fg_info_request();
    fn test_field_fg_sig_is_platform() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fgetsigsinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fg_sig_is_platform) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fgetsigsinfo),
                "::",
                stringify!(fg_sig_is_platform)
            )
        );
    }
    test_field_fg_sig_is_platform();
}
pub type fgetsigsinfo_t = fgetsigsinfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fstore {
    pub fst_flags: ::std::os::raw::c_uint,
    pub fst_posmode: ::std::os::raw::c_int,
    pub fst_offset: off_t,
    pub fst_length: off_t,
    pub fst_bytesalloc: off_t,
}
#[test]
fn bindgen_test_layout_fstore() {
    assert_eq!(
        ::std::mem::size_of::<fstore>(),
        32usize,
        concat!("Size of: ", stringify!(fstore))
    );
    assert_eq!(
        ::std::mem::align_of::<fstore>(),
        8usize,
        concat!("Alignment of ", stringify!(fstore))
    );
    fn test_field_fst_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fstore>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fst_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fstore),
                "::",
                stringify!(fst_flags)
            )
        );
    }
    test_field_fst_flags();
    fn test_field_fst_posmode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fstore>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fst_posmode) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fstore),
                "::",
                stringify!(fst_posmode)
            )
        );
    }
    test_field_fst_posmode();
    fn test_field_fst_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fstore>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fst_offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fstore),
                "::",
                stringify!(fst_offset)
            )
        );
    }
    test_field_fst_offset();
    fn test_field_fst_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fstore>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fst_length) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fstore),
                "::",
                stringify!(fst_length)
            )
        );
    }
    test_field_fst_length();
    fn test_field_fst_bytesalloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fstore>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fst_bytesalloc) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fstore),
                "::",
                stringify!(fst_bytesalloc)
            )
        );
    }
    test_field_fst_bytesalloc();
}
pub type fstore_t = fstore;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpunchhole {
    pub fp_flags: ::std::os::raw::c_uint,
    pub reserved: ::std::os::raw::c_uint,
    pub fp_offset: off_t,
    pub fp_length: off_t,
}
#[test]
fn bindgen_test_layout_fpunchhole() {
    assert_eq!(
        ::std::mem::size_of::<fpunchhole>(),
        24usize,
        concat!("Size of: ", stringify!(fpunchhole))
    );
    assert_eq!(
        ::std::mem::align_of::<fpunchhole>(),
        8usize,
        concat!("Alignment of ", stringify!(fpunchhole))
    );
    fn test_field_fp_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fpunchhole>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fp_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fpunchhole),
                "::",
                stringify!(fp_flags)
            )
        );
    }
    test_field_fp_flags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fpunchhole>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fpunchhole),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
    fn test_field_fp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fpunchhole>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fpunchhole),
                "::",
                stringify!(fp_offset)
            )
        );
    }
    test_field_fp_offset();
    fn test_field_fp_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fpunchhole>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fp_length) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fpunchhole),
                "::",
                stringify!(fp_length)
            )
        );
    }
    test_field_fp_length();
}
pub type fpunchhole_t = fpunchhole;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ftrimactivefile {
    pub fta_offset: off_t,
    pub fta_length: off_t,
}
#[test]
fn bindgen_test_layout_ftrimactivefile() {
    assert_eq!(
        ::std::mem::size_of::<ftrimactivefile>(),
        16usize,
        concat!("Size of: ", stringify!(ftrimactivefile))
    );
    assert_eq!(
        ::std::mem::align_of::<ftrimactivefile>(),
        8usize,
        concat!("Alignment of ", stringify!(ftrimactivefile))
    );
    fn test_field_fta_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ftrimactivefile>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fta_offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ftrimactivefile),
                "::",
                stringify!(fta_offset)
            )
        );
    }
    test_field_fta_offset();
    fn test_field_fta_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ftrimactivefile>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fta_length) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ftrimactivefile),
                "::",
                stringify!(fta_length)
            )
        );
    }
    test_field_fta_length();
}
pub type ftrimactivefile_t = ftrimactivefile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fspecread {
    pub fsr_flags: ::std::os::raw::c_uint,
    pub reserved: ::std::os::raw::c_uint,
    pub fsr_offset: off_t,
    pub fsr_length: off_t,
}
#[test]
fn bindgen_test_layout_fspecread() {
    assert_eq!(
        ::std::mem::size_of::<fspecread>(),
        24usize,
        concat!("Size of: ", stringify!(fspecread))
    );
    assert_eq!(
        ::std::mem::align_of::<fspecread>(),
        8usize,
        concat!("Alignment of ", stringify!(fspecread))
    );
    fn test_field_fsr_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fspecread>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fsr_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fspecread),
                "::",
                stringify!(fsr_flags)
            )
        );
    }
    test_field_fsr_flags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fspecread>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fspecread),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
    fn test_field_fsr_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fspecread>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fsr_offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fspecread),
                "::",
                stringify!(fsr_offset)
            )
        );
    }
    test_field_fsr_offset();
    fn test_field_fsr_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fspecread>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fsr_length) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fspecread),
                "::",
                stringify!(fsr_length)
            )
        );
    }
    test_field_fsr_length();
}
pub type fspecread_t = fspecread;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fbootstraptransfer {
    pub fbt_offset: off_t,
    pub fbt_length: size_t,
    pub fbt_buffer: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_fbootstraptransfer() {
    assert_eq!(
        ::std::mem::size_of::<fbootstraptransfer>(),
        24usize,
        concat!("Size of: ", stringify!(fbootstraptransfer))
    );
    assert_eq!(
        ::std::mem::align_of::<fbootstraptransfer>(),
        8usize,
        concat!("Alignment of ", stringify!(fbootstraptransfer))
    );
    fn test_field_fbt_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fbootstraptransfer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fbt_offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fbootstraptransfer),
                "::",
                stringify!(fbt_offset)
            )
        );
    }
    test_field_fbt_offset();
    fn test_field_fbt_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fbootstraptransfer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fbt_length) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fbootstraptransfer),
                "::",
                stringify!(fbt_length)
            )
        );
    }
    test_field_fbt_length();
    fn test_field_fbt_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fbootstraptransfer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fbt_buffer) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fbootstraptransfer),
                "::",
                stringify!(fbt_buffer)
            )
        );
    }
    test_field_fbt_buffer();
}
pub type fbootstraptransfer_t = fbootstraptransfer;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct log2phys {
    pub l2p_flags: ::std::os::raw::c_uint,
    pub l2p_contigbytes: off_t,
    pub l2p_devoffset: off_t,
}
#[test]
fn bindgen_test_layout_log2phys() {
    assert_eq!(
        ::std::mem::size_of::<log2phys>(),
        20usize,
        concat!("Size of: ", stringify!(log2phys))
    );
    assert_eq!(
        ::std::mem::align_of::<log2phys>(),
        4usize,
        concat!("Alignment of ", stringify!(log2phys))
    );
    fn test_field_l2p_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<log2phys>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l2p_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(log2phys),
                "::",
                stringify!(l2p_flags)
            )
        );
    }
    test_field_l2p_flags();
    fn test_field_l2p_contigbytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<log2phys>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l2p_contigbytes) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(log2phys),
                "::",
                stringify!(l2p_contigbytes)
            )
        );
    }
    test_field_l2p_contigbytes();
    fn test_field_l2p_devoffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<log2phys>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l2p_devoffset) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(log2phys),
                "::",
                stringify!(l2p_devoffset)
            )
        );
    }
    test_field_l2p_devoffset();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _filesec {
    _unused: [u8; 0],
}
pub type filesec_t = *mut _filesec;
pub const filesec_property_t_FILESEC_OWNER: filesec_property_t = 1;
pub const filesec_property_t_FILESEC_GROUP: filesec_property_t = 2;
pub const filesec_property_t_FILESEC_UUID: filesec_property_t = 3;
pub const filesec_property_t_FILESEC_MODE: filesec_property_t = 4;
pub const filesec_property_t_FILESEC_ACL: filesec_property_t = 5;
pub const filesec_property_t_FILESEC_GRPUUID: filesec_property_t = 6;
pub const filesec_property_t_FILESEC_ACL_RAW: filesec_property_t = 100;
pub const filesec_property_t_FILESEC_ACL_ALLOCSIZE: filesec_property_t = 101;
pub type filesec_property_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn open(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn creat(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcntl(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openx_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn open_dprotected_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flock(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn filesec_init() -> filesec_t;
}
extern "C" {
    pub fn filesec_dup(arg1: filesec_t) -> filesec_t;
}
extern "C" {
    pub fn filesec_free(arg1: filesec_t);
}
extern "C" {
    pub fn filesec_get_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn filesec_query_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn filesec_set_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn filesec_unset_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifaddrs {
    pub ifa_next: *mut ifaddrs,
    pub ifa_name: *mut ::std::os::raw::c_char,
    pub ifa_flags: ::std::os::raw::c_uint,
    pub ifa_addr: *mut sockaddr,
    pub ifa_netmask: *mut sockaddr,
    pub ifa_dstaddr: *mut sockaddr,
    pub ifa_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ifaddrs() {
    assert_eq!(
        ::std::mem::size_of::<ifaddrs>(),
        56usize,
        concat!("Size of: ", stringify!(ifaddrs))
    );
    assert_eq!(
        ::std::mem::align_of::<ifaddrs>(),
        8usize,
        concat!("Alignment of ", stringify!(ifaddrs))
    );
    fn test_field_ifa_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifa_next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaddrs),
                "::",
                stringify!(ifa_next)
            )
        );
    }
    test_field_ifa_next();
    fn test_field_ifa_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifa_name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaddrs),
                "::",
                stringify!(ifa_name)
            )
        );
    }
    test_field_ifa_name();
    fn test_field_ifa_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifa_flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaddrs),
                "::",
                stringify!(ifa_flags)
            )
        );
    }
    test_field_ifa_flags();
    fn test_field_ifa_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifa_addr) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaddrs),
                "::",
                stringify!(ifa_addr)
            )
        );
    }
    test_field_ifa_addr();
    fn test_field_ifa_netmask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifa_netmask) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaddrs),
                "::",
                stringify!(ifa_netmask)
            )
        );
    }
    test_field_ifa_netmask();
    fn test_field_ifa_dstaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifa_dstaddr) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaddrs),
                "::",
                stringify!(ifa_dstaddr)
            )
        );
    }
    test_field_ifa_dstaddr();
    fn test_field_ifa_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifa_data) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaddrs),
                "::",
                stringify!(ifa_data)
            )
        );
    }
    test_field_ifa_data();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifmaddrs {
    pub ifma_next: *mut ifmaddrs,
    pub ifma_name: *mut sockaddr,
    pub ifma_addr: *mut sockaddr,
    pub ifma_lladdr: *mut sockaddr,
}
#[test]
fn bindgen_test_layout_ifmaddrs() {
    assert_eq!(
        ::std::mem::size_of::<ifmaddrs>(),
        32usize,
        concat!("Size of: ", stringify!(ifmaddrs))
    );
    assert_eq!(
        ::std::mem::align_of::<ifmaddrs>(),
        8usize,
        concat!("Alignment of ", stringify!(ifmaddrs))
    );
    fn test_field_ifma_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifma_next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmaddrs),
                "::",
                stringify!(ifma_next)
            )
        );
    }
    test_field_ifma_next();
    fn test_field_ifma_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifma_name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmaddrs),
                "::",
                stringify!(ifma_name)
            )
        );
    }
    test_field_ifma_name();
    fn test_field_ifma_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifma_addr) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmaddrs),
                "::",
                stringify!(ifma_addr)
            )
        );
    }
    test_field_ifma_addr();
    fn test_field_ifma_lladdr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifma_lladdr) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmaddrs),
                "::",
                stringify!(ifma_lladdr)
            )
        );
    }
    test_field_ifma_lladdr();
}
extern "C" {
    pub fn getifaddrs(arg1: *mut *mut ifaddrs) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn freeifaddrs(arg1: *mut ifaddrs);
}
extern "C" {
    pub fn getifmaddrs(arg1: *mut *mut ifmaddrs) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn freeifmaddrs(arg1: *mut ifmaddrs);
}
extern "C" {
    pub static mut h_errno: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::std::os::raw::c_char,
    pub h_aliases: *mut *mut ::std::os::raw::c_char,
    pub h_addrtype: ::std::os::raw::c_int,
    pub h_length: ::std::os::raw::c_int,
    pub h_addr_list: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hostent() {
    assert_eq!(
        ::std::mem::size_of::<hostent>(),
        32usize,
        concat!("Size of: ", stringify!(hostent))
    );
    assert_eq!(
        ::std::mem::align_of::<hostent>(),
        8usize,
        concat!("Alignment of ", stringify!(hostent))
    );
    fn test_field_h_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hostent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).h_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hostent),
                "::",
                stringify!(h_name)
            )
        );
    }
    test_field_h_name();
    fn test_field_h_aliases() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hostent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).h_aliases) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hostent),
                "::",
                stringify!(h_aliases)
            )
        );
    }
    test_field_h_aliases();
    fn test_field_h_addrtype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hostent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).h_addrtype) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(hostent),
                "::",
                stringify!(h_addrtype)
            )
        );
    }
    test_field_h_addrtype();
    fn test_field_h_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hostent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).h_length) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(hostent),
                "::",
                stringify!(h_length)
            )
        );
    }
    test_field_h_length();
    fn test_field_h_addr_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hostent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).h_addr_list) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(hostent),
                "::",
                stringify!(h_addr_list)
            )
        );
    }
    test_field_h_addr_list();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netent {
    pub n_name: *mut ::std::os::raw::c_char,
    pub n_aliases: *mut *mut ::std::os::raw::c_char,
    pub n_addrtype: ::std::os::raw::c_int,
    pub n_net: u32,
}
#[test]
fn bindgen_test_layout_netent() {
    assert_eq!(
        ::std::mem::size_of::<netent>(),
        24usize,
        concat!("Size of: ", stringify!(netent))
    );
    assert_eq!(
        ::std::mem::align_of::<netent>(),
        8usize,
        concat!("Alignment of ", stringify!(netent))
    );
    fn test_field_n_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<netent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netent),
                "::",
                stringify!(n_name)
            )
        );
    }
    test_field_n_name();
    fn test_field_n_aliases() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<netent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_aliases) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netent),
                "::",
                stringify!(n_aliases)
            )
        );
    }
    test_field_n_aliases();
    fn test_field_n_addrtype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<netent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_addrtype) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(netent),
                "::",
                stringify!(n_addrtype)
            )
        );
    }
    test_field_n_addrtype();
    fn test_field_n_net() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<netent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_net) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(netent),
                "::",
                stringify!(n_net)
            )
        );
    }
    test_field_n_net();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servent {
    pub s_name: *mut ::std::os::raw::c_char,
    pub s_aliases: *mut *mut ::std::os::raw::c_char,
    pub s_port: ::std::os::raw::c_int,
    pub s_proto: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_servent() {
    assert_eq!(
        ::std::mem::size_of::<servent>(),
        32usize,
        concat!("Size of: ", stringify!(servent))
    );
    assert_eq!(
        ::std::mem::align_of::<servent>(),
        8usize,
        concat!("Alignment of ", stringify!(servent))
    );
    fn test_field_s_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<servent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).s_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(servent),
                "::",
                stringify!(s_name)
            )
        );
    }
    test_field_s_name();
    fn test_field_s_aliases() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<servent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).s_aliases) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(servent),
                "::",
                stringify!(s_aliases)
            )
        );
    }
    test_field_s_aliases();
    fn test_field_s_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<servent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).s_port) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(servent),
                "::",
                stringify!(s_port)
            )
        );
    }
    test_field_s_port();
    fn test_field_s_proto() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<servent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).s_proto) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(servent),
                "::",
                stringify!(s_proto)
            )
        );
    }
    test_field_s_proto();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protoent {
    pub p_name: *mut ::std::os::raw::c_char,
    pub p_aliases: *mut *mut ::std::os::raw::c_char,
    pub p_proto: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_protoent() {
    assert_eq!(
        ::std::mem::size_of::<protoent>(),
        24usize,
        concat!("Size of: ", stringify!(protoent))
    );
    assert_eq!(
        ::std::mem::align_of::<protoent>(),
        8usize,
        concat!("Alignment of ", stringify!(protoent))
    );
    fn test_field_p_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<protoent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(protoent),
                "::",
                stringify!(p_name)
            )
        );
    }
    test_field_p_name();
    fn test_field_p_aliases() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<protoent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_aliases) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(protoent),
                "::",
                stringify!(p_aliases)
            )
        );
    }
    test_field_p_aliases();
    fn test_field_p_proto() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<protoent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_proto) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(protoent),
                "::",
                stringify!(p_proto)
            )
        );
    }
    test_field_p_proto();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_canonname: *mut ::std::os::raw::c_char,
    pub ai_addr: *mut sockaddr,
    pub ai_next: *mut addrinfo,
}
#[test]
fn bindgen_test_layout_addrinfo() {
    assert_eq!(
        ::std::mem::size_of::<addrinfo>(),
        48usize,
        concat!("Size of: ", stringify!(addrinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<addrinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(addrinfo))
    );
    fn test_field_ai_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_flags)
            )
        );
    }
    test_field_ai_flags();
    fn test_field_ai_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_family) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_family)
            )
        );
    }
    test_field_ai_family();
    fn test_field_ai_socktype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_socktype) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_socktype)
            )
        );
    }
    test_field_ai_socktype();
    fn test_field_ai_protocol() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_protocol) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_protocol)
            )
        );
    }
    test_field_ai_protocol();
    fn test_field_ai_addrlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_addrlen) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_addrlen)
            )
        );
    }
    test_field_ai_addrlen();
    fn test_field_ai_canonname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_canonname) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_canonname)
            )
        );
    }
    test_field_ai_canonname();
    fn test_field_ai_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_addr) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_addr)
            )
        );
    }
    test_field_ai_addr();
    fn test_field_ai_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_next) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_next)
            )
        );
    }
    test_field_ai_next();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpcent {
    pub r_name: *mut ::std::os::raw::c_char,
    pub r_aliases: *mut *mut ::std::os::raw::c_char,
    pub r_number: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rpcent() {
    assert_eq!(
        ::std::mem::size_of::<rpcent>(),
        24usize,
        concat!("Size of: ", stringify!(rpcent))
    );
    assert_eq!(
        ::std::mem::align_of::<rpcent>(),
        8usize,
        concat!("Alignment of ", stringify!(rpcent))
    );
    fn test_field_r_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rpcent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).r_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rpcent),
                "::",
                stringify!(r_name)
            )
        );
    }
    test_field_r_name();
    fn test_field_r_aliases() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rpcent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).r_aliases) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rpcent),
                "::",
                stringify!(r_aliases)
            )
        );
    }
    test_field_r_aliases();
    fn test_field_r_number() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rpcent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).r_number) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rpcent),
                "::",
                stringify!(r_number)
            )
        );
    }
    test_field_r_number();
}
extern "C" {
    pub fn endhostent();
}
extern "C" {
    pub fn endnetent();
}
extern "C" {
    pub fn endprotoent();
}
extern "C" {
    pub fn endservent();
}
extern "C" {
    pub fn freeaddrinfo(arg1: *mut addrinfo);
}
extern "C" {
    pub fn gai_strerror(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn getaddrinfo(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const addrinfo,
        arg4: *mut *mut addrinfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostbyaddr(
        arg1: *const ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn gethostbyname(arg1: *const ::std::os::raw::c_char) -> *mut hostent;
}
extern "C" {
    pub fn gethostent() -> *mut hostent;
}
extern "C" {
    pub fn getnameinfo(
        arg1: *const sockaddr,
        arg2: socklen_t,
        arg3: *mut ::std::os::raw::c_char,
        arg4: socklen_t,
        arg5: *mut ::std::os::raw::c_char,
        arg6: socklen_t,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnetbyaddr(arg1: u32, arg2: ::std::os::raw::c_int) -> *mut netent;
}
extern "C" {
    pub fn getnetbyname(arg1: *const ::std::os::raw::c_char) -> *mut netent;
}
extern "C" {
    pub fn getnetent() -> *mut netent;
}
extern "C" {
    pub fn getprotobyname(arg1: *const ::std::os::raw::c_char) -> *mut protoent;
}
extern "C" {
    pub fn getprotobynumber(arg1: ::std::os::raw::c_int) -> *mut protoent;
}
extern "C" {
    pub fn getprotoent() -> *mut protoent;
}
extern "C" {
    pub fn getservbyname(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservbyport(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservent() -> *mut servent;
}
extern "C" {
    pub fn sethostent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setnetent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setprotoent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setservent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn freehostent(arg1: *mut hostent);
}
extern "C" {
    pub fn gethostbyname2(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn getipnodebyaddr(
        arg1: *const ::std::os::raw::c_void,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn getipnodebyname(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn getrpcbyname(name: *const ::std::os::raw::c_char) -> *mut rpcent;
}
extern "C" {
    pub fn getrpcbynumber(number: ::std::os::raw::c_int) -> *mut rpcent;
}
extern "C" {
    pub fn getrpcent() -> *mut rpcent;
}
extern "C" {
    pub fn setrpcent(stayopen: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endrpcent();
}
extern "C" {
    pub fn herror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn hstrerror(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn innetgr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnetgrent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn endnetgrent();
}
extern "C" {
    pub fn setnetgrent(arg1: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollfd {
    pub fd: ::std::os::raw::c_int,
    pub events: ::std::os::raw::c_short,
    pub revents: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_pollfd() {
    assert_eq!(
        ::std::mem::size_of::<pollfd>(),
        8usize,
        concat!("Size of: ", stringify!(pollfd))
    );
    assert_eq!(
        ::std::mem::align_of::<pollfd>(),
        4usize,
        concat!("Alignment of ", stringify!(pollfd))
    );
    fn test_field_fd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pollfd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pollfd),
                "::",
                stringify!(fd)
            )
        );
    }
    test_field_fd();
    fn test_field_events() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pollfd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(pollfd),
                "::",
                stringify!(events)
            )
        );
    }
    test_field_events();
    fn test_field_revents() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pollfd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).revents) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(pollfd),
                "::",
                stringify!(revents)
            )
        );
    }
    test_field_revents();
}
pub type nfds_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn poll(
        arg1: *mut pollfd,
        arg2: nfds_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
    pub __opaque: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        8usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    fn test_field_sched_priority() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sched_param>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_param),
                "::",
                stringify!(sched_priority)
            )
        );
    }
    test_field_sched_priority();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sched_param>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_param),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub const QOS_CLASS_USER_INTERACTIVE: _bindgen_ty_1 = 33;
pub const QOS_CLASS_USER_INITIATED: _bindgen_ty_1 = 25;
pub const QOS_CLASS_DEFAULT: _bindgen_ty_1 = 21;
pub const QOS_CLASS_UTILITY: _bindgen_ty_1 = 17;
pub const QOS_CLASS_BACKGROUND: _bindgen_ty_1 = 9;
pub const QOS_CLASS_UNSPECIFIED: _bindgen_ty_1 = 0;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub type qos_class_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn qos_class_self() -> qos_class_t;
}
extern "C" {
    pub fn qos_class_main() -> qos_class_t;
}
extern "C" {
    pub fn pthread_attr_set_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_get_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_set_qos_class_self_np(
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_get_qos_class_np(
        __pthread: pthread_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_override_s {
    _unused: [u8; 0],
}
pub type pthread_override_t = *mut pthread_override_s;
extern "C" {
    pub fn pthread_override_qos_class_start_np(
        __pthread: pthread_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> pthread_override_t;
}
extern "C" {
    pub fn pthread_override_qos_class_end_np(
        __override: pthread_override_t,
    ) -> ::std::os::raw::c_int;
}
pub type mach_port_t = __darwin_mach_port_t;
extern "C" {
    pub fn pthread_atfork(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
        arg3: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        arg1: *const pthread_attr_t,
        arg2: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        arg1: *const pthread_attr_t,
        arg2: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::os::raw::c_void,
        arg3: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        arg1: *const pthread_attr_t,
        arg2: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        arg1: *mut pthread_attr_t,
        arg2: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        arg1: *mut pthread_attr_t,
        arg2: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        arg1: *mut pthread_attr_t,
        arg2: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        arg1: *mut pthread_cond_t,
        arg2: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        arg1: *const pthread_condattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        arg1: *mut pthread_condattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_create(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_equal(arg1: pthread_t, arg2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_getconcurrency() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(arg1: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_join(
        arg1: pthread_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        arg1: *mut pthread_key_t,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(arg1: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        arg1: *const pthread_mutex_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        arg1: *mut pthread_mutex_t,
        arg2: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        arg1: *mut pthread_mutex_t,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpolicy_np(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpolicy_np(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        arg1: *mut pthread_once_t,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        arg1: *mut pthread_rwlock_t,
        arg2: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        arg1: *const pthread_rwlockattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        arg1: *mut pthread_rwlockattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_setcancelstate(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setconcurrency(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        arg1: pthread_t,
        arg2: ::std::os::raw::c_int,
        arg3: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setspecific(
        arg1: pthread_key_t,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
extern "C" {
    pub fn pthread_is_threaded_np() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_threadid_np(arg1: pthread_t, arg2: *mut __uint64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getname_np(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setname_np(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_main_np() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mach_thread_np(arg1: pthread_t) -> mach_port_t;
}
extern "C" {
    pub fn pthread_get_stacksize_np(arg1: pthread_t) -> size_t;
}
extern "C" {
    pub fn pthread_get_stackaddr_np(arg1: pthread_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_cond_signal_thread_np(
        arg1: *mut pthread_cond_t,
        arg2: pthread_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait_relative_np(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_create_suspended_np(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_from_mach_thread_np(arg1: mach_port_t) -> pthread_t;
}
extern "C" {
    pub fn pthread_sigmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_yield_np();
}
extern "C" {
    pub fn pthread_jit_write_protect_np(enabled: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pthread_jit_write_protect_supported_np() -> ::std::os::raw::c_int;
}
pub type pthread_jit_write_callback_t = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn pthread_jit_write_with_callback_np(
        callback: pthread_jit_write_callback_t,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_jit_write_freeze_callbacks_np();
}
extern "C" {
    pub fn pthread_cpu_number_np(cpu_number_out: *mut size_t) -> ::std::os::raw::c_int;
}
pub type sem_t = ::std::os::raw::c_int;
extern "C" {
    pub fn sem_close(arg1: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_destroy(arg1: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_getvalue(
        arg1: *mut sem_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_init(
        arg1: *mut sem_t,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_open(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> *mut sem_t;
}
extern "C" {
    pub fn sem_post(arg1: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_trywait(arg1: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_unlink(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_wait(arg1: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_signame: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub static sys_siglist: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub fn raise(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsd_signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    pub fn kill(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigaction,
        arg3: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigemptyset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sighold(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigignore(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siginterrupt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(arg1: *const sigset_t, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpause(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigprocmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigrelse(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigset(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    pub fn sigsuspend(arg1: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(
        arg1: *const sigset_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psignal(arg1: ::std::os::raw::c_uint, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sigblock(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsetmask(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigvec(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sigvec,
        arg3: *mut sigvec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn closelog();
}
extern "C" {
    pub fn openlog(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlogmask(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_syslog$DARWIN_EXTSN"]
    pub fn syslog(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn vsyslog(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: __darwin_va_list,
    );
}
pub type tcflag_t = ::std::os::raw::c_ulong;
pub type cc_t = ::std::os::raw::c_uchar;
pub type speed_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct termios {
    pub c_iflag: tcflag_t,
    pub c_oflag: tcflag_t,
    pub c_cflag: tcflag_t,
    pub c_lflag: tcflag_t,
    pub c_cc: [cc_t; 20usize],
    pub c_ispeed: speed_t,
    pub c_ospeed: speed_t,
}
#[test]
fn bindgen_test_layout_termios() {
    assert_eq!(
        ::std::mem::size_of::<termios>(),
        72usize,
        concat!("Size of: ", stringify!(termios))
    );
    assert_eq!(
        ::std::mem::align_of::<termios>(),
        8usize,
        concat!("Alignment of ", stringify!(termios))
    );
    fn test_field_c_iflag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<termios>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c_iflag) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(termios),
                "::",
                stringify!(c_iflag)
            )
        );
    }
    test_field_c_iflag();
    fn test_field_c_oflag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<termios>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c_oflag) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(termios),
                "::",
                stringify!(c_oflag)
            )
        );
    }
    test_field_c_oflag();
    fn test_field_c_cflag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<termios>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c_cflag) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(termios),
                "::",
                stringify!(c_cflag)
            )
        );
    }
    test_field_c_cflag();
    fn test_field_c_lflag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<termios>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c_lflag) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(termios),
                "::",
                stringify!(c_lflag)
            )
        );
    }
    test_field_c_lflag();
    fn test_field_c_cc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<termios>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c_cc) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(termios),
                "::",
                stringify!(c_cc)
            )
        );
    }
    test_field_c_cc();
    fn test_field_c_ispeed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<termios>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c_ispeed) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(termios),
                "::",
                stringify!(c_ispeed)
            )
        );
    }
    test_field_c_ispeed();
    fn test_field_c_ospeed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<termios>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c_ospeed) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(termios),
                "::",
                stringify!(c_ospeed)
            )
        );
    }
    test_field_c_ospeed();
}
extern "C" {
    pub fn cfgetispeed(arg1: *const termios) -> speed_t;
}
extern "C" {
    pub fn cfgetospeed(arg1: *const termios) -> speed_t;
}
extern "C" {
    pub fn cfsetispeed(arg1: *mut termios, arg2: speed_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfsetospeed(arg1: *mut termios, arg2: speed_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetattr(arg1: ::std::os::raw::c_int, arg2: *mut termios) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcsetattr(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *const termios,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcdrain(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcflow(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcflush(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcsendbreak(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfmakeraw(arg1: *mut termios);
}
extern "C" {
    pub fn cfsetspeed(arg1: *mut termios, arg2: speed_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct winsize {
    pub ws_row: ::std::os::raw::c_ushort,
    pub ws_col: ::std::os::raw::c_ushort,
    pub ws_xpixel: ::std::os::raw::c_ushort,
    pub ws_ypixel: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_winsize() {
    assert_eq!(
        ::std::mem::size_of::<winsize>(),
        8usize,
        concat!("Size of: ", stringify!(winsize))
    );
    assert_eq!(
        ::std::mem::align_of::<winsize>(),
        2usize,
        concat!("Alignment of ", stringify!(winsize))
    );
    fn test_field_ws_row() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<winsize>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ws_row) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(winsize),
                "::",
                stringify!(ws_row)
            )
        );
    }
    test_field_ws_row();
    fn test_field_ws_col() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<winsize>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ws_col) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(winsize),
                "::",
                stringify!(ws_col)
            )
        );
    }
    test_field_ws_col();
    fn test_field_ws_xpixel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<winsize>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ws_xpixel) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(winsize),
                "::",
                stringify!(ws_xpixel)
            )
        );
    }
    test_field_ws_xpixel();
    fn test_field_ws_ypixel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<winsize>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ws_ypixel) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(winsize),
                "::",
                stringify!(ws_ypixel)
            )
        );
    }
    test_field_ws_ypixel();
}
extern "C" {
    pub fn tcgetsid(arg1: ::std::os::raw::c_int) -> pid_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct accessx_descriptor {
    pub ad_name_offset: ::std::os::raw::c_uint,
    pub ad_flags: ::std::os::raw::c_int,
    pub ad_pad: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout_accessx_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<accessx_descriptor>(),
        16usize,
        concat!("Size of: ", stringify!(accessx_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<accessx_descriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(accessx_descriptor))
    );
    fn test_field_ad_name_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<accessx_descriptor>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ad_name_offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(accessx_descriptor),
                "::",
                stringify!(ad_name_offset)
            )
        );
    }
    test_field_ad_name_offset();
    fn test_field_ad_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<accessx_descriptor>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ad_flags) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(accessx_descriptor),
                "::",
                stringify!(ad_flags)
            )
        );
    }
    test_field_ad_flags();
    fn test_field_ad_pad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<accessx_descriptor>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ad_pad) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(accessx_descriptor),
                "::",
                stringify!(ad_pad)
            )
        );
    }
    test_field_ad_pad();
}
extern "C" {
    pub fn getattrlistbulk(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getattrlistat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
        arg5: size_t,
        arg6: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setattrlistat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
        arg5: size_t,
        arg6: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: uid_t,
        arg4: gid_t,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn symlinkat(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn access(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn chdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        arg1: *const ::std::os::raw::c_char,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn close(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execve(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> pid_t;
}
extern "C" {
    pub fn fpathconf(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn getcwd(arg1: *mut ::std::os::raw::c_char, arg2: size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getegid() -> gid_t;
}
extern "C" {
    pub fn geteuid() -> uid_t;
}
extern "C" {
    pub fn getgid() -> gid_t;
}
extern "C" {
    pub fn getgroups(arg1: ::std::os::raw::c_int, arg2: *mut gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getpgrp() -> pid_t;
}
extern "C" {
    pub fn getpid() -> pid_t;
}
extern "C" {
    pub fn getppid() -> pid_t;
}
extern "C" {
    pub fn getuid() -> uid_t;
}
extern "C" {
    pub fn isatty(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(arg1: ::std::os::raw::c_int, arg2: off_t, arg3: ::std::os::raw::c_int) -> off_t;
}
extern "C" {
    pub fn pathconf(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pipe(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn rmdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgid(arg1: pid_t, arg2: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> pid_t;
}
extern "C" {
    pub fn setuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sleep(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sysconf(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn tcgetpgrp(arg1: ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn tcsetpgrp(arg1: ::std::os::raw::c_int, arg2: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __nbyte: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn confstr(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn getopt(
        arg1: ::std::os::raw::c_int,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(arg1: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn chroot(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn encrypt(arg1: *mut ::std::os::raw::c_char, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn fchdir(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn getpgid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getsid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lchown(
        arg1: *const ::std::os::raw::c_char,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockf(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbyte: size_t,
        __offset: off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __nbyte: size_t,
        __offset: off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn sbrk(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn setpgrp() -> pid_t;
}
extern "C" {
    pub fn setregid(arg1: gid_t, arg2: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(arg1: uid_t, arg2: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn truncate(arg1: *const ::std::os::raw::c_char, arg2: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ualarm(arg1: useconds_t, arg2: useconds_t) -> useconds_t;
}
extern "C" {
    pub fn usleep(arg1: useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsync(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(arg1: ::std::os::raw::c_int, arg2: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin_r(arg1: *mut ::std::os::raw::c_char, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(arg1: ::std::os::raw::c_int, arg2: uid_t, arg3: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(arg1: *mut ::std::os::raw::c_char, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn setegid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *const timespec,
        arg6: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn select(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
pub type uuid_t = __darwin_uuid_t;
extern "C" {
    pub fn accessx_np(
        arg1: *const accessx_descriptor,
        arg2: size_t,
        arg3: *mut ::std::os::raw::c_int,
        arg4: uid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_profil(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn execvP(
        __file: *const ::std::os::raw::c_char,
        __searchpath: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflagstostr(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getdomainname(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getgrouplist(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostuuid(
        arg1: *mut ::std::os::raw::c_uchar,
        arg2: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getmode(arg1: *const ::std::os::raw::c_void, arg2: mode_t) -> mode_t;
}
extern "C" {
    pub fn getpeereid(
        arg1: ::std::os::raw::c_int,
        arg2: *mut uid_t,
        arg3: *mut gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsgroups_np(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwgroups_np(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initgroups(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn issetugid() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mknod(
        arg1: *const ::std::os::raw::c_char,
        arg2: mode_t,
        arg3: dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkpath_np(path: *const ::std::os::raw::c_char, omode: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkpathat_np(
        dfd: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
        omode: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemp(
        path: *mut ::std::os::raw::c_char,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps(
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp_dprotected_np(
        path: *mut ::std::os::raw::c_char,
        dpclass: ::std::os::raw::c_int,
        dpflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtempat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstempsat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostempsat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nfssvc(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setugid_np(arg1: uid_t, arg2: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getugid_np(arg1: *mut uid_t, arg2: *mut gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn reboot(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd_af(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport_af(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok_sa(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruserok(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgroups(arg1: ::std::os::raw::c_int, arg2: *const gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn sethostname(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlogin(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setmode(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn setrgid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setruid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsgroups_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn setwgroups_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtofflags(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swapon(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn undelete(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unwhiteout(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn syscall(arg1: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetattrlist(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetattrlist(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getattrlist(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setattrlist(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exchangedata(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdirentriesattr(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: *mut ::std::os::raw::c_uint,
        arg6: *mut ::std::os::raw::c_uint,
        arg7: *mut ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fssearchblock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct searchstate {
    _unused: [u8; 0],
}
extern "C" {
    pub fn searchfs(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut fssearchblock,
        arg3: *mut ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
        arg6: *mut searchstate,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsctl(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsctl(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsync_volume_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sync_volume_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optreset: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval64 {
    pub tv_sec: __int64_t,
    pub tv_usec: __int64_t,
}
#[test]
fn bindgen_test_layout_timeval64() {
    assert_eq!(
        ::std::mem::size_of::<timeval64>(),
        16usize,
        concat!("Size of: ", stringify!(timeval64))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval64>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval64))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval64),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_usec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval64),
                "::",
                stringify!(tv_usec)
            )
        );
    }
    test_field_tv_usec();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    fn test_field_it_interval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<itimerval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(itimerval),
                "::",
                stringify!(it_interval)
            )
        );
    }
    test_field_it_interval();
    fn test_field_it_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<itimerval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(itimerval),
                "::",
                stringify!(it_value)
            )
        );
    }
    test_field_it_value();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    fn test_field_tz_minuteswest() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timezone>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tz_minuteswest) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timezone),
                "::",
                stringify!(tz_minuteswest)
            )
        );
    }
    test_field_tz_minuteswest();
    fn test_field_tz_dsttime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timezone>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tz_dsttime) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(timezone),
                "::",
                stringify!(tz_dsttime)
            )
        );
    }
    test_field_tz_dsttime();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clockinfo {
    pub hz: ::std::os::raw::c_int,
    pub tick: ::std::os::raw::c_int,
    pub tickadj: ::std::os::raw::c_int,
    pub stathz: ::std::os::raw::c_int,
    pub profhz: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_clockinfo() {
    assert_eq!(
        ::std::mem::size_of::<clockinfo>(),
        20usize,
        concat!("Size of: ", stringify!(clockinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<clockinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(clockinfo))
    );
    fn test_field_hz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<clockinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hz) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(clockinfo),
                "::",
                stringify!(hz)
            )
        );
    }
    test_field_hz();
    fn test_field_tick() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<clockinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tick) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(clockinfo),
                "::",
                stringify!(tick)
            )
        );
    }
    test_field_tick();
    fn test_field_tickadj() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<clockinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tickadj) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(clockinfo),
                "::",
                stringify!(tickadj)
            )
        );
    }
    test_field_tickadj();
    fn test_field_stathz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<clockinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stathz) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(clockinfo),
                "::",
                stringify!(stathz)
            )
        );
    }
    test_field_stathz();
    fn test_field_profhz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<clockinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).profhz) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(clockinfo),
                "::",
                stringify!(profhz)
            )
        );
    }
    test_field_profhz();
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(arg1: ::std::os::raw::c_int, arg2: *const timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getitimer(arg1: ::std::os::raw::c_int, arg2: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gettimeofday(
        arg1: *mut timeval,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        arg1: ::std::os::raw::c_int,
        arg2: *const itimerval,
        arg3: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const timeval,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_event_data {
    pub if_family: u_int32_t,
    pub if_unit: u_int32_t,
    pub if_name: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_net_event_data() {
    assert_eq!(
        ::std::mem::size_of::<net_event_data>(),
        24usize,
        concat!("Size of: ", stringify!(net_event_data))
    );
    assert_eq!(
        ::std::mem::align_of::<net_event_data>(),
        4usize,
        concat!("Alignment of ", stringify!(net_event_data))
    );
    fn test_field_if_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<net_event_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).if_family) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_event_data),
                "::",
                stringify!(if_family)
            )
        );
    }
    test_field_if_family();
    fn test_field_if_unit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<net_event_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).if_unit) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(net_event_data),
                "::",
                stringify!(if_unit)
            )
        );
    }
    test_field_if_unit();
    fn test_field_if_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<net_event_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).if_name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(net_event_data),
                "::",
                stringify!(if_name)
            )
        );
    }
    test_field_if_name();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval32 {
    pub tv_sec: __int32_t,
    pub tv_usec: __int32_t,
}
#[test]
fn bindgen_test_layout_timeval32() {
    assert_eq!(
        ::std::mem::size_of::<timeval32>(),
        8usize,
        concat!("Size of: ", stringify!(timeval32))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval32>(),
        4usize,
        concat!("Alignment of ", stringify!(timeval32))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval32),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_usec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval32),
                "::",
                stringify!(tv_usec)
            )
        );
    }
    test_field_tv_usec();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct if_data {
    pub ifi_type: u_char,
    pub ifi_typelen: u_char,
    pub ifi_physical: u_char,
    pub ifi_addrlen: u_char,
    pub ifi_hdrlen: u_char,
    pub ifi_recvquota: u_char,
    pub ifi_xmitquota: u_char,
    pub ifi_unused1: u_char,
    pub ifi_mtu: u_int32_t,
    pub ifi_metric: u_int32_t,
    pub ifi_baudrate: u_int32_t,
    pub ifi_ipackets: u_int32_t,
    pub ifi_ierrors: u_int32_t,
    pub ifi_opackets: u_int32_t,
    pub ifi_oerrors: u_int32_t,
    pub ifi_collisions: u_int32_t,
    pub ifi_ibytes: u_int32_t,
    pub ifi_obytes: u_int32_t,
    pub ifi_imcasts: u_int32_t,
    pub ifi_omcasts: u_int32_t,
    pub ifi_iqdrops: u_int32_t,
    pub ifi_noproto: u_int32_t,
    pub ifi_recvtiming: u_int32_t,
    pub ifi_xmittiming: u_int32_t,
    pub ifi_lastchange: timeval32,
    pub ifi_unused2: u_int32_t,
    pub ifi_hwassist: u_int32_t,
    pub ifi_reserved1: u_int32_t,
    pub ifi_reserved2: u_int32_t,
}
#[test]
fn bindgen_test_layout_if_data() {
    assert_eq!(
        ::std::mem::size_of::<if_data>(),
        96usize,
        concat!("Size of: ", stringify!(if_data))
    );
    assert_eq!(
        ::std::mem::align_of::<if_data>(),
        4usize,
        concat!("Alignment of ", stringify!(if_data))
    );
    fn test_field_ifi_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_type)
            )
        );
    }
    test_field_ifi_type();
    fn test_field_ifi_typelen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_typelen) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_typelen)
            )
        );
    }
    test_field_ifi_typelen();
    fn test_field_ifi_physical() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_physical) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_physical)
            )
        );
    }
    test_field_ifi_physical();
    fn test_field_ifi_addrlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_addrlen) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_addrlen)
            )
        );
    }
    test_field_ifi_addrlen();
    fn test_field_ifi_hdrlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_hdrlen) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_hdrlen)
            )
        );
    }
    test_field_ifi_hdrlen();
    fn test_field_ifi_recvquota() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_recvquota) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_recvquota)
            )
        );
    }
    test_field_ifi_recvquota();
    fn test_field_ifi_xmitquota() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_xmitquota) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_xmitquota)
            )
        );
    }
    test_field_ifi_xmitquota();
    fn test_field_ifi_unused1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_unused1) as usize - ptr as usize
            },
            7usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_unused1)
            )
        );
    }
    test_field_ifi_unused1();
    fn test_field_ifi_mtu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_mtu) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_mtu)
            )
        );
    }
    test_field_ifi_mtu();
    fn test_field_ifi_metric() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_metric) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_metric)
            )
        );
    }
    test_field_ifi_metric();
    fn test_field_ifi_baudrate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_baudrate) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_baudrate)
            )
        );
    }
    test_field_ifi_baudrate();
    fn test_field_ifi_ipackets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_ipackets) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_ipackets)
            )
        );
    }
    test_field_ifi_ipackets();
    fn test_field_ifi_ierrors() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_ierrors) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_ierrors)
            )
        );
    }
    test_field_ifi_ierrors();
    fn test_field_ifi_opackets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_opackets) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_opackets)
            )
        );
    }
    test_field_ifi_opackets();
    fn test_field_ifi_oerrors() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_oerrors) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_oerrors)
            )
        );
    }
    test_field_ifi_oerrors();
    fn test_field_ifi_collisions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_collisions) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_collisions)
            )
        );
    }
    test_field_ifi_collisions();
    fn test_field_ifi_ibytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_ibytes) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_ibytes)
            )
        );
    }
    test_field_ifi_ibytes();
    fn test_field_ifi_obytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_obytes) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_obytes)
            )
        );
    }
    test_field_ifi_obytes();
    fn test_field_ifi_imcasts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_imcasts) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_imcasts)
            )
        );
    }
    test_field_ifi_imcasts();
    fn test_field_ifi_omcasts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_omcasts) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_omcasts)
            )
        );
    }
    test_field_ifi_omcasts();
    fn test_field_ifi_iqdrops() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_iqdrops) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_iqdrops)
            )
        );
    }
    test_field_ifi_iqdrops();
    fn test_field_ifi_noproto() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_noproto) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_noproto)
            )
        );
    }
    test_field_ifi_noproto();
    fn test_field_ifi_recvtiming() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_recvtiming) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_recvtiming)
            )
        );
    }
    test_field_ifi_recvtiming();
    fn test_field_ifi_xmittiming() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_xmittiming) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_xmittiming)
            )
        );
    }
    test_field_ifi_xmittiming();
    fn test_field_ifi_lastchange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_lastchange) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_lastchange)
            )
        );
    }
    test_field_ifi_lastchange();
    fn test_field_ifi_unused2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_unused2) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_unused2)
            )
        );
    }
    test_field_ifi_unused2();
    fn test_field_ifi_hwassist() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_hwassist) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_hwassist)
            )
        );
    }
    test_field_ifi_hwassist();
    fn test_field_ifi_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_reserved1) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_reserved1)
            )
        );
    }
    test_field_ifi_reserved1();
    fn test_field_ifi_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_reserved2) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_reserved2)
            )
        );
    }
    test_field_ifi_reserved2();
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct if_data64 {
    pub ifi_type: u_char,
    pub ifi_typelen: u_char,
    pub ifi_physical: u_char,
    pub ifi_addrlen: u_char,
    pub ifi_hdrlen: u_char,
    pub ifi_recvquota: u_char,
    pub ifi_xmitquota: u_char,
    pub ifi_unused1: u_char,
    pub ifi_mtu: u_int32_t,
    pub ifi_metric: u_int32_t,
    pub ifi_baudrate: u_int64_t,
    pub ifi_ipackets: u_int64_t,
    pub ifi_ierrors: u_int64_t,
    pub ifi_opackets: u_int64_t,
    pub ifi_oerrors: u_int64_t,
    pub ifi_collisions: u_int64_t,
    pub ifi_ibytes: u_int64_t,
    pub ifi_obytes: u_int64_t,
    pub ifi_imcasts: u_int64_t,
    pub ifi_omcasts: u_int64_t,
    pub ifi_iqdrops: u_int64_t,
    pub ifi_noproto: u_int64_t,
    pub ifi_recvtiming: u_int32_t,
    pub ifi_xmittiming: u_int32_t,
    pub ifi_lastchange: timeval32,
}
#[test]
fn bindgen_test_layout_if_data64() {
    assert_eq!(
        ::std::mem::size_of::<if_data64>(),
        128usize,
        concat!("Size of: ", stringify!(if_data64))
    );
    assert_eq!(
        ::std::mem::align_of::<if_data64>(),
        4usize,
        concat!("Alignment of ", stringify!(if_data64))
    );
    fn test_field_ifi_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_type)
            )
        );
    }
    test_field_ifi_type();
    fn test_field_ifi_typelen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_typelen) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_typelen)
            )
        );
    }
    test_field_ifi_typelen();
    fn test_field_ifi_physical() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_physical) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_physical)
            )
        );
    }
    test_field_ifi_physical();
    fn test_field_ifi_addrlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_addrlen) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_addrlen)
            )
        );
    }
    test_field_ifi_addrlen();
    fn test_field_ifi_hdrlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_hdrlen) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_hdrlen)
            )
        );
    }
    test_field_ifi_hdrlen();
    fn test_field_ifi_recvquota() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_recvquota) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_recvquota)
            )
        );
    }
    test_field_ifi_recvquota();
    fn test_field_ifi_xmitquota() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_xmitquota) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_xmitquota)
            )
        );
    }
    test_field_ifi_xmitquota();
    fn test_field_ifi_unused1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_unused1) as usize - ptr as usize
            },
            7usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_unused1)
            )
        );
    }
    test_field_ifi_unused1();
    fn test_field_ifi_mtu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_mtu) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_mtu)
            )
        );
    }
    test_field_ifi_mtu();
    fn test_field_ifi_metric() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_metric) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_metric)
            )
        );
    }
    test_field_ifi_metric();
    fn test_field_ifi_baudrate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_baudrate) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_baudrate)
            )
        );
    }
    test_field_ifi_baudrate();
    fn test_field_ifi_ipackets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_ipackets) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_ipackets)
            )
        );
    }
    test_field_ifi_ipackets();
    fn test_field_ifi_ierrors() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_ierrors) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_ierrors)
            )
        );
    }
    test_field_ifi_ierrors();
    fn test_field_ifi_opackets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_opackets) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_opackets)
            )
        );
    }
    test_field_ifi_opackets();
    fn test_field_ifi_oerrors() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_oerrors) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_oerrors)
            )
        );
    }
    test_field_ifi_oerrors();
    fn test_field_ifi_collisions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_collisions) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_collisions)
            )
        );
    }
    test_field_ifi_collisions();
    fn test_field_ifi_ibytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_ibytes) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_ibytes)
            )
        );
    }
    test_field_ifi_ibytes();
    fn test_field_ifi_obytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_obytes) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_obytes)
            )
        );
    }
    test_field_ifi_obytes();
    fn test_field_ifi_imcasts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_imcasts) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_imcasts)
            )
        );
    }
    test_field_ifi_imcasts();
    fn test_field_ifi_omcasts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_omcasts) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_omcasts)
            )
        );
    }
    test_field_ifi_omcasts();
    fn test_field_ifi_iqdrops() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_iqdrops) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_iqdrops)
            )
        );
    }
    test_field_ifi_iqdrops();
    fn test_field_ifi_noproto() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_noproto) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_noproto)
            )
        );
    }
    test_field_ifi_noproto();
    fn test_field_ifi_recvtiming() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_recvtiming) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_recvtiming)
            )
        );
    }
    test_field_ifi_recvtiming();
    fn test_field_ifi_xmittiming() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_xmittiming) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_xmittiming)
            )
        );
    }
    test_field_ifi_xmittiming();
    fn test_field_ifi_lastchange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_lastchange) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_lastchange)
            )
        );
    }
    test_field_ifi_lastchange();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifnet_interface_advisory {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifqueue {
    pub ifq_head: *mut ::std::os::raw::c_void,
    pub ifq_tail: *mut ::std::os::raw::c_void,
    pub ifq_len: ::std::os::raw::c_int,
    pub ifq_maxlen: ::std::os::raw::c_int,
    pub ifq_drops: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ifqueue() {
    assert_eq!(
        ::std::mem::size_of::<ifqueue>(),
        32usize,
        concat!("Size of: ", stringify!(ifqueue))
    );
    assert_eq!(
        ::std::mem::align_of::<ifqueue>(),
        8usize,
        concat!("Alignment of ", stringify!(ifqueue))
    );
    fn test_field_ifq_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifqueue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifq_head) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifqueue),
                "::",
                stringify!(ifq_head)
            )
        );
    }
    test_field_ifq_head();
    fn test_field_ifq_tail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifqueue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifq_tail) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ifqueue),
                "::",
                stringify!(ifq_tail)
            )
        );
    }
    test_field_ifq_tail();
    fn test_field_ifq_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifqueue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifq_len) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifqueue),
                "::",
                stringify!(ifq_len)
            )
        );
    }
    test_field_ifq_len();
    fn test_field_ifq_maxlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifqueue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifq_maxlen) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(ifqueue),
                "::",
                stringify!(ifq_maxlen)
            )
        );
    }
    test_field_ifq_maxlen();
    fn test_field_ifq_drops() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifqueue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifq_drops) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ifqueue),
                "::",
                stringify!(ifq_drops)
            )
        );
    }
    test_field_ifq_drops();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct if_clonereq {
    pub ifcr_total: ::std::os::raw::c_int,
    pub ifcr_count: ::std::os::raw::c_int,
    pub ifcr_buffer: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_if_clonereq() {
    assert_eq!(
        ::std::mem::size_of::<if_clonereq>(),
        16usize,
        concat!("Size of: ", stringify!(if_clonereq))
    );
    assert_eq!(
        ::std::mem::align_of::<if_clonereq>(),
        8usize,
        concat!("Alignment of ", stringify!(if_clonereq))
    );
    fn test_field_ifcr_total() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_clonereq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifcr_total) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(if_clonereq),
                "::",
                stringify!(ifcr_total)
            )
        );
    }
    test_field_ifcr_total();
    fn test_field_ifcr_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_clonereq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifcr_count) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(if_clonereq),
                "::",
                stringify!(ifcr_count)
            )
        );
    }
    test_field_ifcr_count();
    fn test_field_ifcr_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_clonereq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifcr_buffer) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(if_clonereq),
                "::",
                stringify!(ifcr_buffer)
            )
        );
    }
    test_field_ifcr_buffer();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct if_msghdr {
    pub ifm_msglen: ::std::os::raw::c_ushort,
    pub ifm_version: ::std::os::raw::c_uchar,
    pub ifm_type: ::std::os::raw::c_uchar,
    pub ifm_addrs: ::std::os::raw::c_int,
    pub ifm_flags: ::std::os::raw::c_int,
    pub ifm_index: ::std::os::raw::c_ushort,
    pub ifm_data: if_data,
}
#[test]
fn bindgen_test_layout_if_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<if_msghdr>(),
        112usize,
        concat!("Size of: ", stringify!(if_msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<if_msghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(if_msghdr))
    );
    fn test_field_ifm_msglen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_msglen) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr),
                "::",
                stringify!(ifm_msglen)
            )
        );
    }
    test_field_ifm_msglen();
    fn test_field_ifm_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_version) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr),
                "::",
                stringify!(ifm_version)
            )
        );
    }
    test_field_ifm_version();
    fn test_field_ifm_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_type) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr),
                "::",
                stringify!(ifm_type)
            )
        );
    }
    test_field_ifm_type();
    fn test_field_ifm_addrs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_addrs) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr),
                "::",
                stringify!(ifm_addrs)
            )
        );
    }
    test_field_ifm_addrs();
    fn test_field_ifm_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr),
                "::",
                stringify!(ifm_flags)
            )
        );
    }
    test_field_ifm_flags();
    fn test_field_ifm_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_index) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr),
                "::",
                stringify!(ifm_index)
            )
        );
    }
    test_field_ifm_index();
    fn test_field_ifm_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_data) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr),
                "::",
                stringify!(ifm_data)
            )
        );
    }
    test_field_ifm_data();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifa_msghdr {
    pub ifam_msglen: ::std::os::raw::c_ushort,
    pub ifam_version: ::std::os::raw::c_uchar,
    pub ifam_type: ::std::os::raw::c_uchar,
    pub ifam_addrs: ::std::os::raw::c_int,
    pub ifam_flags: ::std::os::raw::c_int,
    pub ifam_index: ::std::os::raw::c_ushort,
    pub ifam_metric: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ifa_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<ifa_msghdr>(),
        20usize,
        concat!("Size of: ", stringify!(ifa_msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ifa_msghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(ifa_msghdr))
    );
    fn test_field_ifam_msglen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifa_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifam_msglen) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifa_msghdr),
                "::",
                stringify!(ifam_msglen)
            )
        );
    }
    test_field_ifam_msglen();
    fn test_field_ifam_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifa_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifam_version) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(ifa_msghdr),
                "::",
                stringify!(ifam_version)
            )
        );
    }
    test_field_ifam_version();
    fn test_field_ifam_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifa_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifam_type) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(ifa_msghdr),
                "::",
                stringify!(ifam_type)
            )
        );
    }
    test_field_ifam_type();
    fn test_field_ifam_addrs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifa_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifam_addrs) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ifa_msghdr),
                "::",
                stringify!(ifam_addrs)
            )
        );
    }
    test_field_ifam_addrs();
    fn test_field_ifam_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifa_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifam_flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ifa_msghdr),
                "::",
                stringify!(ifam_flags)
            )
        );
    }
    test_field_ifam_flags();
    fn test_field_ifam_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifa_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifam_index) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(ifa_msghdr),
                "::",
                stringify!(ifam_index)
            )
        );
    }
    test_field_ifam_index();
    fn test_field_ifam_metric() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifa_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifam_metric) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifa_msghdr),
                "::",
                stringify!(ifam_metric)
            )
        );
    }
    test_field_ifam_metric();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifma_msghdr {
    pub ifmam_msglen: ::std::os::raw::c_ushort,
    pub ifmam_version: ::std::os::raw::c_uchar,
    pub ifmam_type: ::std::os::raw::c_uchar,
    pub ifmam_addrs: ::std::os::raw::c_int,
    pub ifmam_flags: ::std::os::raw::c_int,
    pub ifmam_index: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_ifma_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<ifma_msghdr>(),
        16usize,
        concat!("Size of: ", stringify!(ifma_msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ifma_msghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(ifma_msghdr))
    );
    fn test_field_ifmam_msglen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_msglen) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr),
                "::",
                stringify!(ifmam_msglen)
            )
        );
    }
    test_field_ifmam_msglen();
    fn test_field_ifmam_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_version) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr),
                "::",
                stringify!(ifmam_version)
            )
        );
    }
    test_field_ifmam_version();
    fn test_field_ifmam_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_type) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr),
                "::",
                stringify!(ifmam_type)
            )
        );
    }
    test_field_ifmam_type();
    fn test_field_ifmam_addrs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_addrs) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr),
                "::",
                stringify!(ifmam_addrs)
            )
        );
    }
    test_field_ifmam_addrs();
    fn test_field_ifmam_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr),
                "::",
                stringify!(ifmam_flags)
            )
        );
    }
    test_field_ifmam_flags();
    fn test_field_ifmam_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_index) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr),
                "::",
                stringify!(ifmam_index)
            )
        );
    }
    test_field_ifmam_index();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct if_msghdr2 {
    pub ifm_msglen: u_short,
    pub ifm_version: u_char,
    pub ifm_type: u_char,
    pub ifm_addrs: ::std::os::raw::c_int,
    pub ifm_flags: ::std::os::raw::c_int,
    pub ifm_index: u_short,
    pub ifm_snd_len: ::std::os::raw::c_int,
    pub ifm_snd_maxlen: ::std::os::raw::c_int,
    pub ifm_snd_drops: ::std::os::raw::c_int,
    pub ifm_timer: ::std::os::raw::c_int,
    pub ifm_data: if_data64,
}
#[test]
fn bindgen_test_layout_if_msghdr2() {
    assert_eq!(
        ::std::mem::size_of::<if_msghdr2>(),
        160usize,
        concat!("Size of: ", stringify!(if_msghdr2))
    );
    assert_eq!(
        ::std::mem::align_of::<if_msghdr2>(),
        4usize,
        concat!("Alignment of ", stringify!(if_msghdr2))
    );
    fn test_field_ifm_msglen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_msglen) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_msglen)
            )
        );
    }
    test_field_ifm_msglen();
    fn test_field_ifm_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_version) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_version)
            )
        );
    }
    test_field_ifm_version();
    fn test_field_ifm_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_type) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_type)
            )
        );
    }
    test_field_ifm_type();
    fn test_field_ifm_addrs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_addrs) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_addrs)
            )
        );
    }
    test_field_ifm_addrs();
    fn test_field_ifm_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_flags)
            )
        );
    }
    test_field_ifm_flags();
    fn test_field_ifm_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_index) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_index)
            )
        );
    }
    test_field_ifm_index();
    fn test_field_ifm_snd_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_snd_len) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_snd_len)
            )
        );
    }
    test_field_ifm_snd_len();
    fn test_field_ifm_snd_maxlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_snd_maxlen) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_snd_maxlen)
            )
        );
    }
    test_field_ifm_snd_maxlen();
    fn test_field_ifm_snd_drops() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_snd_drops) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_snd_drops)
            )
        );
    }
    test_field_ifm_snd_drops();
    fn test_field_ifm_timer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_timer) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_timer)
            )
        );
    }
    test_field_ifm_timer();
    fn test_field_ifm_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_data) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_data)
            )
        );
    }
    test_field_ifm_data();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifma_msghdr2 {
    pub ifmam_msglen: u_short,
    pub ifmam_version: u_char,
    pub ifmam_type: u_char,
    pub ifmam_addrs: ::std::os::raw::c_int,
    pub ifmam_flags: ::std::os::raw::c_int,
    pub ifmam_index: u_short,
    pub ifmam_refcount: i32,
}
#[test]
fn bindgen_test_layout_ifma_msghdr2() {
    assert_eq!(
        ::std::mem::size_of::<ifma_msghdr2>(),
        20usize,
        concat!("Size of: ", stringify!(ifma_msghdr2))
    );
    assert_eq!(
        ::std::mem::align_of::<ifma_msghdr2>(),
        4usize,
        concat!("Alignment of ", stringify!(ifma_msghdr2))
    );
    fn test_field_ifmam_msglen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_msglen) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr2),
                "::",
                stringify!(ifmam_msglen)
            )
        );
    }
    test_field_ifmam_msglen();
    fn test_field_ifmam_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_version) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr2),
                "::",
                stringify!(ifmam_version)
            )
        );
    }
    test_field_ifmam_version();
    fn test_field_ifmam_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_type) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr2),
                "::",
                stringify!(ifmam_type)
            )
        );
    }
    test_field_ifmam_type();
    fn test_field_ifmam_addrs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_addrs) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr2),
                "::",
                stringify!(ifmam_addrs)
            )
        );
    }
    test_field_ifmam_addrs();
    fn test_field_ifmam_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr2),
                "::",
                stringify!(ifmam_flags)
            )
        );
    }
    test_field_ifmam_flags();
    fn test_field_ifmam_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_index) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr2),
                "::",
                stringify!(ifmam_index)
            )
        );
    }
    test_field_ifmam_index();
    fn test_field_ifmam_refcount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_refcount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr2),
                "::",
                stringify!(ifmam_refcount)
            )
        );
    }
    test_field_ifmam_refcount();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifdevmtu {
    pub ifdm_current: ::std::os::raw::c_int,
    pub ifdm_min: ::std::os::raw::c_int,
    pub ifdm_max: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ifdevmtu() {
    assert_eq!(
        ::std::mem::size_of::<ifdevmtu>(),
        12usize,
        concat!("Size of: ", stringify!(ifdevmtu))
    );
    assert_eq!(
        ::std::mem::align_of::<ifdevmtu>(),
        4usize,
        concat!("Alignment of ", stringify!(ifdevmtu))
    );
    fn test_field_ifdm_current() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifdevmtu>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifdm_current) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifdevmtu),
                "::",
                stringify!(ifdm_current)
            )
        );
    }
    test_field_ifdm_current();
    fn test_field_ifdm_min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifdevmtu>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifdm_min) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ifdevmtu),
                "::",
                stringify!(ifdm_min)
            )
        );
    }
    test_field_ifdm_min();
    fn test_field_ifdm_max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifdevmtu>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifdm_max) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ifdevmtu),
                "::",
                stringify!(ifdm_max)
            )
        );
    }
    test_field_ifdm_max();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifkpi {
    pub ifk_module_id: ::std::os::raw::c_uint,
    pub ifk_type: ::std::os::raw::c_uint,
    pub ifk_data: ifkpi__bindgen_ty_1,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub union ifkpi__bindgen_ty_1 {
    pub ifk_ptr: *mut ::std::os::raw::c_void,
    pub ifk_value: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ifkpi__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ifkpi__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ifkpi__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ifkpi__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ifkpi__bindgen_ty_1))
    );
    fn test_field_ifk_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifkpi__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifk_ptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifkpi__bindgen_ty_1),
                "::",
                stringify!(ifk_ptr)
            )
        );
    }
    test_field_ifk_ptr();
    fn test_field_ifk_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifkpi__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifk_value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifkpi__bindgen_ty_1),
                "::",
                stringify!(ifk_value)
            )
        );
    }
    test_field_ifk_value();
}
#[test]
fn bindgen_test_layout_ifkpi() {
    assert_eq!(
        ::std::mem::size_of::<ifkpi>(),
        16usize,
        concat!("Size of: ", stringify!(ifkpi))
    );
    assert_eq!(
        ::std::mem::align_of::<ifkpi>(),
        4usize,
        concat!("Alignment of ", stringify!(ifkpi))
    );
    fn test_field_ifk_module_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifkpi>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifk_module_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifkpi),
                "::",
                stringify!(ifk_module_id)
            )
        );
    }
    test_field_ifk_module_id();
    fn test_field_ifk_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifkpi>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifk_type) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ifkpi),
                "::",
                stringify!(ifk_type)
            )
        );
    }
    test_field_ifk_type();
    fn test_field_ifk_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifkpi>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifk_data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ifkpi),
                "::",
                stringify!(ifk_data)
            )
        );
    }
    test_field_ifk_data();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifreq {
    pub ifr_name: [::std::os::raw::c_char; 16usize],
    pub ifr_ifru: ifreq__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifreq__bindgen_ty_1 {
    pub ifru_addr: sockaddr,
    pub ifru_dstaddr: sockaddr,
    pub ifru_broadaddr: sockaddr,
    pub ifru_flags: ::std::os::raw::c_short,
    pub ifru_metric: ::std::os::raw::c_int,
    pub ifru_mtu: ::std::os::raw::c_int,
    pub ifru_phys: ::std::os::raw::c_int,
    pub ifru_media: ::std::os::raw::c_int,
    pub ifru_intval: ::std::os::raw::c_int,
    pub ifru_data: caddr_t,
    pub ifru_devmtu: ifdevmtu,
    pub ifru_kpi: ifkpi,
    pub ifru_wake_flags: u_int32_t,
    pub ifru_route_refcnt: u_int32_t,
    pub ifru_cap: [::std::os::raw::c_int; 2usize],
    pub ifru_functional_type: u_int32_t,
}
#[test]
fn bindgen_test_layout_ifreq__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ifreq__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(ifreq__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ifreq__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ifreq__bindgen_ty_1))
    );
    fn test_field_ifru_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_addr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_addr)
            )
        );
    }
    test_field_ifru_addr();
    fn test_field_ifru_dstaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_dstaddr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_dstaddr)
            )
        );
    }
    test_field_ifru_dstaddr();
    fn test_field_ifru_broadaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_broadaddr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_broadaddr)
            )
        );
    }
    test_field_ifru_broadaddr();
    fn test_field_ifru_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_flags)
            )
        );
    }
    test_field_ifru_flags();
    fn test_field_ifru_metric() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_metric) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_metric)
            )
        );
    }
    test_field_ifru_metric();
    fn test_field_ifru_mtu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_mtu) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_mtu)
            )
        );
    }
    test_field_ifru_mtu();
    fn test_field_ifru_phys() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_phys) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_phys)
            )
        );
    }
    test_field_ifru_phys();
    fn test_field_ifru_media() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_media) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_media)
            )
        );
    }
    test_field_ifru_media();
    fn test_field_ifru_intval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_intval) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_intval)
            )
        );
    }
    test_field_ifru_intval();
    fn test_field_ifru_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_data)
            )
        );
    }
    test_field_ifru_data();
    fn test_field_ifru_devmtu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_devmtu) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_devmtu)
            )
        );
    }
    test_field_ifru_devmtu();
    fn test_field_ifru_kpi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_kpi) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_kpi)
            )
        );
    }
    test_field_ifru_kpi();
    fn test_field_ifru_wake_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_wake_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_wake_flags)
            )
        );
    }
    test_field_ifru_wake_flags();
    fn test_field_ifru_route_refcnt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_route_refcnt) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_route_refcnt)
            )
        );
    }
    test_field_ifru_route_refcnt();
    fn test_field_ifru_cap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_cap) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_cap)
            )
        );
    }
    test_field_ifru_cap();
    fn test_field_ifru_functional_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_functional_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_functional_type)
            )
        );
    }
    test_field_ifru_functional_type();
}
#[test]
fn bindgen_test_layout_ifreq() {
    assert_eq!(
        ::std::mem::size_of::<ifreq>(),
        32usize,
        concat!("Size of: ", stringify!(ifreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ifreq>(),
        8usize,
        concat!("Alignment of ", stringify!(ifreq))
    );
    fn test_field_ifr_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifr_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq),
                "::",
                stringify!(ifr_name)
            )
        );
    }
    test_field_ifr_name();
    fn test_field_ifr_ifru() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifr_ifru) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq),
                "::",
                stringify!(ifr_ifru)
            )
        );
    }
    test_field_ifr_ifru();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifaliasreq {
    pub ifra_name: [::std::os::raw::c_char; 16usize],
    pub ifra_addr: sockaddr,
    pub ifra_broadaddr: sockaddr,
    pub ifra_mask: sockaddr,
}
#[test]
fn bindgen_test_layout_ifaliasreq() {
    assert_eq!(
        ::std::mem::size_of::<ifaliasreq>(),
        64usize,
        concat!("Size of: ", stringify!(ifaliasreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ifaliasreq>(),
        1usize,
        concat!("Alignment of ", stringify!(ifaliasreq))
    );
    fn test_field_ifra_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaliasreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifra_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaliasreq),
                "::",
                stringify!(ifra_name)
            )
        );
    }
    test_field_ifra_name();
    fn test_field_ifra_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaliasreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifra_addr) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaliasreq),
                "::",
                stringify!(ifra_addr)
            )
        );
    }
    test_field_ifra_addr();
    fn test_field_ifra_broadaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaliasreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifra_broadaddr) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaliasreq),
                "::",
                stringify!(ifra_broadaddr)
            )
        );
    }
    test_field_ifra_broadaddr();
    fn test_field_ifra_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaliasreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifra_mask) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaliasreq),
                "::",
                stringify!(ifra_mask)
            )
        );
    }
    test_field_ifra_mask();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rslvmulti_req {
    pub sa: *mut sockaddr,
    pub llsa: *mut *mut sockaddr,
}
#[test]
fn bindgen_test_layout_rslvmulti_req() {
    assert_eq!(
        ::std::mem::size_of::<rslvmulti_req>(),
        16usize,
        concat!("Size of: ", stringify!(rslvmulti_req))
    );
    assert_eq!(
        ::std::mem::align_of::<rslvmulti_req>(),
        8usize,
        concat!("Alignment of ", stringify!(rslvmulti_req))
    );
    fn test_field_sa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rslvmulti_req>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rslvmulti_req),
                "::",
                stringify!(sa)
            )
        );
    }
    test_field_sa();
    fn test_field_llsa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rslvmulti_req>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).llsa) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rslvmulti_req),
                "::",
                stringify!(llsa)
            )
        );
    }
    test_field_llsa();
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct ifmediareq {
    pub ifm_name: [::std::os::raw::c_char; 16usize],
    pub ifm_current: ::std::os::raw::c_int,
    pub ifm_mask: ::std::os::raw::c_int,
    pub ifm_status: ::std::os::raw::c_int,
    pub ifm_active: ::std::os::raw::c_int,
    pub ifm_count: ::std::os::raw::c_int,
    pub ifm_ulist: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ifmediareq() {
    assert_eq!(
        ::std::mem::size_of::<ifmediareq>(),
        44usize,
        concat!("Size of: ", stringify!(ifmediareq))
    );
    assert_eq!(
        ::std::mem::align_of::<ifmediareq>(),
        4usize,
        concat!("Alignment of ", stringify!(ifmediareq))
    );
    fn test_field_ifm_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmediareq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmediareq),
                "::",
                stringify!(ifm_name)
            )
        );
    }
    test_field_ifm_name();
    fn test_field_ifm_current() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmediareq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_current) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmediareq),
                "::",
                stringify!(ifm_current)
            )
        );
    }
    test_field_ifm_current();
    fn test_field_ifm_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmediareq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_mask) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmediareq),
                "::",
                stringify!(ifm_mask)
            )
        );
    }
    test_field_ifm_mask();
    fn test_field_ifm_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmediareq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_status) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmediareq),
                "::",
                stringify!(ifm_status)
            )
        );
    }
    test_field_ifm_status();
    fn test_field_ifm_active() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmediareq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_active) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmediareq),
                "::",
                stringify!(ifm_active)
            )
        );
    }
    test_field_ifm_active();
    fn test_field_ifm_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmediareq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_count) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmediareq),
                "::",
                stringify!(ifm_count)
            )
        );
    }
    test_field_ifm_count();
    fn test_field_ifm_ulist() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmediareq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_ulist) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmediareq),
                "::",
                stringify!(ifm_ulist)
            )
        );
    }
    test_field_ifm_ulist();
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct ifdrv {
    pub ifd_name: [::std::os::raw::c_char; 16usize],
    pub ifd_cmd: ::std::os::raw::c_ulong,
    pub ifd_len: size_t,
    pub ifd_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ifdrv() {
    assert_eq!(
        ::std::mem::size_of::<ifdrv>(),
        40usize,
        concat!("Size of: ", stringify!(ifdrv))
    );
    assert_eq!(
        ::std::mem::align_of::<ifdrv>(),
        4usize,
        concat!("Alignment of ", stringify!(ifdrv))
    );
    fn test_field_ifd_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifdrv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifd_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifdrv),
                "::",
                stringify!(ifd_name)
            )
        );
    }
    test_field_ifd_name();
    fn test_field_ifd_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifdrv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifd_cmd) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifdrv),
                "::",
                stringify!(ifd_cmd)
            )
        );
    }
    test_field_ifd_cmd();
    fn test_field_ifd_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifdrv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifd_len) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ifdrv),
                "::",
                stringify!(ifd_len)
            )
        );
    }
    test_field_ifd_len();
    fn test_field_ifd_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifdrv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifd_data) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ifdrv),
                "::",
                stringify!(ifd_data)
            )
        );
    }
    test_field_ifd_data();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifstat {
    pub ifs_name: [::std::os::raw::c_char; 16usize],
    pub ascii: [::std::os::raw::c_char; 801usize],
}
#[test]
fn bindgen_test_layout_ifstat() {
    assert_eq!(
        ::std::mem::size_of::<ifstat>(),
        817usize,
        concat!("Size of: ", stringify!(ifstat))
    );
    assert_eq!(
        ::std::mem::align_of::<ifstat>(),
        1usize,
        concat!("Alignment of ", stringify!(ifstat))
    );
    fn test_field_ifs_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifstat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifs_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifstat),
                "::",
                stringify!(ifs_name)
            )
        );
    }
    test_field_ifs_name();
    fn test_field_ascii() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifstat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ascii) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifstat),
                "::",
                stringify!(ascii)
            )
        );
    }
    test_field_ascii();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifconf {
    pub ifc_len: ::std::os::raw::c_int,
    pub ifc_ifcu: ifconf__bindgen_ty_1,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub union ifconf__bindgen_ty_1 {
    pub ifcu_buf: caddr_t,
    pub ifcu_req: *mut ifreq,
}
#[test]
fn bindgen_test_layout_ifconf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ifconf__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ifconf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ifconf__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ifconf__bindgen_ty_1))
    );
    fn test_field_ifcu_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifconf__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifcu_buf) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifconf__bindgen_ty_1),
                "::",
                stringify!(ifcu_buf)
            )
        );
    }
    test_field_ifcu_buf();
    fn test_field_ifcu_req() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifconf__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifcu_req) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifconf__bindgen_ty_1),
                "::",
                stringify!(ifcu_req)
            )
        );
    }
    test_field_ifcu_req();
}
#[test]
fn bindgen_test_layout_ifconf() {
    assert_eq!(
        ::std::mem::size_of::<ifconf>(),
        12usize,
        concat!("Size of: ", stringify!(ifconf))
    );
    assert_eq!(
        ::std::mem::align_of::<ifconf>(),
        4usize,
        concat!("Alignment of ", stringify!(ifconf))
    );
    fn test_field_ifc_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifconf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifc_len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifconf),
                "::",
                stringify!(ifc_len)
            )
        );
    }
    test_field_ifc_len();
    fn test_field_ifc_ifcu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifconf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifc_ifcu) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ifconf),
                "::",
                stringify!(ifc_ifcu)
            )
        );
    }
    test_field_ifc_ifcu();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kev_dl_proto_data {
    pub link_data: net_event_data,
    pub proto_family: u_int32_t,
    pub proto_remaining_count: u_int32_t,
}
#[test]
fn bindgen_test_layout_kev_dl_proto_data() {
    assert_eq!(
        ::std::mem::size_of::<kev_dl_proto_data>(),
        32usize,
        concat!("Size of: ", stringify!(kev_dl_proto_data))
    );
    assert_eq!(
        ::std::mem::align_of::<kev_dl_proto_data>(),
        4usize,
        concat!("Alignment of ", stringify!(kev_dl_proto_data))
    );
    fn test_field_link_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kev_dl_proto_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).link_data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kev_dl_proto_data),
                "::",
                stringify!(link_data)
            )
        );
    }
    test_field_link_data();
    fn test_field_proto_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kev_dl_proto_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).proto_family) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(kev_dl_proto_data),
                "::",
                stringify!(proto_family)
            )
        );
    }
    test_field_proto_family();
    fn test_field_proto_remaining_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kev_dl_proto_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).proto_remaining_count) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(kev_dl_proto_data),
                "::",
                stringify!(proto_remaining_count)
            )
        );
    }
    test_field_proto_remaining_count();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct if_nameindex {
    pub if_index: ::std::os::raw::c_uint,
    pub if_name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_if_nameindex() {
    assert_eq!(
        ::std::mem::size_of::<if_nameindex>(),
        16usize,
        concat!("Size of: ", stringify!(if_nameindex))
    );
    assert_eq!(
        ::std::mem::align_of::<if_nameindex>(),
        8usize,
        concat!("Alignment of ", stringify!(if_nameindex))
    );
    fn test_field_if_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_nameindex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).if_index) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(if_nameindex),
                "::",
                stringify!(if_index)
            )
        );
    }
    test_field_if_index();
    fn test_field_if_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_nameindex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).if_name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(if_nameindex),
                "::",
                stringify!(if_name)
            )
        );
    }
    test_field_if_name();
}
extern "C" {
    pub fn if_nametoindex(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn if_indextoname(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn if_nameindex() -> *mut if_nameindex;
}
extern "C" {
    pub fn if_freenameindex(arg1: *mut if_nameindex);
}
pub type tcp_seq = __uint32_t;
pub type tcp_cc = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcphdr {
    pub th_sport: ::std::os::raw::c_ushort,
    pub th_dport: ::std::os::raw::c_ushort,
    pub th_seq: tcp_seq,
    pub th_ack: tcp_seq,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub th_flags: ::std::os::raw::c_uchar,
    pub th_win: ::std::os::raw::c_ushort,
    pub th_sum: ::std::os::raw::c_ushort,
    pub th_urp: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_tcphdr() {
    assert_eq!(
        ::std::mem::size_of::<tcphdr>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr))
    );
    assert_eq!(
        ::std::mem::align_of::<tcphdr>(),
        4usize,
        concat!("Alignment of ", stringify!(tcphdr))
    );
    fn test_field_th_sport() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcphdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).th_sport) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(th_sport)
            )
        );
    }
    test_field_th_sport();
    fn test_field_th_dport() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcphdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).th_dport) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(th_dport)
            )
        );
    }
    test_field_th_dport();
    fn test_field_th_seq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcphdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).th_seq) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(th_seq)
            )
        );
    }
    test_field_th_seq();
    fn test_field_th_ack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcphdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).th_ack) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(th_ack)
            )
        );
    }
    test_field_th_ack();
    fn test_field_th_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcphdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).th_flags) as usize - ptr as usize
            },
            13usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(th_flags)
            )
        );
    }
    test_field_th_flags();
    fn test_field_th_win() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcphdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).th_win) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(th_win)
            )
        );
    }
    test_field_th_win();
    fn test_field_th_sum() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcphdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).th_sum) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(th_sum)
            )
        );
    }
    test_field_th_sum();
    fn test_field_th_urp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcphdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).th_urp) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(th_urp)
            )
        );
    }
    test_field_th_urp();
}
impl tcphdr {
    #[inline]
    pub fn th_x2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_th_x2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn th_off(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_th_off(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        th_x2: ::std::os::raw::c_uint,
        th_off: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let th_x2: u32 = unsafe { ::std::mem::transmute(th_x2) };
            th_x2 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let th_off: u32 = unsafe { ::std::mem::transmute(th_off) };
            th_off as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_connection_info {
    pub tcpi_state: u_int8_t,
    pub tcpi_snd_wscale: u_int8_t,
    pub tcpi_rcv_wscale: u_int8_t,
    pub __pad1: u_int8_t,
    pub tcpi_options: u_int32_t,
    pub tcpi_flags: u_int32_t,
    pub tcpi_rto: u_int32_t,
    pub tcpi_maxseg: u_int32_t,
    pub tcpi_snd_ssthresh: u_int32_t,
    pub tcpi_snd_cwnd: u_int32_t,
    pub tcpi_snd_wnd: u_int32_t,
    pub tcpi_snd_sbbytes: u_int32_t,
    pub tcpi_rcv_wnd: u_int32_t,
    pub tcpi_rttcur: u_int32_t,
    pub tcpi_srtt: u_int32_t,
    pub tcpi_rttvar: u_int32_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub tcpi_txpackets: u_int64_t,
    pub tcpi_txbytes: u_int64_t,
    pub tcpi_txretransmitbytes: u_int64_t,
    pub tcpi_rxpackets: u_int64_t,
    pub tcpi_rxbytes: u_int64_t,
    pub tcpi_rxoutoforderbytes: u_int64_t,
    pub tcpi_txretransmitpackets: u_int64_t,
}
#[test]
fn bindgen_test_layout_tcp_connection_info() {
    assert_eq!(
        ::std::mem::size_of::<tcp_connection_info>(),
        112usize,
        concat!("Size of: ", stringify!(tcp_connection_info))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_connection_info>(),
        8usize,
        concat!("Alignment of ", stringify!(tcp_connection_info))
    );
    fn test_field_tcpi_state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_state) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_state)
            )
        );
    }
    test_field_tcpi_state();
    fn test_field_tcpi_snd_wscale() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_snd_wscale) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_snd_wscale)
            )
        );
    }
    test_field_tcpi_snd_wscale();
    fn test_field_tcpi_rcv_wscale() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_rcv_wscale) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_rcv_wscale)
            )
        );
    }
    test_field_tcpi_rcv_wscale();
    fn test_field___pad1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(__pad1)
            )
        );
    }
    test_field___pad1();
    fn test_field_tcpi_options() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_options) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_options)
            )
        );
    }
    test_field_tcpi_options();
    fn test_field_tcpi_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_flags)
            )
        );
    }
    test_field_tcpi_flags();
    fn test_field_tcpi_rto() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_rto) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_rto)
            )
        );
    }
    test_field_tcpi_rto();
    fn test_field_tcpi_maxseg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_maxseg) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_maxseg)
            )
        );
    }
    test_field_tcpi_maxseg();
    fn test_field_tcpi_snd_ssthresh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_snd_ssthresh) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_snd_ssthresh)
            )
        );
    }
    test_field_tcpi_snd_ssthresh();
    fn test_field_tcpi_snd_cwnd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_snd_cwnd) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_snd_cwnd)
            )
        );
    }
    test_field_tcpi_snd_cwnd();
    fn test_field_tcpi_snd_wnd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_snd_wnd) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_snd_wnd)
            )
        );
    }
    test_field_tcpi_snd_wnd();
    fn test_field_tcpi_snd_sbbytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_snd_sbbytes) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_snd_sbbytes)
            )
        );
    }
    test_field_tcpi_snd_sbbytes();
    fn test_field_tcpi_rcv_wnd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_rcv_wnd) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_rcv_wnd)
            )
        );
    }
    test_field_tcpi_rcv_wnd();
    fn test_field_tcpi_rttcur() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_rttcur) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_rttcur)
            )
        );
    }
    test_field_tcpi_rttcur();
    fn test_field_tcpi_srtt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_srtt) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_srtt)
            )
        );
    }
    test_field_tcpi_srtt();
    fn test_field_tcpi_rttvar() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_rttvar) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_rttvar)
            )
        );
    }
    test_field_tcpi_rttvar();
    fn test_field_tcpi_txpackets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_txpackets) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_txpackets)
            )
        );
    }
    test_field_tcpi_txpackets();
    fn test_field_tcpi_txbytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_txbytes) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_txbytes)
            )
        );
    }
    test_field_tcpi_txbytes();
    fn test_field_tcpi_txretransmitbytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_txretransmitbytes) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_txretransmitbytes)
            )
        );
    }
    test_field_tcpi_txretransmitbytes();
    fn test_field_tcpi_rxpackets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_rxpackets) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_rxpackets)
            )
        );
    }
    test_field_tcpi_rxpackets();
    fn test_field_tcpi_rxbytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_rxbytes) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_rxbytes)
            )
        );
    }
    test_field_tcpi_rxbytes();
    fn test_field_tcpi_rxoutoforderbytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_rxoutoforderbytes) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_rxoutoforderbytes)
            )
        );
    }
    test_field_tcpi_rxoutoforderbytes();
    fn test_field_tcpi_txretransmitpackets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_txretransmitpackets) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_txretransmitpackets)
            )
        );
    }
    test_field_tcpi_txretransmitpackets();
}
impl tcp_connection_info {
    #[inline]
    pub fn tcpi_tfo_cookie_req(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_cookie_req(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_cookie_rcv(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_cookie_rcv(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_syn_loss(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_syn_loss(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_syn_data_sent(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_syn_data_sent(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_syn_data_acked(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_syn_data_acked(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_syn_data_rcv(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_syn_data_rcv(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_cookie_req_rcv(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_cookie_req_rcv(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_cookie_sent(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_cookie_sent(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_cookie_invalid(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_cookie_invalid(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_cookie_wrong(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_cookie_wrong(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_no_cookie_rcv(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_no_cookie_rcv(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_heuristics_disable(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_heuristics_disable(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_send_blackhole(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_send_blackhole(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_recv_blackhole(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_recv_blackhole(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_onebyte_proxy(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_onebyte_proxy(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __pad2(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set___pad2(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tcpi_tfo_cookie_req: u_int32_t,
        tcpi_tfo_cookie_rcv: u_int32_t,
        tcpi_tfo_syn_loss: u_int32_t,
        tcpi_tfo_syn_data_sent: u_int32_t,
        tcpi_tfo_syn_data_acked: u_int32_t,
        tcpi_tfo_syn_data_rcv: u_int32_t,
        tcpi_tfo_cookie_req_rcv: u_int32_t,
        tcpi_tfo_cookie_sent: u_int32_t,
        tcpi_tfo_cookie_invalid: u_int32_t,
        tcpi_tfo_cookie_wrong: u_int32_t,
        tcpi_tfo_no_cookie_rcv: u_int32_t,
        tcpi_tfo_heuristics_disable: u_int32_t,
        tcpi_tfo_send_blackhole: u_int32_t,
        tcpi_tfo_recv_blackhole: u_int32_t,
        tcpi_tfo_onebyte_proxy: u_int32_t,
        __pad2: u_int32_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tcpi_tfo_cookie_req: u32 = unsafe { ::std::mem::transmute(tcpi_tfo_cookie_req) };
            tcpi_tfo_cookie_req as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tcpi_tfo_cookie_rcv: u32 = unsafe { ::std::mem::transmute(tcpi_tfo_cookie_rcv) };
            tcpi_tfo_cookie_rcv as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tcpi_tfo_syn_loss: u32 = unsafe { ::std::mem::transmute(tcpi_tfo_syn_loss) };
            tcpi_tfo_syn_loss as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tcpi_tfo_syn_data_sent: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_syn_data_sent) };
            tcpi_tfo_syn_data_sent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tcpi_tfo_syn_data_acked: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_syn_data_acked) };
            tcpi_tfo_syn_data_acked as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tcpi_tfo_syn_data_rcv: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_syn_data_rcv) };
            tcpi_tfo_syn_data_rcv as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tcpi_tfo_cookie_req_rcv: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_cookie_req_rcv) };
            tcpi_tfo_cookie_req_rcv as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tcpi_tfo_cookie_sent: u32 = unsafe { ::std::mem::transmute(tcpi_tfo_cookie_sent) };
            tcpi_tfo_cookie_sent as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let tcpi_tfo_cookie_invalid: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_cookie_invalid) };
            tcpi_tfo_cookie_invalid as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let tcpi_tfo_cookie_wrong: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_cookie_wrong) };
            tcpi_tfo_cookie_wrong as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let tcpi_tfo_no_cookie_rcv: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_no_cookie_rcv) };
            tcpi_tfo_no_cookie_rcv as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let tcpi_tfo_heuristics_disable: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_heuristics_disable) };
            tcpi_tfo_heuristics_disable as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let tcpi_tfo_send_blackhole: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_send_blackhole) };
            tcpi_tfo_send_blackhole as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tcpi_tfo_recv_blackhole: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_recv_blackhole) };
            tcpi_tfo_recv_blackhole as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tcpi_tfo_onebyte_proxy: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_onebyte_proxy) };
            tcpi_tfo_onebyte_proxy as u64
        });
        __bindgen_bitfield_unit.set(15usize, 17u8, {
            let __pad2: u32 = unsafe { ::std::mem::transmute(__pad2) };
            __pad2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ttysize {
    pub ts_lines: ::std::os::raw::c_ushort,
    pub ts_cols: ::std::os::raw::c_ushort,
    pub ts_xxx: ::std::os::raw::c_ushort,
    pub ts_yyy: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_ttysize() {
    assert_eq!(
        ::std::mem::size_of::<ttysize>(),
        8usize,
        concat!("Size of: ", stringify!(ttysize))
    );
    assert_eq!(
        ::std::mem::align_of::<ttysize>(),
        2usize,
        concat!("Alignment of ", stringify!(ttysize))
    );
    fn test_field_ts_lines() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ttysize>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ts_lines) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ttysize),
                "::",
                stringify!(ts_lines)
            )
        );
    }
    test_field_ts_lines();
    fn test_field_ts_cols() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ttysize>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ts_cols) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(ttysize),
                "::",
                stringify!(ts_cols)
            )
        );
    }
    test_field_ts_cols();
    fn test_field_ts_xxx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ttysize>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ts_xxx) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ttysize),
                "::",
                stringify!(ts_xxx)
            )
        );
    }
    test_field_ts_xxx();
    fn test_field_ts_yyy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ttysize>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ts_yyy) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(ttysize),
                "::",
                stringify!(ts_yyy)
            )
        );
    }
    test_field_ts_yyy();
}
extern "C" {
    pub fn ioctl(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_ulong,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mlockall(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn munlockall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mlock(arg1: *const ::std::os::raw::c_void, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mmap(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: off_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mprotect(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msync(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn munlock(arg1: *const ::std::os::raw::c_void, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn munmap(arg1: *mut ::std::os::raw::c_void, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shm_open(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shm_unlink(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_madvise(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn madvise(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mincore(
        arg1: *const ::std::os::raw::c_void,
        arg2: size_t,
        arg3: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn minherit(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ostat {
    pub st_dev: __uint16_t,
    pub st_ino: ino_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_uid: __uint16_t,
    pub st_gid: __uint16_t,
    pub st_rdev: __uint16_t,
    pub st_size: __int32_t,
    pub st_atimespec: timespec,
    pub st_mtimespec: timespec,
    pub st_ctimespec: timespec,
    pub st_blksize: __int32_t,
    pub st_blocks: __int32_t,
    pub st_flags: __uint32_t,
    pub st_gen: __uint32_t,
}
#[test]
fn bindgen_test_layout_ostat() {
    assert_eq!(
        ::std::mem::size_of::<ostat>(),
        96usize,
        concat!("Size of: ", stringify!(ostat))
    );
    assert_eq!(
        ::std::mem::align_of::<ostat>(),
        8usize,
        concat!("Alignment of ", stringify!(ostat))
    );
    fn test_field_st_dev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_dev)
            )
        );
    }
    test_field_st_dev();
    fn test_field_st_ino() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_ino)
            )
        );
    }
    test_field_st_ino();
    fn test_field_st_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_mode)
            )
        );
    }
    test_field_st_mode();
    fn test_field_st_nlink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_nlink)
            )
        );
    }
    test_field_st_nlink();
    fn test_field_st_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_uid)
            )
        );
    }
    test_field_st_uid();
    fn test_field_st_gid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_gid)
            )
        );
    }
    test_field_st_gid();
    fn test_field_st_rdev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_rdev)
            )
        );
    }
    test_field_st_rdev();
    fn test_field_st_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_size)
            )
        );
    }
    test_field_st_size();
    fn test_field_st_atimespec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_atimespec) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_atimespec)
            )
        );
    }
    test_field_st_atimespec();
    fn test_field_st_mtimespec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_mtimespec) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_mtimespec)
            )
        );
    }
    test_field_st_mtimespec();
    fn test_field_st_ctimespec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_ctimespec) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_ctimespec)
            )
        );
    }
    test_field_st_ctimespec();
    fn test_field_st_blksize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_blksize) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_blksize)
            )
        );
    }
    test_field_st_blksize();
    fn test_field_st_blocks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_blocks) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_blocks)
            )
        );
    }
    test_field_st_blocks();
    fn test_field_st_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_flags) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_flags)
            )
        );
    }
    test_field_st_flags();
    fn test_field_st_gen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_gen) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_gen)
            )
        );
    }
    test_field_st_gen();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: dev_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_ino: __darwin_ino64_t,
    pub st_uid: uid_t,
    pub st_gid: gid_t,
    pub st_rdev: dev_t,
    pub st_atimespec: timespec,
    pub st_mtimespec: timespec,
    pub st_ctimespec: timespec,
    pub st_birthtimespec: timespec,
    pub st_size: off_t,
    pub st_blocks: blkcnt_t,
    pub st_blksize: blksize_t,
    pub st_flags: __uint32_t,
    pub st_gen: __uint32_t,
    pub st_lspare: __int32_t,
    pub st_qspare: [__int64_t; 2usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    fn test_field_st_dev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_dev)
            )
        );
    }
    test_field_st_dev();
    fn test_field_st_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_mode)
            )
        );
    }
    test_field_st_mode();
    fn test_field_st_nlink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_nlink)
            )
        );
    }
    test_field_st_nlink();
    fn test_field_st_ino() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_ino)
            )
        );
    }
    test_field_st_ino();
    fn test_field_st_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_uid)
            )
        );
    }
    test_field_st_uid();
    fn test_field_st_gid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_gid)
            )
        );
    }
    test_field_st_gid();
    fn test_field_st_rdev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_rdev)
            )
        );
    }
    test_field_st_rdev();
    fn test_field_st_atimespec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_atimespec) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_atimespec)
            )
        );
    }
    test_field_st_atimespec();
    fn test_field_st_mtimespec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_mtimespec) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_mtimespec)
            )
        );
    }
    test_field_st_mtimespec();
    fn test_field_st_ctimespec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_ctimespec) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_ctimespec)
            )
        );
    }
    test_field_st_ctimespec();
    fn test_field_st_birthtimespec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_birthtimespec) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_birthtimespec)
            )
        );
    }
    test_field_st_birthtimespec();
    fn test_field_st_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_size)
            )
        );
    }
    test_field_st_size();
    fn test_field_st_blocks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_blocks) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_blocks)
            )
        );
    }
    test_field_st_blocks();
    fn test_field_st_blksize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_blksize) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_blksize)
            )
        );
    }
    test_field_st_blksize();
    fn test_field_st_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_flags) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_flags)
            )
        );
    }
    test_field_st_flags();
    fn test_field_st_gen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_gen) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_gen)
            )
        );
    }
    test_field_st_gen();
    fn test_field_st_lspare() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_lspare) as usize - ptr as usize
            },
            124usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_lspare)
            )
        );
    }
    test_field_st_lspare();
    fn test_field_st_qspare() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_qspare) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_qspare)
            )
        );
    }
    test_field_st_qspare();
}
extern "C" {
    pub fn chmod(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmod(arg1: ::std::os::raw::c_int, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstat(arg1: ::std::os::raw::c_int, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstat(arg1: *const ::std::os::raw::c_char, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdir(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifo(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stat(arg1: *const ::std::os::raw::c_char, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn umask(arg1: mode_t) -> mode_t;
}
extern "C" {
    pub fn fchmodat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstatat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut stat,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdirat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimens(__fd: ::std::os::raw::c_int, __times: *const timespec)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimensat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __times: *const timespec,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chflags(arg1: *const ::std::os::raw::c_char, arg2: __uint32_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chmodx_np(arg1: *const ::std::os::raw::c_char, arg2: filesec_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchflags(arg1: ::std::os::raw::c_int, arg2: __uint32_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmodx_np(arg1: ::std::os::raw::c_int, arg2: filesec_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut stat,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchflags(arg1: *const ::std::os::raw::c_char, arg2: __uint32_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchmod(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstatx_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut stat,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdirx_np(arg1: *const ::std::os::raw::c_char, arg2: filesec_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifox_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn statx_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut stat,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn umaskx_np(arg1: filesec_t) -> ::std::os::raw::c_int;
}
pub const uio_rw_UIO_READ: uio_rw = 0;
pub const uio_rw_UIO_WRITE: uio_rw = 1;
pub type uio_rw = ::std::os::raw::c_uint;
extern "C" {
    pub fn readv(
        arg1: ::std::os::raw::c_int,
        arg2: *const iovec,
        arg3: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn writev(
        arg1: ::std::os::raw::c_int,
        arg2: *const iovec,
        arg3: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn preadv(
        arg1: ::std::os::raw::c_int,
        arg2: *const iovec,
        arg3: ::std::os::raw::c_int,
        arg4: off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwritev(
        arg1: ::std::os::raw::c_int,
        arg2: *const iovec,
        arg3: ::std::os::raw::c_int,
        arg4: off_t,
    ) -> ssize_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_un {
    pub sun_len: ::std::os::raw::c_uchar,
    pub sun_family: sa_family_t,
    pub sun_path: [::std::os::raw::c_char; 104usize],
}
#[test]
fn bindgen_test_layout_sockaddr_un() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_un>(),
        106usize,
        concat!("Size of: ", stringify!(sockaddr_un))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_un>(),
        1usize,
        concat!("Alignment of ", stringify!(sockaddr_un))
    );
    fn test_field_sun_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_un>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sun_len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_un),
                "::",
                stringify!(sun_len)
            )
        );
    }
    test_field_sun_len();
    fn test_field_sun_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_un>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sun_family) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_un),
                "::",
                stringify!(sun_family)
            )
        );
    }
    test_field_sun_family();
    fn test_field_sun_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_un>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sun_path) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_un),
                "::",
                stringify!(sun_path)
            )
        );
    }
    test_field_sun_path();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct waitq_set {
    _unused: [u8; 0],
}
pub type au_id_t = uid_t;
pub type au_asid_t = pid_t;
pub type au_event_t = u_int16_t;
pub type au_emod_t = u_int16_t;
pub type au_class_t = u_int32_t;
pub type au_asflgs_t = u_int64_t;
pub type au_ctlmode_t = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_tid {
    pub port: dev_t,
    pub machine: u_int32_t,
}
#[test]
fn bindgen_test_layout_au_tid() {
    assert_eq!(
        ::std::mem::size_of::<au_tid>(),
        8usize,
        concat!("Size of: ", stringify!(au_tid))
    );
    assert_eq!(
        ::std::mem::align_of::<au_tid>(),
        4usize,
        concat!("Alignment of ", stringify!(au_tid))
    );
    fn test_field_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_tid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(au_tid),
                "::",
                stringify!(port)
            )
        );
    }
    test_field_port();
    fn test_field_machine() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_tid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).machine) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(au_tid),
                "::",
                stringify!(machine)
            )
        );
    }
    test_field_machine();
}
pub type au_tid_t = au_tid;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_tid_addr {
    pub at_port: dev_t,
    pub at_type: u_int32_t,
    pub at_addr: [u_int32_t; 4usize],
}
#[test]
fn bindgen_test_layout_au_tid_addr() {
    assert_eq!(
        ::std::mem::size_of::<au_tid_addr>(),
        24usize,
        concat!("Size of: ", stringify!(au_tid_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<au_tid_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(au_tid_addr))
    );
    fn test_field_at_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_tid_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).at_port) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(au_tid_addr),
                "::",
                stringify!(at_port)
            )
        );
    }
    test_field_at_port();
    fn test_field_at_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_tid_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).at_type) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(au_tid_addr),
                "::",
                stringify!(at_type)
            )
        );
    }
    test_field_at_type();
    fn test_field_at_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_tid_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).at_addr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(au_tid_addr),
                "::",
                stringify!(at_addr)
            )
        );
    }
    test_field_at_addr();
}
pub type au_tid_addr_t = au_tid_addr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_mask {
    pub am_success: ::std::os::raw::c_uint,
    pub am_failure: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_au_mask() {
    assert_eq!(
        ::std::mem::size_of::<au_mask>(),
        8usize,
        concat!("Size of: ", stringify!(au_mask))
    );
    assert_eq!(
        ::std::mem::align_of::<au_mask>(),
        4usize,
        concat!("Alignment of ", stringify!(au_mask))
    );
    fn test_field_am_success() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_mask>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).am_success) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(au_mask),
                "::",
                stringify!(am_success)
            )
        );
    }
    test_field_am_success();
    fn test_field_am_failure() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_mask>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).am_failure) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(au_mask),
                "::",
                stringify!(am_failure)
            )
        );
    }
    test_field_am_failure();
}
pub type au_mask_t = au_mask;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct auditinfo {
    pub ai_auid: au_id_t,
    pub ai_mask: au_mask_t,
    pub ai_termid: au_tid_t,
    pub ai_asid: au_asid_t,
}
#[test]
fn bindgen_test_layout_auditinfo() {
    assert_eq!(
        ::std::mem::size_of::<auditinfo>(),
        24usize,
        concat!("Size of: ", stringify!(auditinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<auditinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(auditinfo))
    );
    fn test_field_ai_auid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_auid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(auditinfo),
                "::",
                stringify!(ai_auid)
            )
        );
    }
    test_field_ai_auid();
    fn test_field_ai_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_mask) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(auditinfo),
                "::",
                stringify!(ai_mask)
            )
        );
    }
    test_field_ai_mask();
    fn test_field_ai_termid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_termid) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(auditinfo),
                "::",
                stringify!(ai_termid)
            )
        );
    }
    test_field_ai_termid();
    fn test_field_ai_asid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_asid) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(auditinfo),
                "::",
                stringify!(ai_asid)
            )
        );
    }
    test_field_ai_asid();
}
pub type auditinfo_t = auditinfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct auditinfo_addr {
    pub ai_auid: au_id_t,
    pub ai_mask: au_mask_t,
    pub ai_termid: au_tid_addr_t,
    pub ai_asid: au_asid_t,
    pub ai_flags: au_asflgs_t,
}
#[test]
fn bindgen_test_layout_auditinfo_addr() {
    assert_eq!(
        ::std::mem::size_of::<auditinfo_addr>(),
        48usize,
        concat!("Size of: ", stringify!(auditinfo_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<auditinfo_addr>(),
        8usize,
        concat!("Alignment of ", stringify!(auditinfo_addr))
    );
    fn test_field_ai_auid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_auid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(auditinfo_addr),
                "::",
                stringify!(ai_auid)
            )
        );
    }
    test_field_ai_auid();
    fn test_field_ai_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_mask) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(auditinfo_addr),
                "::",
                stringify!(ai_mask)
            )
        );
    }
    test_field_ai_mask();
    fn test_field_ai_termid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_termid) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(auditinfo_addr),
                "::",
                stringify!(ai_termid)
            )
        );
    }
    test_field_ai_termid();
    fn test_field_ai_asid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_asid) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(auditinfo_addr),
                "::",
                stringify!(ai_asid)
            )
        );
    }
    test_field_ai_asid();
    fn test_field_ai_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_flags) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(auditinfo_addr),
                "::",
                stringify!(ai_flags)
            )
        );
    }
    test_field_ai_flags();
}
pub type auditinfo_addr_t = auditinfo_addr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct auditpinfo {
    pub ap_pid: pid_t,
    pub ap_auid: au_id_t,
    pub ap_mask: au_mask_t,
    pub ap_termid: au_tid_t,
    pub ap_asid: au_asid_t,
}
#[test]
fn bindgen_test_layout_auditpinfo() {
    assert_eq!(
        ::std::mem::size_of::<auditpinfo>(),
        28usize,
        concat!("Size of: ", stringify!(auditpinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<auditpinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(auditpinfo))
    );
    fn test_field_ap_pid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_pid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo),
                "::",
                stringify!(ap_pid)
            )
        );
    }
    test_field_ap_pid();
    fn test_field_ap_auid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_auid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo),
                "::",
                stringify!(ap_auid)
            )
        );
    }
    test_field_ap_auid();
    fn test_field_ap_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_mask) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo),
                "::",
                stringify!(ap_mask)
            )
        );
    }
    test_field_ap_mask();
    fn test_field_ap_termid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_termid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo),
                "::",
                stringify!(ap_termid)
            )
        );
    }
    test_field_ap_termid();
    fn test_field_ap_asid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_asid) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo),
                "::",
                stringify!(ap_asid)
            )
        );
    }
    test_field_ap_asid();
}
pub type auditpinfo_t = auditpinfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct auditpinfo_addr {
    pub ap_pid: pid_t,
    pub ap_auid: au_id_t,
    pub ap_mask: au_mask_t,
    pub ap_termid: au_tid_addr_t,
    pub ap_asid: au_asid_t,
    pub ap_flags: au_asflgs_t,
}
#[test]
fn bindgen_test_layout_auditpinfo_addr() {
    assert_eq!(
        ::std::mem::size_of::<auditpinfo_addr>(),
        56usize,
        concat!("Size of: ", stringify!(auditpinfo_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<auditpinfo_addr>(),
        8usize,
        concat!("Alignment of ", stringify!(auditpinfo_addr))
    );
    fn test_field_ap_pid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_pid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo_addr),
                "::",
                stringify!(ap_pid)
            )
        );
    }
    test_field_ap_pid();
    fn test_field_ap_auid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_auid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo_addr),
                "::",
                stringify!(ap_auid)
            )
        );
    }
    test_field_ap_auid();
    fn test_field_ap_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_mask) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo_addr),
                "::",
                stringify!(ap_mask)
            )
        );
    }
    test_field_ap_mask();
    fn test_field_ap_termid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_termid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo_addr),
                "::",
                stringify!(ap_termid)
            )
        );
    }
    test_field_ap_termid();
    fn test_field_ap_asid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_asid) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo_addr),
                "::",
                stringify!(ap_asid)
            )
        );
    }
    test_field_ap_asid();
    fn test_field_ap_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_flags) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo_addr),
                "::",
                stringify!(ap_flags)
            )
        );
    }
    test_field_ap_flags();
}
pub type auditpinfo_addr_t = auditpinfo_addr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_session {
    pub as_aia_p: *mut auditinfo_addr_t,
    pub as_mask: au_mask_t,
}
#[test]
fn bindgen_test_layout_au_session() {
    assert_eq!(
        ::std::mem::size_of::<au_session>(),
        16usize,
        concat!("Size of: ", stringify!(au_session))
    );
    assert_eq!(
        ::std::mem::align_of::<au_session>(),
        8usize,
        concat!("Alignment of ", stringify!(au_session))
    );
    fn test_field_as_aia_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_session>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_aia_p) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(au_session),
                "::",
                stringify!(as_aia_p)
            )
        );
    }
    test_field_as_aia_p();
    fn test_field_as_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_session>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_mask) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(au_session),
                "::",
                stringify!(as_mask)
            )
        );
    }
    test_field_as_mask();
}
pub type au_session_t = au_session;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_expire_after {
    pub age: time_t,
    pub size: size_t,
    pub op_type: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_au_expire_after() {
    assert_eq!(
        ::std::mem::size_of::<au_expire_after>(),
        24usize,
        concat!("Size of: ", stringify!(au_expire_after))
    );
    assert_eq!(
        ::std::mem::align_of::<au_expire_after>(),
        8usize,
        concat!("Alignment of ", stringify!(au_expire_after))
    );
    fn test_field_age() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_expire_after>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).age) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(au_expire_after),
                "::",
                stringify!(age)
            )
        );
    }
    test_field_age();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_expire_after>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(au_expire_after),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_op_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_expire_after>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).op_type) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(au_expire_after),
                "::",
                stringify!(op_type)
            )
        );
    }
    test_field_op_type();
}
pub type au_expire_after_t = au_expire_after;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_token {
    _unused: [u8; 0],
}
pub type token_t = au_token;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_qctrl {
    pub aq_hiwater: ::std::os::raw::c_int,
    pub aq_lowater: ::std::os::raw::c_int,
    pub aq_bufsz: ::std::os::raw::c_int,
    pub aq_delay: ::std::os::raw::c_int,
    pub aq_minfree: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_au_qctrl() {
    assert_eq!(
        ::std::mem::size_of::<au_qctrl>(),
        20usize,
        concat!("Size of: ", stringify!(au_qctrl))
    );
    assert_eq!(
        ::std::mem::align_of::<au_qctrl>(),
        4usize,
        concat!("Alignment of ", stringify!(au_qctrl))
    );
    fn test_field_aq_hiwater() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_qctrl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aq_hiwater) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(au_qctrl),
                "::",
                stringify!(aq_hiwater)
            )
        );
    }
    test_field_aq_hiwater();
    fn test_field_aq_lowater() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_qctrl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aq_lowater) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(au_qctrl),
                "::",
                stringify!(aq_lowater)
            )
        );
    }
    test_field_aq_lowater();
    fn test_field_aq_bufsz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_qctrl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aq_bufsz) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(au_qctrl),
                "::",
                stringify!(aq_bufsz)
            )
        );
    }
    test_field_aq_bufsz();
    fn test_field_aq_delay() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_qctrl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aq_delay) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(au_qctrl),
                "::",
                stringify!(aq_delay)
            )
        );
    }
    test_field_aq_delay();
    fn test_field_aq_minfree() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_qctrl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aq_minfree) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(au_qctrl),
                "::",
                stringify!(aq_minfree)
            )
        );
    }
    test_field_aq_minfree();
}
pub type au_qctrl_t = au_qctrl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_stat {
    pub as_version: ::std::os::raw::c_uint,
    pub as_numevent: ::std::os::raw::c_uint,
    pub as_generated: ::std::os::raw::c_int,
    pub as_nonattrib: ::std::os::raw::c_int,
    pub as_kernel: ::std::os::raw::c_int,
    pub as_audit: ::std::os::raw::c_int,
    pub as_auditctl: ::std::os::raw::c_int,
    pub as_enqueue: ::std::os::raw::c_int,
    pub as_written: ::std::os::raw::c_int,
    pub as_wblocked: ::std::os::raw::c_int,
    pub as_rblocked: ::std::os::raw::c_int,
    pub as_dropped: ::std::os::raw::c_int,
    pub as_totalsize: ::std::os::raw::c_int,
    pub as_memused: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_audit_stat() {
    assert_eq!(
        ::std::mem::size_of::<audit_stat>(),
        56usize,
        concat!("Size of: ", stringify!(audit_stat))
    );
    assert_eq!(
        ::std::mem::align_of::<audit_stat>(),
        4usize,
        concat!("Alignment of ", stringify!(audit_stat))
    );
    fn test_field_as_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_version)
            )
        );
    }
    test_field_as_version();
    fn test_field_as_numevent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_numevent) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_numevent)
            )
        );
    }
    test_field_as_numevent();
    fn test_field_as_generated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_generated) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_generated)
            )
        );
    }
    test_field_as_generated();
    fn test_field_as_nonattrib() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_nonattrib) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_nonattrib)
            )
        );
    }
    test_field_as_nonattrib();
    fn test_field_as_kernel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_kernel) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_kernel)
            )
        );
    }
    test_field_as_kernel();
    fn test_field_as_audit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_audit) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_audit)
            )
        );
    }
    test_field_as_audit();
    fn test_field_as_auditctl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_auditctl) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_auditctl)
            )
        );
    }
    test_field_as_auditctl();
    fn test_field_as_enqueue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_enqueue) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_enqueue)
            )
        );
    }
    test_field_as_enqueue();
    fn test_field_as_written() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_written) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_written)
            )
        );
    }
    test_field_as_written();
    fn test_field_as_wblocked() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_wblocked) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_wblocked)
            )
        );
    }
    test_field_as_wblocked();
    fn test_field_as_rblocked() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_rblocked) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_rblocked)
            )
        );
    }
    test_field_as_rblocked();
    fn test_field_as_dropped() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_dropped) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_dropped)
            )
        );
    }
    test_field_as_dropped();
    fn test_field_as_totalsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_totalsize) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_totalsize)
            )
        );
    }
    test_field_as_totalsize();
    fn test_field_as_memused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_memused) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_memused)
            )
        );
    }
    test_field_as_memused();
}
pub type au_stat_t = audit_stat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_fstat {
    pub af_filesz: u_int64_t,
    pub af_currsz: u_int64_t,
}
#[test]
fn bindgen_test_layout_audit_fstat() {
    assert_eq!(
        ::std::mem::size_of::<audit_fstat>(),
        16usize,
        concat!("Size of: ", stringify!(audit_fstat))
    );
    assert_eq!(
        ::std::mem::align_of::<audit_fstat>(),
        8usize,
        concat!("Alignment of ", stringify!(audit_fstat))
    );
    fn test_field_af_filesz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_fstat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).af_filesz) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_fstat),
                "::",
                stringify!(af_filesz)
            )
        );
    }
    test_field_af_filesz();
    fn test_field_af_currsz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_fstat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).af_currsz) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_fstat),
                "::",
                stringify!(af_currsz)
            )
        );
    }
    test_field_af_currsz();
}
pub type au_fstat_t = audit_fstat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_evclass_map {
    pub ec_number: au_event_t,
    pub ec_class: au_class_t,
}
#[test]
fn bindgen_test_layout_au_evclass_map() {
    assert_eq!(
        ::std::mem::size_of::<au_evclass_map>(),
        8usize,
        concat!("Size of: ", stringify!(au_evclass_map))
    );
    assert_eq!(
        ::std::mem::align_of::<au_evclass_map>(),
        4usize,
        concat!("Alignment of ", stringify!(au_evclass_map))
    );
    fn test_field_ec_number() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_evclass_map>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ec_number) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(au_evclass_map),
                "::",
                stringify!(ec_number)
            )
        );
    }
    test_field_ec_number();
    fn test_field_ec_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_evclass_map>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ec_class) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(au_evclass_map),
                "::",
                stringify!(ec_class)
            )
        );
    }
    test_field_ec_class();
}
pub type au_evclass_map_t = au_evclass_map;
extern "C" {
    pub fn audit(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn auditon(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn auditctl(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getauid(arg1: *mut au_id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setauid(arg1: *const au_id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getaudit_addr(
        arg1: *mut auditinfo_addr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setaudit_addr(
        arg1: *const auditinfo_addr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getaudit(arg1: *mut auditinfo) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setaudit(arg1: *const auditinfo) -> ::std::os::raw::c_int;
}
pub type boolean_t = ::std::os::raw::c_int;
pub type natural_t = __darwin_natural_t;
pub type integer_t = ::std::os::raw::c_int;
pub type vm_offset_t = usize;
pub type vm_size_t = usize;
pub type mach_vm_address_t = u64;
pub type mach_vm_offset_t = u64;
pub type mach_vm_size_t = u64;
pub type vm_map_offset_t = u64;
pub type vm_map_address_t = u64;
pub type vm_map_size_t = u64;
pub type vm32_offset_t = u32;
pub type vm32_address_t = u32;
pub type vm32_size_t = u32;
pub type mach_port_context_t = vm_offset_t;
pub type mach_port_name_t = natural_t;
pub type mach_port_name_array_t = *mut mach_port_name_t;
pub type mach_port_array_t = *mut mach_port_t;
pub type mach_port_right_t = natural_t;
pub type mach_port_type_t = natural_t;
pub type mach_port_type_array_t = *mut mach_port_type_t;
pub type mach_port_urefs_t = natural_t;
pub type mach_port_delta_t = integer_t;
pub type mach_port_seqno_t = natural_t;
pub type mach_port_mscount_t = natural_t;
pub type mach_port_msgcount_t = natural_t;
pub type mach_port_rights_t = natural_t;
pub type mach_port_srights_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_status {
    pub mps_pset: mach_port_rights_t,
    pub mps_seqno: mach_port_seqno_t,
    pub mps_mscount: mach_port_mscount_t,
    pub mps_qlimit: mach_port_msgcount_t,
    pub mps_msgcount: mach_port_msgcount_t,
    pub mps_sorights: mach_port_rights_t,
    pub mps_srights: boolean_t,
    pub mps_pdrequest: boolean_t,
    pub mps_nsrequest: boolean_t,
    pub mps_flags: natural_t,
}
#[test]
fn bindgen_test_layout_mach_port_status() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_status>(),
        40usize,
        concat!("Size of: ", stringify!(mach_port_status))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_status>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_status))
    );
    fn test_field_mps_pset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_pset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_pset)
            )
        );
    }
    test_field_mps_pset();
    fn test_field_mps_seqno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_seqno) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_seqno)
            )
        );
    }
    test_field_mps_seqno();
    fn test_field_mps_mscount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_mscount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_mscount)
            )
        );
    }
    test_field_mps_mscount();
    fn test_field_mps_qlimit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_qlimit) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_qlimit)
            )
        );
    }
    test_field_mps_qlimit();
    fn test_field_mps_msgcount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_msgcount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_msgcount)
            )
        );
    }
    test_field_mps_msgcount();
    fn test_field_mps_sorights() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_sorights) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_sorights)
            )
        );
    }
    test_field_mps_sorights();
    fn test_field_mps_srights() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_srights) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_srights)
            )
        );
    }
    test_field_mps_srights();
    fn test_field_mps_pdrequest() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_pdrequest) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_pdrequest)
            )
        );
    }
    test_field_mps_pdrequest();
    fn test_field_mps_nsrequest() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_nsrequest) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_nsrequest)
            )
        );
    }
    test_field_mps_nsrequest();
    fn test_field_mps_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_flags) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_flags)
            )
        );
    }
    test_field_mps_flags();
}
pub type mach_port_status_t = mach_port_status;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_limits {
    pub mpl_qlimit: mach_port_msgcount_t,
}
#[test]
fn bindgen_test_layout_mach_port_limits() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_limits>(),
        4usize,
        concat!("Size of: ", stringify!(mach_port_limits))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_limits>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_limits))
    );
    fn test_field_mpl_qlimit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_limits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mpl_qlimit) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_limits),
                "::",
                stringify!(mpl_qlimit)
            )
        );
    }
    test_field_mpl_qlimit();
}
pub type mach_port_limits_t = mach_port_limits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_info_ext {
    pub mpie_status: mach_port_status_t,
    pub mpie_boost_cnt: mach_port_msgcount_t,
    pub reserved: [u32; 6usize],
}
#[test]
fn bindgen_test_layout_mach_port_info_ext() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_info_ext>(),
        68usize,
        concat!("Size of: ", stringify!(mach_port_info_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_info_ext>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_info_ext))
    );
    fn test_field_mpie_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_info_ext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mpie_status) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_info_ext),
                "::",
                stringify!(mpie_status)
            )
        );
    }
    test_field_mpie_status();
    fn test_field_mpie_boost_cnt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_info_ext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mpie_boost_cnt) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_info_ext),
                "::",
                stringify!(mpie_boost_cnt)
            )
        );
    }
    test_field_mpie_boost_cnt();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_info_ext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_info_ext),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type mach_port_info_ext_t = mach_port_info_ext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_guard_info {
    pub mpgi_guard: u64,
}
#[test]
fn bindgen_test_layout_mach_port_guard_info() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_guard_info>(),
        8usize,
        concat!("Size of: ", stringify!(mach_port_guard_info))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_guard_info>(),
        8usize,
        concat!("Alignment of ", stringify!(mach_port_guard_info))
    );
    fn test_field_mpgi_guard() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_guard_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mpgi_guard) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_guard_info),
                "::",
                stringify!(mpgi_guard)
            )
        );
    }
    test_field_mpgi_guard();
}
pub type mach_port_guard_info_t = mach_port_guard_info;
pub type mach_port_info_t = *mut integer_t;
pub type mach_port_flavor_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_qos {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub len: natural_t,
}
#[test]
fn bindgen_test_layout_mach_port_qos() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_qos>(),
        8usize,
        concat!("Size of: ", stringify!(mach_port_qos))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_qos>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_qos))
    );
    fn test_field_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_qos>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_qos),
                "::",
                stringify!(len)
            )
        );
    }
    test_field_len();
}
impl mach_port_qos {
    #[inline]
    pub fn name(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_name(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn prealloc(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_prealloc(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pad1(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_pad1(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        name: ::std::os::raw::c_uint,
        prealloc: ::std::os::raw::c_uint,
        pad1: boolean_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let name: u32 = unsafe { ::std::mem::transmute(name) };
            name as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let prealloc: u32 = unsafe { ::std::mem::transmute(prealloc) };
            prealloc as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let pad1: u32 = unsafe { ::std::mem::transmute(pad1) };
            pad1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type mach_port_qos_t = mach_port_qos;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_service_port_info {
    pub mspi_string_name: [::std::os::raw::c_char; 255usize],
    pub mspi_domain_type: u8,
}
#[test]
fn bindgen_test_layout_mach_service_port_info() {
    assert_eq!(
        ::std::mem::size_of::<mach_service_port_info>(),
        256usize,
        concat!("Size of: ", stringify!(mach_service_port_info))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_service_port_info>(),
        1usize,
        concat!("Alignment of ", stringify!(mach_service_port_info))
    );
    fn test_field_mspi_string_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_service_port_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mspi_string_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_service_port_info),
                "::",
                stringify!(mspi_string_name)
            )
        );
    }
    test_field_mspi_string_name();
    fn test_field_mspi_domain_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_service_port_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mspi_domain_type) as usize - ptr as usize
            },
            255usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_service_port_info),
                "::",
                stringify!(mspi_domain_type)
            )
        );
    }
    test_field_mspi_domain_type();
}
pub type mach_service_port_info_data_t = mach_service_port_info;
pub type mach_service_port_info_t = *mut mach_service_port_info;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mach_port_options {
    pub flags: u32,
    pub mpl: mach_port_limits_t,
    pub __bindgen_anon_1: mach_port_options__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mach_port_options__bindgen_ty_1 {
    pub reserved: [u64; 2usize],
    pub work_interval_port: mach_port_name_t,
    pub service_port_info: mach_service_port_info_t,
    pub service_port_name: mach_port_name_t,
}
#[test]
fn bindgen_test_layout_mach_port_options__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_options__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(mach_port_options__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_options__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(mach_port_options__bindgen_ty_1))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_options__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_options__bindgen_ty_1),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
    fn test_field_work_interval_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_options__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).work_interval_port) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_options__bindgen_ty_1),
                "::",
                stringify!(work_interval_port)
            )
        );
    }
    test_field_work_interval_port();
    fn test_field_service_port_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_options__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).service_port_info) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_options__bindgen_ty_1),
                "::",
                stringify!(service_port_info)
            )
        );
    }
    test_field_service_port_info();
    fn test_field_service_port_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_options__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).service_port_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_options__bindgen_ty_1),
                "::",
                stringify!(service_port_name)
            )
        );
    }
    test_field_service_port_name();
}
#[test]
fn bindgen_test_layout_mach_port_options() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_options>(),
        24usize,
        concat!("Size of: ", stringify!(mach_port_options))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_options>(),
        8usize,
        concat!("Alignment of ", stringify!(mach_port_options))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_options>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_options),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_mpl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_options>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mpl) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_options),
                "::",
                stringify!(mpl)
            )
        );
    }
    test_field_mpl();
}
pub type mach_port_options_t = mach_port_options;
pub type mach_port_options_ptr_t = *mut mach_port_options_t;
pub const mach_port_guard_exception_codes_kGUARD_EXC_DESTROY: mach_port_guard_exception_codes = 1;
pub const mach_port_guard_exception_codes_kGUARD_EXC_MOD_REFS: mach_port_guard_exception_codes = 2;
pub const mach_port_guard_exception_codes_kGUARD_EXC_SET_CONTEXT: mach_port_guard_exception_codes =
    4;
pub const mach_port_guard_exception_codes_kGUARD_EXC_UNGUARDED: mach_port_guard_exception_codes = 8;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INCORRECT_GUARD:
    mach_port_guard_exception_codes = 16;
pub const mach_port_guard_exception_codes_kGUARD_EXC_IMMOVABLE: mach_port_guard_exception_codes =
    32;
pub const mach_port_guard_exception_codes_kGUARD_EXC_STRICT_REPLY: mach_port_guard_exception_codes =
    64;
pub const mach_port_guard_exception_codes_kGUARD_EXC_MSG_FILTERED: mach_port_guard_exception_codes =
    128;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_RIGHT:
    mach_port_guard_exception_codes = 256;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_NAME: mach_port_guard_exception_codes =
    512;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_VALUE:
    mach_port_guard_exception_codes = 1024;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_ARGUMENT:
    mach_port_guard_exception_codes = 2048;
pub const mach_port_guard_exception_codes_kGUARD_EXC_RIGHT_EXISTS: mach_port_guard_exception_codes =
    4096;
pub const mach_port_guard_exception_codes_kGUARD_EXC_KERN_NO_SPACE:
    mach_port_guard_exception_codes = 8192;
pub const mach_port_guard_exception_codes_kGUARD_EXC_KERN_FAILURE: mach_port_guard_exception_codes =
    16384;
pub const mach_port_guard_exception_codes_kGUARD_EXC_KERN_RESOURCE:
    mach_port_guard_exception_codes = 32768;
pub const mach_port_guard_exception_codes_kGUARD_EXC_SEND_INVALID_REPLY:
    mach_port_guard_exception_codes = 65536;
pub const mach_port_guard_exception_codes_kGUARD_EXC_SEND_INVALID_VOUCHER:
    mach_port_guard_exception_codes = 131072;
pub const mach_port_guard_exception_codes_kGUARD_EXC_SEND_INVALID_RIGHT:
    mach_port_guard_exception_codes = 262144;
pub const mach_port_guard_exception_codes_kGUARD_EXC_RCV_INVALID_NAME:
    mach_port_guard_exception_codes = 524288;
pub const mach_port_guard_exception_codes_kGUARD_EXC_RCV_GUARDED_DESC:
    mach_port_guard_exception_codes = 1048576;
pub const mach_port_guard_exception_codes_kGUARD_EXC_MOD_REFS_NON_FATAL:
    mach_port_guard_exception_codes = 2097152;
pub const mach_port_guard_exception_codes_kGUARD_EXC_IMMOVABLE_NON_FATAL:
    mach_port_guard_exception_codes = 4194304;
pub type mach_port_guard_exception_codes = ::std::os::raw::c_uint;
extern "C" {
    pub fn audit_session_self() -> mach_port_name_t;
}
extern "C" {
    pub fn audit_session_join(port: mach_port_name_t) -> au_asid_t;
}
extern "C" {
    pub fn audit_session_port(
        asid: au_asid_t,
        portname: *mut mach_port_name_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct label {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucred {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_cred {
    _unused: [u8; 0],
}
pub type kauth_cred_t = *mut ucred;
pub type posix_cred_t = *mut posix_cred;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xucred {
    pub cr_version: u_int,
    pub cr_uid: uid_t,
    pub cr_ngroups: ::std::os::raw::c_short,
    pub cr_groups: [gid_t; 16usize],
}
#[test]
fn bindgen_test_layout_xucred() {
    assert_eq!(
        ::std::mem::size_of::<xucred>(),
        76usize,
        concat!("Size of: ", stringify!(xucred))
    );
    assert_eq!(
        ::std::mem::align_of::<xucred>(),
        4usize,
        concat!("Alignment of ", stringify!(xucred))
    );
    fn test_field_cr_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<xucred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cr_version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(xucred),
                "::",
                stringify!(cr_version)
            )
        );
    }
    test_field_cr_version();
    fn test_field_cr_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<xucred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cr_uid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(xucred),
                "::",
                stringify!(cr_uid)
            )
        );
    }
    test_field_cr_uid();
    fn test_field_cr_ngroups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<xucred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cr_ngroups) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(xucred),
                "::",
                stringify!(cr_ngroups)
            )
        );
    }
    test_field_cr_ngroups();
    fn test_field_cr_groups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<xucred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cr_groups) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(xucred),
                "::",
                stringify!(cr_groups)
            )
        );
    }
    test_field_cr_groups();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmspace {
    pub dummy: i32,
    pub dummy2: caddr_t,
    pub dummy3: [i32; 5usize],
    pub dummy4: [caddr_t; 3usize],
}
#[test]
fn bindgen_test_layout_vmspace() {
    assert_eq!(
        ::std::mem::size_of::<vmspace>(),
        64usize,
        concat!("Size of: ", stringify!(vmspace))
    );
    assert_eq!(
        ::std::mem::align_of::<vmspace>(),
        8usize,
        concat!("Alignment of ", stringify!(vmspace))
    );
    fn test_field_dummy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<vmspace>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vmspace),
                "::",
                stringify!(dummy)
            )
        );
    }
    test_field_dummy();
    fn test_field_dummy2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<vmspace>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy2) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(vmspace),
                "::",
                stringify!(dummy2)
            )
        );
    }
    test_field_dummy2();
    fn test_field_dummy3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<vmspace>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy3) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(vmspace),
                "::",
                stringify!(dummy3)
            )
        );
    }
    test_field_dummy3();
    fn test_field_dummy4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<vmspace>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy4) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(vmspace),
                "::",
                stringify!(dummy4)
            )
        );
    }
    test_field_dummy4();
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct kevent {
    pub ident: usize,
    pub filter: i16,
    pub flags: u16,
    pub fflags: u32,
    pub data: isize,
    pub udata: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_kevent() {
    assert_eq!(
        ::std::mem::size_of::<kevent>(),
        32usize,
        concat!("Size of: ", stringify!(kevent))
    );
    assert_eq!(
        ::std::mem::align_of::<kevent>(),
        4usize,
        concat!("Alignment of ", stringify!(kevent))
    );
    fn test_field_ident() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ident) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent),
                "::",
                stringify!(ident)
            )
        );
    }
    test_field_ident();
    fn test_field_filter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filter) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent),
                "::",
                stringify!(filter)
            )
        );
    }
    test_field_filter();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_fflags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fflags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent),
                "::",
                stringify!(fflags)
            )
        );
    }
    test_field_fflags();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_udata() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).udata) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent),
                "::",
                stringify!(udata)
            )
        );
    }
    test_field_udata();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kevent64_s {
    pub ident: u64,
    pub filter: i16,
    pub flags: u16,
    pub fflags: u32,
    pub data: i64,
    pub udata: u64,
    pub ext: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_kevent64_s() {
    assert_eq!(
        ::std::mem::size_of::<kevent64_s>(),
        48usize,
        concat!("Size of: ", stringify!(kevent64_s))
    );
    assert_eq!(
        ::std::mem::align_of::<kevent64_s>(),
        8usize,
        concat!("Alignment of ", stringify!(kevent64_s))
    );
    fn test_field_ident() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent64_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ident) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent64_s),
                "::",
                stringify!(ident)
            )
        );
    }
    test_field_ident();
    fn test_field_filter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent64_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filter) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent64_s),
                "::",
                stringify!(filter)
            )
        );
    }
    test_field_filter();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent64_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent64_s),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_fflags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent64_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fflags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent64_s),
                "::",
                stringify!(fflags)
            )
        );
    }
    test_field_fflags();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent64_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent64_s),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_udata() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent64_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).udata) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent64_s),
                "::",
                stringify!(udata)
            )
        );
    }
    test_field_udata();
    fn test_field_ext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent64_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ext) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent64_s),
                "::",
                stringify!(ext)
            )
        );
    }
    test_field_ext();
}
pub const eNoteReapDeprecated: _bindgen_ty_2 = 268435456;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const eNoteExitReparentedDeprecated: _bindgen_ty_3 = 524288;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct knote {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct klist {
    pub slh_first: *mut knote,
}
#[test]
fn bindgen_test_layout_klist() {
    assert_eq!(
        ::std::mem::size_of::<klist>(),
        8usize,
        concat!("Size of: ", stringify!(klist))
    );
    assert_eq!(
        ::std::mem::align_of::<klist>(),
        8usize,
        concat!("Alignment of ", stringify!(klist))
    );
    fn test_field_slh_first() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<klist>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).slh_first) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(klist),
                "::",
                stringify!(slh_first)
            )
        );
    }
    test_field_slh_first();
}
extern "C" {
    pub fn kqueue() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kevent(
        kq: ::std::os::raw::c_int,
        changelist: *const kevent,
        nchanges: ::std::os::raw::c_int,
        eventlist: *mut kevent,
        nevents: ::std::os::raw::c_int,
        timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kevent64(
        kq: ::std::os::raw::c_int,
        changelist: *const kevent64_s,
        nchanges: ::std::os::raw::c_int,
        eventlist: *mut kevent64_s,
        nevents: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct session {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pgrp {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_ {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_ident {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct extern_proc {
    pub p_un: extern_proc__bindgen_ty_1,
    pub p_vmspace: *mut vmspace,
    pub p_sigacts: *mut sigacts,
    pub p_flag: ::std::os::raw::c_int,
    pub p_stat: ::std::os::raw::c_char,
    pub p_pid: pid_t,
    pub p_oppid: pid_t,
    pub p_dupfd: ::std::os::raw::c_int,
    pub user_stack: caddr_t,
    pub exit_thread: *mut ::std::os::raw::c_void,
    pub p_debugger: ::std::os::raw::c_int,
    pub sigwait: boolean_t,
    pub p_estcpu: u_int,
    pub p_cpticks: ::std::os::raw::c_int,
    pub p_pctcpu: fixpt_t,
    pub p_wchan: *mut ::std::os::raw::c_void,
    pub p_wmesg: *mut ::std::os::raw::c_char,
    pub p_swtime: u_int,
    pub p_slptime: u_int,
    pub p_realtimer: itimerval,
    pub p_rtime: timeval,
    pub p_uticks: u_quad_t,
    pub p_sticks: u_quad_t,
    pub p_iticks: u_quad_t,
    pub p_traceflag: ::std::os::raw::c_int,
    pub p_tracep: *mut vnode,
    pub p_siglist: ::std::os::raw::c_int,
    pub p_textvp: *mut vnode,
    pub p_holdcnt: ::std::os::raw::c_int,
    pub p_sigmask: sigset_t,
    pub p_sigignore: sigset_t,
    pub p_sigcatch: sigset_t,
    pub p_priority: u_char,
    pub p_usrpri: u_char,
    pub p_nice: ::std::os::raw::c_char,
    pub p_comm: [::std::os::raw::c_char; 17usize],
    pub p_pgrp: *mut pgrp,
    pub p_addr: *mut user,
    pub p_xstat: u_short,
    pub p_acflag: u_short,
    pub p_ru: *mut rusage,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union extern_proc__bindgen_ty_1 {
    pub p_st1: extern_proc__bindgen_ty_1__bindgen_ty_1,
    pub __p_starttime: timeval,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct extern_proc__bindgen_ty_1__bindgen_ty_1 {
    pub __p_forw: *mut proc_,
    pub __p_back: *mut proc_,
}
#[test]
fn bindgen_test_layout_extern_proc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<extern_proc__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(extern_proc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<extern_proc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(extern_proc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field___p_forw() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<extern_proc__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__p_forw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(__p_forw)
            )
        );
    }
    test_field___p_forw();
    fn test_field___p_back() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<extern_proc__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__p_back) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(__p_back)
            )
        );
    }
    test_field___p_back();
}
#[test]
fn bindgen_test_layout_extern_proc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<extern_proc__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(extern_proc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<extern_proc__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(extern_proc__bindgen_ty_1))
    );
    fn test_field_p_st1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_st1) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc__bindgen_ty_1),
                "::",
                stringify!(p_st1)
            )
        );
    }
    test_field_p_st1();
    fn test_field___p_starttime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__p_starttime) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc__bindgen_ty_1),
                "::",
                stringify!(__p_starttime)
            )
        );
    }
    test_field___p_starttime();
}
#[test]
fn bindgen_test_layout_extern_proc() {
    assert_eq!(
        ::std::mem::size_of::<extern_proc>(),
        296usize,
        concat!("Size of: ", stringify!(extern_proc))
    );
    assert_eq!(
        ::std::mem::align_of::<extern_proc>(),
        8usize,
        concat!("Alignment of ", stringify!(extern_proc))
    );
    fn test_field_p_un() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_un) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_un)
            )
        );
    }
    test_field_p_un();
    fn test_field_p_vmspace() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_vmspace) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_vmspace)
            )
        );
    }
    test_field_p_vmspace();
    fn test_field_p_sigacts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_sigacts) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_sigacts)
            )
        );
    }
    test_field_p_sigacts();
    fn test_field_p_flag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_flag) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_flag)
            )
        );
    }
    test_field_p_flag();
    fn test_field_p_stat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_stat) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_stat)
            )
        );
    }
    test_field_p_stat();
    fn test_field_p_pid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_pid) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_pid)
            )
        );
    }
    test_field_p_pid();
    fn test_field_p_oppid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_oppid) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_oppid)
            )
        );
    }
    test_field_p_oppid();
    fn test_field_p_dupfd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_dupfd) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_dupfd)
            )
        );
    }
    test_field_p_dupfd();
    fn test_field_user_stack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user_stack) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(user_stack)
            )
        );
    }
    test_field_user_stack();
    fn test_field_exit_thread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).exit_thread) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(exit_thread)
            )
        );
    }
    test_field_exit_thread();
    fn test_field_p_debugger() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_debugger) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_debugger)
            )
        );
    }
    test_field_p_debugger();
    fn test_field_sigwait() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sigwait) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(sigwait)
            )
        );
    }
    test_field_sigwait();
    fn test_field_p_estcpu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_estcpu) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_estcpu)
            )
        );
    }
    test_field_p_estcpu();
    fn test_field_p_cpticks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_cpticks) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_cpticks)
            )
        );
    }
    test_field_p_cpticks();
    fn test_field_p_pctcpu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_pctcpu) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_pctcpu)
            )
        );
    }
    test_field_p_pctcpu();
    fn test_field_p_wchan() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_wchan) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_wchan)
            )
        );
    }
    test_field_p_wchan();
    fn test_field_p_wmesg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_wmesg) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_wmesg)
            )
        );
    }
    test_field_p_wmesg();
    fn test_field_p_swtime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_swtime) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_swtime)
            )
        );
    }
    test_field_p_swtime();
    fn test_field_p_slptime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_slptime) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_slptime)
            )
        );
    }
    test_field_p_slptime();
    fn test_field_p_realtimer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_realtimer) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_realtimer)
            )
        );
    }
    test_field_p_realtimer();
    fn test_field_p_rtime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_rtime) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_rtime)
            )
        );
    }
    test_field_p_rtime();
    fn test_field_p_uticks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_uticks) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_uticks)
            )
        );
    }
    test_field_p_uticks();
    fn test_field_p_sticks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_sticks) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_sticks)
            )
        );
    }
    test_field_p_sticks();
    fn test_field_p_iticks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_iticks) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_iticks)
            )
        );
    }
    test_field_p_iticks();
    fn test_field_p_traceflag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_traceflag) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_traceflag)
            )
        );
    }
    test_field_p_traceflag();
    fn test_field_p_tracep() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_tracep) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_tracep)
            )
        );
    }
    test_field_p_tracep();
    fn test_field_p_siglist() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_siglist) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_siglist)
            )
        );
    }
    test_field_p_siglist();
    fn test_field_p_textvp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_textvp) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_textvp)
            )
        );
    }
    test_field_p_textvp();
    fn test_field_p_holdcnt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_holdcnt) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_holdcnt)
            )
        );
    }
    test_field_p_holdcnt();
    fn test_field_p_sigmask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_sigmask) as usize - ptr as usize
            },
            228usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_sigmask)
            )
        );
    }
    test_field_p_sigmask();
    fn test_field_p_sigignore() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_sigignore) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_sigignore)
            )
        );
    }
    test_field_p_sigignore();
    fn test_field_p_sigcatch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_sigcatch) as usize - ptr as usize
            },
            236usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_sigcatch)
            )
        );
    }
    test_field_p_sigcatch();
    fn test_field_p_priority() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_priority) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_priority)
            )
        );
    }
    test_field_p_priority();
    fn test_field_p_usrpri() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_usrpri) as usize - ptr as usize
            },
            241usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_usrpri)
            )
        );
    }
    test_field_p_usrpri();
    fn test_field_p_nice() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_nice) as usize - ptr as usize
            },
            242usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_nice)
            )
        );
    }
    test_field_p_nice();
    fn test_field_p_comm() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_comm) as usize - ptr as usize
            },
            243usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_comm)
            )
        );
    }
    test_field_p_comm();
    fn test_field_p_pgrp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_pgrp) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_pgrp)
            )
        );
    }
    test_field_p_pgrp();
    fn test_field_p_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_addr) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_addr)
            )
        );
    }
    test_field_p_addr();
    fn test_field_p_xstat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_xstat) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_xstat)
            )
        );
    }
    test_field_p_xstat();
    fn test_field_p_acflag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_acflag) as usize - ptr as usize
            },
            282usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_acflag)
            )
        );
    }
    test_field_p_acflag();
    fn test_field_p_ru() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_ru) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_ru)
            )
        );
    }
    test_field_p_ru();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctlname {
    pub ctl_name: *mut ::std::os::raw::c_char,
    pub ctl_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ctlname() {
    assert_eq!(
        ::std::mem::size_of::<ctlname>(),
        16usize,
        concat!("Size of: ", stringify!(ctlname))
    );
    assert_eq!(
        ::std::mem::align_of::<ctlname>(),
        8usize,
        concat!("Alignment of ", stringify!(ctlname))
    );
    fn test_field_ctl_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ctlname>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctl_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ctlname),
                "::",
                stringify!(ctl_name)
            )
        );
    }
    test_field_ctl_name();
    fn test_field_ctl_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ctlname>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctl_type) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ctlname),
                "::",
                stringify!(ctl_type)
            )
        );
    }
    test_field_ctl_type();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pcred {
    pub pc_lock: [::std::os::raw::c_char; 72usize],
    pub pc_ucred: *mut ucred,
    pub p_ruid: uid_t,
    pub p_svuid: uid_t,
    pub p_rgid: gid_t,
    pub p_svgid: gid_t,
    pub p_refcnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__pcred() {
    assert_eq!(
        ::std::mem::size_of::<_pcred>(),
        104usize,
        concat!("Size of: ", stringify!(_pcred))
    );
    assert_eq!(
        ::std::mem::align_of::<_pcred>(),
        8usize,
        concat!("Alignment of ", stringify!(_pcred))
    );
    fn test_field_pc_lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_pcred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pc_lock) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_pcred),
                "::",
                stringify!(pc_lock)
            )
        );
    }
    test_field_pc_lock();
    fn test_field_pc_ucred() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_pcred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pc_ucred) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_pcred),
                "::",
                stringify!(pc_ucred)
            )
        );
    }
    test_field_pc_ucred();
    fn test_field_p_ruid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_pcred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_ruid) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_pcred),
                "::",
                stringify!(p_ruid)
            )
        );
    }
    test_field_p_ruid();
    fn test_field_p_svuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_pcred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_svuid) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(_pcred),
                "::",
                stringify!(p_svuid)
            )
        );
    }
    test_field_p_svuid();
    fn test_field_p_rgid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_pcred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_rgid) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_pcred),
                "::",
                stringify!(p_rgid)
            )
        );
    }
    test_field_p_rgid();
    fn test_field_p_svgid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_pcred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_svgid) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(_pcred),
                "::",
                stringify!(p_svgid)
            )
        );
    }
    test_field_p_svgid();
    fn test_field_p_refcnt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_pcred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_refcnt) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_pcred),
                "::",
                stringify!(p_refcnt)
            )
        );
    }
    test_field_p_refcnt();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ucred {
    pub cr_ref: i32,
    pub cr_uid: uid_t,
    pub cr_ngroups: ::std::os::raw::c_short,
    pub cr_groups: [gid_t; 16usize],
}
#[test]
fn bindgen_test_layout__ucred() {
    assert_eq!(
        ::std::mem::size_of::<_ucred>(),
        76usize,
        concat!("Size of: ", stringify!(_ucred))
    );
    assert_eq!(
        ::std::mem::align_of::<_ucred>(),
        4usize,
        concat!("Alignment of ", stringify!(_ucred))
    );
    fn test_field_cr_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_ucred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cr_ref) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_ucred),
                "::",
                stringify!(cr_ref)
            )
        );
    }
    test_field_cr_ref();
    fn test_field_cr_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_ucred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cr_uid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_ucred),
                "::",
                stringify!(cr_uid)
            )
        );
    }
    test_field_cr_uid();
    fn test_field_cr_ngroups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_ucred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cr_ngroups) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_ucred),
                "::",
                stringify!(cr_ngroups)
            )
        );
    }
    test_field_cr_ngroups();
    fn test_field_cr_groups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_ucred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cr_groups) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_ucred),
                "::",
                stringify!(cr_groups)
            )
        );
    }
    test_field_cr_groups();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kinfo_proc {
    pub kp_proc: extern_proc,
    pub kp_eproc: kinfo_proc_eproc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kinfo_proc_eproc {
    pub e_paddr: *mut proc_,
    pub e_sess: *mut session,
    pub e_pcred: _pcred,
    pub e_ucred: _ucred,
    pub e_vm: vmspace,
    pub e_ppid: pid_t,
    pub e_pgid: pid_t,
    pub e_jobc: ::std::os::raw::c_short,
    pub e_tdev: dev_t,
    pub e_tpgid: pid_t,
    pub e_tsess: *mut session,
    pub e_wmesg: [::std::os::raw::c_char; 8usize],
    pub e_xsize: segsz_t,
    pub e_xrssize: ::std::os::raw::c_short,
    pub e_xccount: ::std::os::raw::c_short,
    pub e_xswrss: ::std::os::raw::c_short,
    pub e_flag: i32,
    pub e_login: [::std::os::raw::c_char; 12usize],
    pub e_spare: [i32; 4usize],
}
#[test]
fn bindgen_test_layout_kinfo_proc_eproc() {
    assert_eq!(
        ::std::mem::size_of::<kinfo_proc_eproc>(),
        352usize,
        concat!("Size of: ", stringify!(kinfo_proc_eproc))
    );
    assert_eq!(
        ::std::mem::align_of::<kinfo_proc_eproc>(),
        8usize,
        concat!("Alignment of ", stringify!(kinfo_proc_eproc))
    );
    fn test_field_e_paddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_paddr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_paddr)
            )
        );
    }
    test_field_e_paddr();
    fn test_field_e_sess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_sess) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_sess)
            )
        );
    }
    test_field_e_sess();
    fn test_field_e_pcred() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_pcred) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_pcred)
            )
        );
    }
    test_field_e_pcred();
    fn test_field_e_ucred() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_ucred) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_ucred)
            )
        );
    }
    test_field_e_ucred();
    fn test_field_e_vm() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_vm) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_vm)
            )
        );
    }
    test_field_e_vm();
    fn test_field_e_ppid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_ppid) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_ppid)
            )
        );
    }
    test_field_e_ppid();
    fn test_field_e_pgid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_pgid) as usize - ptr as usize
            },
            268usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_pgid)
            )
        );
    }
    test_field_e_pgid();
    fn test_field_e_jobc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_jobc) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_jobc)
            )
        );
    }
    test_field_e_jobc();
    fn test_field_e_tdev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_tdev) as usize - ptr as usize
            },
            276usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_tdev)
            )
        );
    }
    test_field_e_tdev();
    fn test_field_e_tpgid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_tpgid) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_tpgid)
            )
        );
    }
    test_field_e_tpgid();
    fn test_field_e_tsess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_tsess) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_tsess)
            )
        );
    }
    test_field_e_tsess();
    fn test_field_e_wmesg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_wmesg) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_wmesg)
            )
        );
    }
    test_field_e_wmesg();
    fn test_field_e_xsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_xsize) as usize - ptr as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_xsize)
            )
        );
    }
    test_field_e_xsize();
    fn test_field_e_xrssize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_xrssize) as usize - ptr as usize
            },
            308usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_xrssize)
            )
        );
    }
    test_field_e_xrssize();
    fn test_field_e_xccount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_xccount) as usize - ptr as usize
            },
            310usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_xccount)
            )
        );
    }
    test_field_e_xccount();
    fn test_field_e_xswrss() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_xswrss) as usize - ptr as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_xswrss)
            )
        );
    }
    test_field_e_xswrss();
    fn test_field_e_flag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_flag) as usize - ptr as usize
            },
            316usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_flag)
            )
        );
    }
    test_field_e_flag();
    fn test_field_e_login() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_login) as usize - ptr as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_login)
            )
        );
    }
    test_field_e_login();
    fn test_field_e_spare() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_spare) as usize - ptr as usize
            },
            332usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_spare)
            )
        );
    }
    test_field_e_spare();
}
#[test]
fn bindgen_test_layout_kinfo_proc() {
    assert_eq!(
        ::std::mem::size_of::<kinfo_proc>(),
        648usize,
        concat!("Size of: ", stringify!(kinfo_proc))
    );
    assert_eq!(
        ::std::mem::align_of::<kinfo_proc>(),
        8usize,
        concat!("Alignment of ", stringify!(kinfo_proc))
    );
    fn test_field_kp_proc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kp_proc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc),
                "::",
                stringify!(kp_proc)
            )
        );
    }
    test_field_kp_proc();
    fn test_field_kp_eproc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kp_eproc) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc),
                "::",
                stringify!(kp_eproc)
            )
        );
    }
    test_field_kp_eproc();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xsw_usage {
    pub xsu_total: u_int64_t,
    pub xsu_avail: u_int64_t,
    pub xsu_used: u_int64_t,
    pub xsu_pagesize: u_int32_t,
    pub xsu_encrypted: boolean_t,
}
#[test]
fn bindgen_test_layout_xsw_usage() {
    assert_eq!(
        ::std::mem::size_of::<xsw_usage>(),
        32usize,
        concat!("Size of: ", stringify!(xsw_usage))
    );
    assert_eq!(
        ::std::mem::align_of::<xsw_usage>(),
        8usize,
        concat!("Alignment of ", stringify!(xsw_usage))
    );
    fn test_field_xsu_total() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<xsw_usage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xsu_total) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(xsw_usage),
                "::",
                stringify!(xsu_total)
            )
        );
    }
    test_field_xsu_total();
    fn test_field_xsu_avail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<xsw_usage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xsu_avail) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(xsw_usage),
                "::",
                stringify!(xsu_avail)
            )
        );
    }
    test_field_xsu_avail();
    fn test_field_xsu_used() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<xsw_usage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xsu_used) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(xsw_usage),
                "::",
                stringify!(xsu_used)
            )
        );
    }
    test_field_xsu_used();
    fn test_field_xsu_pagesize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<xsw_usage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xsu_pagesize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(xsw_usage),
                "::",
                stringify!(xsu_pagesize)
            )
        );
    }
    test_field_xsu_pagesize();
    fn test_field_xsu_encrypted() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<xsw_usage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xsu_encrypted) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(xsw_usage),
                "::",
                stringify!(xsu_encrypted)
            )
        );
    }
    test_field_xsu_encrypted();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct loadavg {
    pub ldavg: [fixpt_t; 3usize],
    pub fscale: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_loadavg() {
    assert_eq!(
        ::std::mem::size_of::<loadavg>(),
        24usize,
        concat!("Size of: ", stringify!(loadavg))
    );
    assert_eq!(
        ::std::mem::align_of::<loadavg>(),
        8usize,
        concat!("Alignment of ", stringify!(loadavg))
    );
    fn test_field_ldavg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<loadavg>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ldavg) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(loadavg),
                "::",
                stringify!(ldavg)
            )
        );
    }
    test_field_ldavg();
    fn test_field_fscale() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<loadavg>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fscale) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(loadavg),
                "::",
                stringify!(fscale)
            )
        );
    }
    test_field_fscale();
}
extern "C" {
    pub static mut averunnable: loadavg;
}
extern "C" {
    pub fn sysctl(
        arg1: *mut ::std::os::raw::c_int,
        arg2: u_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut size_t,
        arg5: *mut ::std::os::raw::c_void,
        arg6: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sysctlbyname(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut size_t,
        arg4: *mut ::std::os::raw::c_void,
        arg5: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sysctlnametomib(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct user {}
#[test]
fn bindgen_test_layout_user() {
    assert_eq!(
        ::std::mem::size_of::<user>(),
        0usize,
        concat!("Size of: ", stringify!(user))
    );
    assert_eq!(
        ::std::mem::align_of::<user>(),
        1usize,
        concat!("Alignment of ", stringify!(user))
    );
}
pub type regoff_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct regex_t {
    pub re_magic: ::std::os::raw::c_int,
    pub re_nsub: size_t,
    pub re_endp: *const ::std::os::raw::c_char,
    pub re_g: *mut re_guts,
}
#[test]
fn bindgen_test_layout_regex_t() {
    assert_eq!(
        ::std::mem::size_of::<regex_t>(),
        32usize,
        concat!("Size of: ", stringify!(regex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<regex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(regex_t))
    );
    fn test_field_re_magic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<regex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).re_magic) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(regex_t),
                "::",
                stringify!(re_magic)
            )
        );
    }
    test_field_re_magic();
    fn test_field_re_nsub() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<regex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).re_nsub) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(regex_t),
                "::",
                stringify!(re_nsub)
            )
        );
    }
    test_field_re_nsub();
    fn test_field_re_endp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<regex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).re_endp) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(regex_t),
                "::",
                stringify!(re_endp)
            )
        );
    }
    test_field_re_endp();
    fn test_field_re_g() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<regex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).re_g) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(regex_t),
                "::",
                stringify!(re_g)
            )
        );
    }
    test_field_re_g();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct regmatch_t {
    pub rm_so: regoff_t,
    pub rm_eo: regoff_t,
}
#[test]
fn bindgen_test_layout_regmatch_t() {
    assert_eq!(
        ::std::mem::size_of::<regmatch_t>(),
        16usize,
        concat!("Size of: ", stringify!(regmatch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<regmatch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(regmatch_t))
    );
    fn test_field_rm_so() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<regmatch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rm_so) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(regmatch_t),
                "::",
                stringify!(rm_so)
            )
        );
    }
    test_field_rm_so();
    fn test_field_rm_eo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<regmatch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rm_eo) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(regmatch_t),
                "::",
                stringify!(rm_eo)
            )
        );
    }
    test_field_rm_eo();
}
extern "C" {
    pub fn regcomp(
        arg1: *mut regex_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn regerror(
        arg1: ::std::os::raw::c_int,
        arg2: *const regex_t,
        arg3: *mut ::std::os::raw::c_char,
        arg4: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn regexec(
        arg1: *const regex_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
        __pmatch: *mut regmatch_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn regfree(arg1: *mut regex_t);
}
extern "C" {
    pub fn regncomp(
        arg1: *mut regex_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn regnexec(
        arg1: *const regex_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: size_t,
        __pmatch: *mut regmatch_t,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn regwcomp(
        arg1: *mut regex_t,
        arg2: *const wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn regwexec(
        arg1: *const regex_t,
        arg2: *const wchar_t,
        arg3: size_t,
        __pmatch: *mut regmatch_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn regwncomp(
        arg1: *mut regex_t,
        arg2: *const wchar_t,
        arg3: size_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn regwnexec(
        arg1: *const regex_t,
        arg2: *const wchar_t,
        arg3: size_t,
        arg4: size_t,
        __pmatch: *mut regmatch_t,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct option {
    pub name: *const ::std::os::raw::c_char,
    pub has_arg: ::std::os::raw::c_int,
    pub flag: *mut ::std::os::raw::c_int,
    pub val: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_option() {
    assert_eq!(
        ::std::mem::size_of::<option>(),
        32usize,
        concat!("Size of: ", stringify!(option))
    );
    assert_eq!(
        ::std::mem::align_of::<option>(),
        8usize,
        concat!("Alignment of ", stringify!(option))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<option>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(option),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_has_arg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<option>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_arg) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(option),
                "::",
                stringify!(has_arg)
            )
        );
    }
    test_field_has_arg();
    fn test_field_flag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<option>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flag) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(option),
                "::",
                stringify!(flag)
            )
        );
    }
    test_field_flag();
    fn test_field_val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<option>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(option),
                "::",
                stringify!(val)
            )
        );
    }
    test_field_val();
}
extern "C" {
    pub fn getopt_long(
        arg1: ::std::os::raw::c_int,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const option,
        arg5: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt_long_only(
        arg1: ::std::os::raw::c_int,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const option,
        arg5: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " List of CPUs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_cpuset {
    pub str_: [::std::os::raw::c_char; 257usize],
    pub cpus: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_spdk_cpuset() {
    assert_eq!(
        ::std::mem::size_of::<spdk_cpuset>(),
        385usize,
        concat!("Size of: ", stringify!(spdk_cpuset))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_cpuset>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_cpuset))
    );
    fn test_field_str() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_cpuset>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_cpuset),
                "::",
                stringify!(str_)
            )
        );
    }
    test_field_str();
    fn test_field_cpus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_cpuset>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cpus) as usize - ptr as usize
            },
            257usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_cpuset),
                "::",
                stringify!(cpus)
            )
        );
    }
    test_field_cpus();
}
extern "C" {
    #[doc = " Allocate CPU set object."]
    #[doc = ""]
    #[doc = " \\return a pointer to the allocated zeroed cpuset on success, or NULL on failure."]
    pub fn spdk_cpuset_alloc() -> *mut spdk_cpuset;
}
extern "C" {
    #[doc = " Free allocated CPU set."]
    #[doc = ""]
    #[doc = " \\param set CPU set to be freed."]
    pub fn spdk_cpuset_free(set: *mut spdk_cpuset);
}
extern "C" {
    #[doc = " Compare two CPU sets."]
    #[doc = ""]
    #[doc = " \\param set1 CPU set1."]
    #[doc = " \\param set2 CPU set2."]
    #[doc = ""]
    #[doc = " \\return true if both CPU sets are equal."]
    pub fn spdk_cpuset_equal(set1: *const spdk_cpuset, set2: *const spdk_cpuset) -> bool;
}
extern "C" {
    #[doc = " Copy the content of CPU set to another."]
    #[doc = ""]
    #[doc = " \\param dst Destination CPU set"]
    #[doc = " \\param src Source CPU set"]
    pub fn spdk_cpuset_copy(dst: *mut spdk_cpuset, src: *const spdk_cpuset);
}
extern "C" {
    #[doc = " Perform AND operation on two CPU sets. The result is stored in dst."]
    #[doc = ""]
    #[doc = " \\param dst First argument of operation. This value also stores the result of operation."]
    #[doc = " \\param src Second argument of operation."]
    pub fn spdk_cpuset_and(dst: *mut spdk_cpuset, src: *const spdk_cpuset);
}
extern "C" {
    #[doc = " Perform OR operation on two CPU sets. The result is stored in dst."]
    #[doc = ""]
    #[doc = " \\param dst First argument of operation. This value also stores the result of operation."]
    #[doc = " \\param src Second argument of operation."]
    pub fn spdk_cpuset_or(dst: *mut spdk_cpuset, src: *const spdk_cpuset);
}
extern "C" {
    #[doc = " Perform XOR operation on two CPU sets. The result is stored in dst."]
    #[doc = ""]
    #[doc = " \\param dst First argument of operation. This value also stores the result of operation."]
    #[doc = " \\param src Second argument of operation."]
    pub fn spdk_cpuset_xor(dst: *mut spdk_cpuset, src: *const spdk_cpuset);
}
extern "C" {
    #[doc = " Negate all CPUs in CPU set."]
    #[doc = ""]
    #[doc = " \\param set CPU set to be negated. This value also stores the result of operation."]
    pub fn spdk_cpuset_negate(set: *mut spdk_cpuset);
}
extern "C" {
    #[doc = " Clear all CPUs in CPU set."]
    #[doc = ""]
    #[doc = " \\param set CPU set to be cleared."]
    pub fn spdk_cpuset_zero(set: *mut spdk_cpuset);
}
extern "C" {
    #[doc = " Set or clear CPU state in CPU set."]
    #[doc = ""]
    #[doc = " \\param set CPU set object."]
    #[doc = " \\param cpu CPU index to be set or cleared."]
    #[doc = " \\param state *true* to set cpu, *false* to clear."]
    pub fn spdk_cpuset_set_cpu(set: *mut spdk_cpuset, cpu: u32, state: bool);
}
extern "C" {
    #[doc = " Get the state of CPU in CPU set."]
    #[doc = ""]
    #[doc = " \\param set CPU set object."]
    #[doc = " \\param cpu CPU index."]
    #[doc = ""]
    #[doc = " \\return the state of selected CPU."]
    pub fn spdk_cpuset_get_cpu(set: *const spdk_cpuset, cpu: u32) -> bool;
}
extern "C" {
    #[doc = " Get the number of CPUs that are set in CPU set."]
    #[doc = ""]
    #[doc = " \\param set CPU set object."]
    #[doc = ""]
    #[doc = " \\return the number of CPUs."]
    pub fn spdk_cpuset_count(set: *const spdk_cpuset) -> u32;
}
extern "C" {
    #[doc = " Convert a CPU set to hex string."]
    #[doc = ""]
    #[doc = " \\param set CPU set."]
    #[doc = ""]
    #[doc = " \\return a pointer to hexadecimal representation of CPU set. Buffer to store a"]
    #[doc = " string is dynamically allocated internally and freed with CPU set object."]
    #[doc = " Memory returned by this function might be changed after subsequent calls to"]
    #[doc = " this function so string should be copied by user."]
    pub fn spdk_cpuset_fmt(set: *mut spdk_cpuset) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert a string containing a CPU core mask into a CPU set."]
    #[doc = ""]
    #[doc = " \\param set CPU set."]
    #[doc = " \\param mask String defining CPU set. By default hexadecimal value is used or"]
    #[doc = " as CPU list enclosed in square brackets defined as: 'c1[-c2][,c3[-c4],...]'."]
    #[doc = ""]
    #[doc = " \\return zero if success, non zero if fails."]
    pub fn spdk_cpuset_parse(
        set: *mut spdk_cpuset,
        mask: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " for passing user-provided log call"]
#[doc = ""]
#[doc = " \\param level Log level threshold."]
#[doc = " \\param file Name of the current source file."]
#[doc = " \\param line Current source file line."]
#[doc = " \\param func Current source function name."]
#[doc = " \\param format Format string to the message."]
#[doc = " \\param args Additional arguments for format string."]
pub type logfunc = ::std::option::Option<
    unsafe extern "C" fn(
        level: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        args: va_list,
    ),
>;
extern "C" {
    #[doc = " Initialize the logging module. Messages prior"]
    #[doc = " to this call will be dropped."]
    pub fn spdk_log_open(logf: logfunc);
}
extern "C" {
    #[doc = " Close the currently active log. Messages after this call"]
    #[doc = " will be dropped."]
    pub fn spdk_log_close();
}
extern "C" {
    #[doc = " Enable or disable timestamps"]
    pub fn spdk_log_enable_timestamps(value: bool);
}
#[doc = " All messages will be suppressed."]
pub const spdk_log_level_SPDK_LOG_DISABLED: spdk_log_level = -1;
#[doc = " All messages will be suppressed."]
pub const spdk_log_level_SPDK_LOG_ERROR: spdk_log_level = 0;
#[doc = " All messages will be suppressed."]
pub const spdk_log_level_SPDK_LOG_WARN: spdk_log_level = 1;
#[doc = " All messages will be suppressed."]
pub const spdk_log_level_SPDK_LOG_NOTICE: spdk_log_level = 2;
#[doc = " All messages will be suppressed."]
pub const spdk_log_level_SPDK_LOG_INFO: spdk_log_level = 3;
#[doc = " All messages will be suppressed."]
pub const spdk_log_level_SPDK_LOG_DEBUG: spdk_log_level = 4;
pub type spdk_log_level = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Set the log level threshold to log messages. Messages with a higher"]
    #[doc = " level than this are ignored."]
    #[doc = ""]
    #[doc = " \\param level Log level threshold to set to log messages."]
    pub fn spdk_log_set_level(level: spdk_log_level);
}
extern "C" {
    #[doc = " Get the current log level threshold."]
    #[doc = ""]
    #[doc = " \\return the current log level threshold."]
    pub fn spdk_log_get_level() -> spdk_log_level;
}
extern "C" {
    #[doc = " Set the current log level threshold for printing to stderr."]
    #[doc = " Messages with a level less than or equal to this level"]
    #[doc = " are also printed to stderr. You can use \\c SPDK_LOG_DISABLED to completely"]
    #[doc = " suppress log printing."]
    #[doc = ""]
    #[doc = " \\param level Log level threshold for printing to stderr."]
    pub fn spdk_log_set_print_level(level: spdk_log_level);
}
extern "C" {
    #[doc = " Get the current log level print threshold."]
    #[doc = ""]
    #[doc = " \\return the current log level print threshold."]
    pub fn spdk_log_get_print_level() -> spdk_log_level;
}
extern "C" {
    #[doc = " Write messages to the log file. If \\c level is set to \\c SPDK_LOG_DISABLED,"]
    #[doc = " this log message won't be written."]
    #[doc = ""]
    #[doc = " \\param level Log level threshold."]
    #[doc = " \\param file Name of the current source file."]
    #[doc = " \\param line Current source line number."]
    #[doc = " \\param func Current source function name."]
    #[doc = " \\param format Format string to the message."]
    pub fn spdk_log(
        level: spdk_log_level,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Same as spdk_log except that instead of being called with variable number of"]
    #[doc = " arguments it is called with an argument list as defined in stdarg.h"]
    #[doc = ""]
    #[doc = " \\param level Log level threshold."]
    #[doc = " \\param file Name of the current source file."]
    #[doc = " \\param line Current source line number."]
    #[doc = " \\param func Current source function name."]
    #[doc = " \\param format Format string to the message."]
    #[doc = " \\param ap printf arguments"]
    pub fn spdk_vlog(
        level: spdk_log_level,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
extern "C" {
    #[doc = " Log the contents of a raw buffer to a file."]
    #[doc = ""]
    #[doc = " \\param fp File to hold the log."]
    #[doc = " \\param label Label to print to the file."]
    #[doc = " \\param buf Buffer that holds the log information."]
    #[doc = " \\param len Length of buffer to dump."]
    pub fn spdk_log_dump(
        fp: *mut FILE,
        label: *const ::std::os::raw::c_char,
        buf: *const ::std::os::raw::c_void,
        len: size_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_log_flag {
    pub tailq: spdk_log_flag__bindgen_ty_1,
    pub name: *const ::std::os::raw::c_char,
    pub enabled: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_log_flag__bindgen_ty_1 {
    pub tqe_next: *mut spdk_log_flag,
    pub tqe_prev: *mut *mut spdk_log_flag,
}
#[test]
fn bindgen_test_layout_spdk_log_flag__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_log_flag__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(spdk_log_flag__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_log_flag__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_log_flag__bindgen_ty_1))
    );
    fn test_field_tqe_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_log_flag__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tqe_next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_log_flag__bindgen_ty_1),
                "::",
                stringify!(tqe_next)
            )
        );
    }
    test_field_tqe_next();
    fn test_field_tqe_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_log_flag__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tqe_prev) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_log_flag__bindgen_ty_1),
                "::",
                stringify!(tqe_prev)
            )
        );
    }
    test_field_tqe_prev();
}
#[test]
fn bindgen_test_layout_spdk_log_flag() {
    assert_eq!(
        ::std::mem::size_of::<spdk_log_flag>(),
        32usize,
        concat!("Size of: ", stringify!(spdk_log_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_log_flag>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_log_flag))
    );
    fn test_field_tailq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_log_flag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tailq) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_log_flag),
                "::",
                stringify!(tailq)
            )
        );
    }
    test_field_tailq();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_log_flag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_log_flag),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_enabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_log_flag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_log_flag),
                "::",
                stringify!(enabled)
            )
        );
    }
    test_field_enabled();
}
extern "C" {
    #[doc = " Register a log flag."]
    #[doc = ""]
    #[doc = " \\param name Name of the log flag."]
    #[doc = " \\param flag Log flag to be added."]
    pub fn spdk_log_register_flag(name: *const ::std::os::raw::c_char, flag: *mut spdk_log_flag);
}
extern "C" {
    #[doc = " Get the first registered log flag."]
    #[doc = ""]
    #[doc = " \\return The first registered log flag."]
    pub fn spdk_log_get_first_flag() -> *mut spdk_log_flag;
}
extern "C" {
    #[doc = " Get the next registered log flag."]
    #[doc = ""]
    #[doc = " \\param flag The current log flag."]
    #[doc = ""]
    #[doc = " \\return The next registered log flag."]
    pub fn spdk_log_get_next_flag(flag: *mut spdk_log_flag) -> *mut spdk_log_flag;
}
extern "C" {
    #[doc = " Check whether the log flag exists and is enabled."]
    #[doc = ""]
    #[doc = " \\return true if enabled, or false otherwise."]
    pub fn spdk_log_get_flag(flag: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Enable the log flag."]
    #[doc = ""]
    #[doc = " \\param flag Log flag to be enabled."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on failure."]
    pub fn spdk_log_set_flag(flag: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clear a log flag."]
    #[doc = ""]
    #[doc = " \\param flag Log flag to clear."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on failure."]
    pub fn spdk_log_clear_flag(flag: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Show all the log flags and their usage."]
    #[doc = ""]
    #[doc = " \\param f File to hold all the flags' information."]
    #[doc = " \\param log_arg Command line option to set/enable the log flag."]
    pub fn spdk_log_usage(f: *mut FILE, log_arg: *const ::std::os::raw::c_char);
}
pub const spdk_thread_poller_rc_SPDK_POLLER_IDLE: spdk_thread_poller_rc = 0;
pub const spdk_thread_poller_rc_SPDK_POLLER_BUSY: spdk_thread_poller_rc = 1;
pub type spdk_thread_poller_rc = ::std::os::raw::c_uint;
#[doc = " A stackless, lightweight thread."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_thread {
    _unused: [u8; 0],
}
#[doc = " A function repeatedly called on the same spdk_thread."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_poller {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_io_channel_iter {
    _unused: [u8; 0],
}
#[doc = " A function that is called each time a new thread is created."]
#[doc = " The implementor of this function should frequently call"]
#[doc = " spdk_thread_poll() on the thread provided."]
#[doc = ""]
#[doc = " \\param thread The new spdk_thread."]
pub type spdk_new_thread_fn =
    ::std::option::Option<unsafe extern "C" fn(thread: *mut spdk_thread) -> ::std::os::raw::c_int>;
pub const spdk_thread_op_SPDK_THREAD_OP_NEW: spdk_thread_op = 0;
pub const spdk_thread_op_SPDK_THREAD_OP_RESCHED: spdk_thread_op = 1;
#[doc = " SPDK thread operation type."]
pub type spdk_thread_op = ::std::os::raw::c_uint;
#[doc = " Function to be called for SPDK thread operation."]
pub type spdk_thread_op_fn = ::std::option::Option<
    unsafe extern "C" fn(thread: *mut spdk_thread, op: spdk_thread_op) -> ::std::os::raw::c_int,
>;
#[doc = " Function to check whether the SPDK thread operation is supported."]
pub type spdk_thread_op_supported_fn =
    ::std::option::Option<unsafe extern "C" fn(op: spdk_thread_op) -> bool>;
#[doc = " A function that will be called on the target thread."]
#[doc = ""]
#[doc = " \\param ctx Context passed as arg to spdk_thread_pass_msg()."]
pub type spdk_msg_fn =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>;
#[doc = " Function to be called to pass a message to a thread."]
#[doc = ""]
#[doc = " \\param fn Callback function for a thread."]
#[doc = " \\param ctx Context passed to fn."]
#[doc = " \\param thread_ctx Context for the thread."]
pub type spdk_thread_pass_msg = ::std::option::Option<
    unsafe extern "C" fn(
        fn_: spdk_msg_fn,
        ctx: *mut ::std::os::raw::c_void,
        thread_ctx: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Callback function for a poller."]
#[doc = ""]
#[doc = " \\param ctx Context passed as arg to spdk_poller_register()."]
#[doc = " \\return 0 to indicate that polling took place but no events were found;"]
#[doc = " positive to indicate that polling took place and some events were processed;"]
#[doc = " negative if the poller does not provide spin-wait information."]
pub type spdk_poller_fn = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " Function to be called to start a poller for the thread."]
#[doc = ""]
#[doc = " \\param thread_ctx Context for the thread."]
#[doc = " \\param fn Callback function for a poller."]
#[doc = " \\param arg Argument passed to callback."]
#[doc = " \\param period_microseconds Polling period in microseconds."]
#[doc = ""]
#[doc = " \\return a pointer to the poller on success, or NULL on failure."]
pub type spdk_start_poller = ::std::option::Option<
    unsafe extern "C" fn(
        thread_ctx: *mut ::std::os::raw::c_void,
        fn_: spdk_poller_fn,
        arg: *mut ::std::os::raw::c_void,
        period_microseconds: u64,
    ) -> *mut spdk_poller,
>;
#[doc = " Function to be called to stop a poller."]
#[doc = ""]
#[doc = " \\param poller Poller to stop."]
#[doc = " \\param thread_ctx Context for the thread."]
pub type spdk_stop_poller = ::std::option::Option<
    unsafe extern "C" fn(poller: *mut spdk_poller, thread_ctx: *mut ::std::os::raw::c_void),
>;
#[doc = " Callback function to set poller into interrupt mode or back to poll mode."]
#[doc = ""]
#[doc = " \\param poller Poller to set interrupt or poll mode."]
#[doc = " \\param cb_arg Argument passed to the callback function."]
#[doc = " \\param interrupt_mode Set interrupt mode for true, or poll mode for false"]
pub type spdk_poller_set_interrupt_mode_cb = ::std::option::Option<
    unsafe extern "C" fn(
        poller: *mut spdk_poller,
        cb_arg: *mut ::std::os::raw::c_void,
        interrupt_mode: bool,
    ),
>;
extern "C" {
    #[doc = " Mark that the poller is capable of entering interrupt mode."]
    #[doc = ""]
    #[doc = " When registering the poller set interrupt callback, the callback will get"]
    #[doc = " executed immediately if its spdk_thread is in the interrupt mode."]
    #[doc = ""]
    #[doc = " \\param poller The poller to register callback function."]
    #[doc = " \\param cb_fn Callback function called when the poller must transition into or out of interrupt mode"]
    #[doc = " \\param cb_arg Argument passed to the callback function."]
    pub fn spdk_poller_register_interrupt(
        poller: *mut spdk_poller,
        cb_fn: spdk_poller_set_interrupt_mode_cb,
        cb_arg: *mut ::std::os::raw::c_void,
    );
}
#[doc = " I/O channel creation callback."]
#[doc = ""]
#[doc = " \\param io_device I/O device associated with this channel."]
#[doc = " \\param ctx_buf Context for the I/O device."]
pub type spdk_io_channel_create_cb = ::std::option::Option<
    unsafe extern "C" fn(
        io_device: *mut ::std::os::raw::c_void,
        ctx_buf: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " I/O channel destruction callback."]
#[doc = ""]
#[doc = " \\param io_device I/O device associated with this channel."]
#[doc = " \\param ctx_buf Context for the I/O device."]
pub type spdk_io_channel_destroy_cb = ::std::option::Option<
    unsafe extern "C" fn(
        io_device: *mut ::std::os::raw::c_void,
        ctx_buf: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " I/O device unregister callback."]
#[doc = ""]
#[doc = " \\param io_device Unregistered I/O device."]
pub type spdk_io_device_unregister_cb =
    ::std::option::Option<unsafe extern "C" fn(io_device: *mut ::std::os::raw::c_void)>;
#[doc = " Called on the appropriate thread for each channel associated with io_device."]
#[doc = ""]
#[doc = " \\param i I/O channel iterator."]
pub type spdk_channel_msg =
    ::std::option::Option<unsafe extern "C" fn(i: *mut spdk_io_channel_iter)>;
#[doc = " spdk_for_each_channel() callback."]
#[doc = ""]
#[doc = " \\param i I/O channel iterator."]
#[doc = " \\param status 0 if it completed successfully, or negative errno if it failed."]
pub type spdk_channel_for_each_cpl = ::std::option::Option<
    unsafe extern "C" fn(i: *mut spdk_io_channel_iter, status: ::std::os::raw::c_int),
>;
#[doc = " \\brief Represents a per-thread channel for accessing an I/O device."]
#[doc = ""]
#[doc = " An I/O device may be a physical entity (i.e. NVMe controller) or a software"]
#[doc = "  entity (i.e. a blobstore)."]
#[doc = ""]
#[doc = " This structure is not part of the API - all accesses should be done through"]
#[doc = "  spdk_io_channel function calls."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_io_channel {
    pub thread: *mut spdk_thread,
    pub dev: *mut io_device,
    pub ref_: u32,
    pub destroy_ref: u32,
    pub tailq: spdk_io_channel__bindgen_ty_1,
    pub destroy_cb: spdk_io_channel_destroy_cb,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_io_channel__bindgen_ty_1 {
    pub tqe_next: *mut spdk_io_channel,
    pub tqe_prev: *mut *mut spdk_io_channel,
}
#[test]
fn bindgen_test_layout_spdk_io_channel__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_io_channel__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(spdk_io_channel__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_io_channel__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_io_channel__bindgen_ty_1))
    );
    fn test_field_tqe_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_io_channel__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tqe_next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_io_channel__bindgen_ty_1),
                "::",
                stringify!(tqe_next)
            )
        );
    }
    test_field_tqe_next();
    fn test_field_tqe_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_io_channel__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tqe_prev) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_io_channel__bindgen_ty_1),
                "::",
                stringify!(tqe_prev)
            )
        );
    }
    test_field_tqe_prev();
}
#[test]
fn bindgen_test_layout_spdk_io_channel() {
    assert_eq!(
        ::std::mem::size_of::<spdk_io_channel>(),
        48usize,
        concat!("Size of: ", stringify!(spdk_io_channel))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_io_channel>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_io_channel))
    );
    fn test_field_thread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_io_channel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thread) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_io_channel),
                "::",
                stringify!(thread)
            )
        );
    }
    test_field_thread();
    fn test_field_dev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_io_channel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dev) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_io_channel),
                "::",
                stringify!(dev)
            )
        );
    }
    test_field_dev();
    fn test_field_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_io_channel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_io_channel),
                "::",
                stringify!(ref_)
            )
        );
    }
    test_field_ref();
    fn test_field_destroy_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_io_channel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).destroy_ref) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_io_channel),
                "::",
                stringify!(destroy_ref)
            )
        );
    }
    test_field_destroy_ref();
    fn test_field_tailq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_io_channel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tailq) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_io_channel),
                "::",
                stringify!(tailq)
            )
        );
    }
    test_field_tailq();
    fn test_field_destroy_cb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_io_channel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).destroy_cb) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_io_channel),
                "::",
                stringify!(destroy_cb)
            )
        );
    }
    test_field_destroy_cb();
}
extern "C" {
    #[doc = " Initialize the threading library. Must be called once prior to allocating any threads."]
    #[doc = ""]
    #[doc = " \\param new_thread_fn Called each time a new SPDK thread is created. The implementor"]
    #[doc = " is expected to frequently call spdk_thread_poll() on the provided thread."]
    #[doc = " \\param ctx_sz For each thread allocated, an additional region of memory of"]
    #[doc = " size ctx_size will also be allocated, for use by the thread scheduler. A pointer"]
    #[doc = " to this region may be obtained by calling spdk_thread_get_ctx()."]
    #[doc = ""]
    #[doc = " \\return 0 on success. Negated errno on failure."]
    pub fn spdk_thread_lib_init(
        new_thread_fn: spdk_new_thread_fn,
        ctx_sz: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize the threading library. Must be called once prior to allocating any threads"]
    #[doc = ""]
    #[doc = " Both thread_op_fn and thread_op_type_supported_fn have to be specified or not"]
    #[doc = " specified together."]
    #[doc = ""]
    #[doc = " \\param thread_op_fn Called for SPDK thread operation."]
    #[doc = " \\param thread_op_supported_fn Called to check whether the SPDK thread operation is supported."]
    #[doc = " \\param ctx_sz For each thread allocated, for use by the thread scheduler. A pointer"]
    #[doc = " to this region may be obtained by calling spdk_thread_get_ctx()."]
    #[doc = ""]
    #[doc = " \\return 0 on success. Negated errno on failure."]
    pub fn spdk_thread_lib_init_ext(
        thread_op_fn: spdk_thread_op_fn,
        thread_op_supported_fn: spdk_thread_op_supported_fn,
        ctx_sz: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release all resources associated with this library."]
    pub fn spdk_thread_lib_fini();
}
extern "C" {
    #[doc = " Creates a new SPDK thread object."]
    #[doc = ""]
    #[doc = " \\param name Human-readable name for the thread; can be retrieved with spdk_thread_get_name()."]
    #[doc = " The string is copied, so the pointed-to data only needs to be valid during the"]
    #[doc = " spdk_thread_create() call. May be NULL to specify no name."]
    #[doc = " \\param cpumask Optional mask of CPU cores on which to schedule this thread. This is only"]
    #[doc = " a suggestion to the scheduler. The value is copied, so cpumask may be released when"]
    #[doc = " this function returns. May be NULL if no mask is required."]
    #[doc = ""]
    #[doc = " \\return a pointer to the allocated thread on success or NULL on failure.."]
    pub fn spdk_thread_create(
        name: *const ::std::os::raw::c_char,
        cpumask: *mut spdk_cpuset,
    ) -> *mut spdk_thread;
}
extern "C" {
    #[doc = " Force the current system thread to act as if executing the given SPDK thread."]
    #[doc = ""]
    #[doc = " \\param thread The thread to set."]
    pub fn spdk_set_thread(thread: *mut spdk_thread);
}
extern "C" {
    #[doc = " Mark the thread as exited, failing all future spdk_thread_send_msg(),"]
    #[doc = " spdk_poller_register(), and spdk_get_io_channel() calls. May only be called"]
    #[doc = " within an spdk poller or message."]
    #[doc = ""]
    #[doc = " All I/O channel references associated with the thread must be released"]
    #[doc = " using spdk_put_io_channel(), and all active pollers associated with the thread"]
    #[doc = " should be unregistered using spdk_poller_unregister(), prior to calling"]
    #[doc = " this function. This function will complete these processing. The completion can"]
    #[doc = " be queried by spdk_thread_is_exited()."]
    #[doc = ""]
    #[doc = " \\param thread The thread to destroy."]
    #[doc = ""]
    #[doc = " \\return always 0. (return value was deprecated but keep it for ABI compatibility.)"]
    pub fn spdk_thread_exit(thread: *mut spdk_thread) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns whether the thread is marked as exited."]
    #[doc = ""]
    #[doc = " \\param thread The thread to query."]
    #[doc = ""]
    #[doc = " \\return true if marked as exited, false otherwise."]
    pub fn spdk_thread_is_exited(thread: *mut spdk_thread) -> bool;
}
extern "C" {
    #[doc = " Destroy a thread, releasing all of its resources. May only be called"]
    #[doc = " on a thread previously marked as exited."]
    #[doc = ""]
    #[doc = " \\param thread The thread to destroy."]
    #[doc = ""]
    pub fn spdk_thread_destroy(thread: *mut spdk_thread);
}
extern "C" {
    #[doc = " Return a pointer to this thread's context."]
    #[doc = ""]
    #[doc = " \\param thread The thread on which to get the context."]
    #[doc = ""]
    #[doc = " \\return a pointer to the per-thread context, or NULL if there is"]
    #[doc = " no per-thread context."]
    pub fn spdk_thread_get_ctx(thread: *mut spdk_thread) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get the thread's cpumask."]
    #[doc = ""]
    #[doc = " \\param thread The thread to get the cpumask for."]
    #[doc = ""]
    #[doc = " \\return cpuset pointer"]
    pub fn spdk_thread_get_cpumask(thread: *mut spdk_thread) -> *mut spdk_cpuset;
}
extern "C" {
    #[doc = " Set the current thread's cpumask to the specified value. The thread may be"]
    #[doc = " rescheduled to one of the CPUs specified in the cpumask."]
    #[doc = ""]
    #[doc = " This API requires SPDK thread operation supports SPDK_THREAD_OP_RESCHED."]
    #[doc = ""]
    #[doc = " \\param cpumask The new cpumask for the thread."]
    #[doc = ""]
    #[doc = " \\return 0 on success, negated errno otherwise."]
    pub fn spdk_thread_set_cpumask(cpumask: *mut spdk_cpuset) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the thread object associated with the context handle previously"]
    #[doc = " obtained by calling spdk_thread_get_ctx()."]
    #[doc = ""]
    #[doc = " \\param ctx A context previously obtained by calling spdk_thread_get_ctx()"]
    #[doc = ""]
    #[doc = " \\return The associated thread."]
    pub fn spdk_thread_get_from_ctx(ctx: *mut ::std::os::raw::c_void) -> *mut spdk_thread;
}
extern "C" {
    #[doc = " Perform one iteration worth of processing on the thread. This includes"]
    #[doc = " both expired and continuous pollers as well as messages. If the thread"]
    #[doc = " has exited, return immediately."]
    #[doc = ""]
    #[doc = " \\param thread The thread to process"]
    #[doc = " \\param max_msgs The maximum number of messages that will be processed."]
    #[doc = "                 Use 0 to process the default number of messages (8)."]
    #[doc = " \\param now The current time, in ticks. Optional. If 0 is passed, this"]
    #[doc = "            function will call spdk_get_ticks() to get the current time."]
    #[doc = "            The current time is used as start time and this function"]
    #[doc = "            will call spdk_get_ticks() at its end to know end time to"]
    #[doc = "            measure run time of this function."]
    #[doc = ""]
    #[doc = " \\return 1 if work was done. 0 if no work was done."]
    pub fn spdk_thread_poll(
        thread: *mut spdk_thread,
        max_msgs: u32,
        now: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the number of ticks until the next timed poller"]
    #[doc = " would expire. Timed pollers are pollers for which"]
    #[doc = " period_microseconds is greater than 0."]
    #[doc = ""]
    #[doc = " \\param thread The thread to check poller expiration times on"]
    #[doc = ""]
    #[doc = " \\return Number of ticks. If no timed pollers, return 0."]
    pub fn spdk_thread_next_poller_expiration(thread: *mut spdk_thread) -> u64;
}
extern "C" {
    #[doc = " Returns whether there are any active pollers (pollers for which"]
    #[doc = " period_microseconds equals 0) registered to be run on the thread."]
    #[doc = ""]
    #[doc = " \\param thread The thread to check."]
    #[doc = ""]
    #[doc = " \\return 1 if there is at least one active poller, 0 otherwise."]
    pub fn spdk_thread_has_active_pollers(thread: *mut spdk_thread) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns whether there are any pollers registered to be run"]
    #[doc = " on the thread."]
    #[doc = ""]
    #[doc = " \\param thread The thread to check."]
    #[doc = ""]
    #[doc = " \\return true if there is any active poller, false otherwise."]
    pub fn spdk_thread_has_pollers(thread: *mut spdk_thread) -> bool;
}
extern "C" {
    #[doc = " Returns whether there are scheduled operations to be run on the thread."]
    #[doc = ""]
    #[doc = " \\param thread The thread to check."]
    #[doc = ""]
    #[doc = " \\return true if there are no scheduled operations, false otherwise."]
    pub fn spdk_thread_is_idle(thread: *mut spdk_thread) -> bool;
}
extern "C" {
    #[doc = " Get count of allocated threads."]
    pub fn spdk_thread_get_count() -> u32;
}
extern "C" {
    #[doc = " Get a handle to the current thread."]
    #[doc = ""]
    #[doc = " This handle may be passed to other threads and used as the target of"]
    #[doc = " spdk_thread_send_msg()."]
    #[doc = ""]
    #[doc = " \\sa spdk_io_channel_get_thread()"]
    #[doc = ""]
    #[doc = " \\return a pointer to the current thread on success or NULL on failure."]
    pub fn spdk_get_thread() -> *mut spdk_thread;
}
extern "C" {
    #[doc = " Get a thread's name."]
    #[doc = ""]
    #[doc = " \\param thread Thread to query."]
    #[doc = ""]
    #[doc = " \\return the name of the thread."]
    pub fn spdk_thread_get_name(thread: *const spdk_thread) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get a thread's ID."]
    #[doc = ""]
    #[doc = " \\param thread Thread to query."]
    #[doc = ""]
    #[doc = " \\return the ID of the thread.."]
    pub fn spdk_thread_get_id(thread: *const spdk_thread) -> u64;
}
extern "C" {
    #[doc = " Get the thread by the ID."]
    #[doc = ""]
    #[doc = " \\param id ID of the thread."]
    #[doc = " \\return Thread whose ID matches or NULL otherwise."]
    pub fn spdk_thread_get_by_id(id: u64) -> *mut spdk_thread;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_thread_stats {
    pub busy_tsc: u64,
    pub idle_tsc: u64,
}
#[test]
fn bindgen_test_layout_spdk_thread_stats() {
    assert_eq!(
        ::std::mem::size_of::<spdk_thread_stats>(),
        16usize,
        concat!("Size of: ", stringify!(spdk_thread_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_thread_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_thread_stats))
    );
    fn test_field_busy_tsc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_thread_stats>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).busy_tsc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_thread_stats),
                "::",
                stringify!(busy_tsc)
            )
        );
    }
    test_field_busy_tsc();
    fn test_field_idle_tsc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_thread_stats>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).idle_tsc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_thread_stats),
                "::",
                stringify!(idle_tsc)
            )
        );
    }
    test_field_idle_tsc();
}
extern "C" {
    #[doc = " Get statistics about the current thread."]
    #[doc = ""]
    #[doc = " Copy cumulative thread stats values to the provided thread stats structure."]
    #[doc = ""]
    #[doc = " \\param stats User's thread_stats structure."]
    pub fn spdk_thread_get_stats(stats: *mut spdk_thread_stats) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the TSC value from the end of the last time this thread was polled."]
    #[doc = ""]
    #[doc = " \\param thread Thread to query."]
    #[doc = ""]
    #[doc = " \\return TSC value from the end of the last time this thread was polled."]
    pub fn spdk_thread_get_last_tsc(thread: *mut spdk_thread) -> u64;
}
extern "C" {
    #[doc = " Send a message to the given thread."]
    #[doc = ""]
    #[doc = " The message will be sent asynchronously - i.e. spdk_thread_send_msg will always return"]
    #[doc = " prior to `fn` being called."]
    #[doc = ""]
    #[doc = " \\param thread The target thread."]
    #[doc = " \\param fn This function will be called on the given thread."]
    #[doc = " \\param ctx This context will be passed to fn when called."]
    #[doc = ""]
    #[doc = " \\return 0 on success"]
    #[doc = " \\return -ENOMEM if the message could not be allocated"]
    #[doc = " \\return -EIO if the message could not be sent to the destination thread"]
    pub fn spdk_thread_send_msg(
        thread: *const spdk_thread,
        fn_: spdk_msg_fn,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a message to the given thread. Only one critical message can be outstanding at the same"]
    #[doc = " time. It's intended to use this function in any cases that might interrupt the execution of the"]
    #[doc = " application, such as signal handlers."]
    #[doc = ""]
    #[doc = " The message will be sent asynchronously - i.e. spdk_thread_send_critical_msg will always return"]
    #[doc = " prior to `fn` being called."]
    #[doc = ""]
    #[doc = " \\param thread The target thread."]
    #[doc = " \\param fn This function will be called on the given thread."]
    #[doc = ""]
    #[doc = " \\return 0 on success"]
    #[doc = " \\return -EIO if the message could not be sent to the destination thread, due to an already"]
    #[doc = " outstanding critical message"]
    pub fn spdk_thread_send_critical_msg(
        thread: *mut spdk_thread,
        fn_: spdk_msg_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a message to each thread, serially."]
    #[doc = ""]
    #[doc = " The message is sent asynchronously - i.e. spdk_for_each_thread will return"]
    #[doc = " prior to `fn` being called on each thread."]
    #[doc = ""]
    #[doc = " \\param fn This is the function that will be called on each thread."]
    #[doc = " \\param ctx This context will be passed to fn when called."]
    #[doc = " \\param cpl This will be called on the originating thread after `fn` has been"]
    #[doc = " called on each thread."]
    pub fn spdk_for_each_thread(
        fn_: spdk_msg_fn,
        ctx: *mut ::std::os::raw::c_void,
        cpl: spdk_msg_fn,
    );
}
extern "C" {
    #[doc = " Set current spdk_thread into interrupt mode or back to poll mode."]
    #[doc = ""]
    #[doc = " Only valid when thread interrupt facility is enabled by"]
    #[doc = " spdk_interrupt_mode_enable()."]
    #[doc = ""]
    #[doc = " \\param enable_interrupt Set interrupt mode for true, or poll mode for false"]
    pub fn spdk_thread_set_interrupt_mode(enable_interrupt: bool);
}
extern "C" {
    #[doc = " Register a poller on the current thread."]
    #[doc = ""]
    #[doc = " The poller can be unregistered by calling spdk_poller_unregister()."]
    #[doc = ""]
    #[doc = " \\param fn This function will be called every `period_microseconds`."]
    #[doc = " \\param arg Argument passed to fn."]
    #[doc = " \\param period_microseconds How often to call `fn`. If 0, call `fn` as often"]
    #[doc = "  as possible."]
    #[doc = ""]
    #[doc = " \\return a pointer to the poller registered on the current thread on success"]
    #[doc = " or NULL on failure."]
    pub fn spdk_poller_register(
        fn_: spdk_poller_fn,
        arg: *mut ::std::os::raw::c_void,
        period_microseconds: u64,
    ) -> *mut spdk_poller;
}
extern "C" {
    #[doc = " Register a poller on the current thread with arbitrary name."]
    #[doc = ""]
    #[doc = " The poller can be unregistered by calling spdk_poller_unregister()."]
    #[doc = ""]
    #[doc = " \\param fn This function will be called every `period_microseconds`."]
    #[doc = " \\param arg Argument passed to fn."]
    #[doc = " \\param period_microseconds How often to call `fn`. If 0, call `fn` as often"]
    #[doc = "  as possible."]
    #[doc = " \\param name Human readable name for the poller. Pointer of the poller function"]
    #[doc = " name is set if NULL."]
    #[doc = ""]
    #[doc = " \\return a pointer to the poller registered on the current thread on success"]
    #[doc = " or NULL on failure."]
    pub fn spdk_poller_register_named(
        fn_: spdk_poller_fn,
        arg: *mut ::std::os::raw::c_void,
        period_microseconds: u64,
        name: *const ::std::os::raw::c_char,
    ) -> *mut spdk_poller;
}
extern "C" {
    #[doc = " Unregister a poller on the current thread."]
    #[doc = ""]
    #[doc = " \\param ppoller The poller to unregister."]
    pub fn spdk_poller_unregister(ppoller: *mut *mut spdk_poller);
}
extern "C" {
    #[doc = " Pause a poller on the current thread."]
    #[doc = ""]
    #[doc = " The poller is not run until it is resumed with spdk_poller_resume().  It is"]
    #[doc = " perfectly fine to pause an already paused poller."]
    #[doc = ""]
    #[doc = " \\param poller The poller to pause."]
    pub fn spdk_poller_pause(poller: *mut spdk_poller);
}
extern "C" {
    #[doc = " Resume a poller on the current thread."]
    #[doc = ""]
    #[doc = " Resumes a poller paused with spdk_poller_pause().  It is perfectly fine to"]
    #[doc = " resume an unpaused poller."]
    #[doc = ""]
    #[doc = " \\param poller The poller to resume."]
    pub fn spdk_poller_resume(poller: *mut spdk_poller);
}
extern "C" {
    #[doc = " Register the opaque io_device context as an I/O device."]
    #[doc = ""]
    #[doc = " After an I/O device is registered, it can return I/O channels using the"]
    #[doc = " spdk_get_io_channel() function."]
    #[doc = ""]
    #[doc = " \\param io_device The pointer to io_device context."]
    #[doc = " \\param create_cb Callback function invoked to allocate any resources required"]
    #[doc = " for a new I/O channel."]
    #[doc = " \\param destroy_cb Callback function invoked to release the resources for an"]
    #[doc = " I/O channel."]
    #[doc = " \\param ctx_size The size of the context buffer allocated to store references"]
    #[doc = " to allocated I/O channel resources."]
    #[doc = " \\param name A string name for the device used only for debugging. Optional -"]
    #[doc = " may be NULL."]
    pub fn spdk_io_device_register(
        io_device: *mut ::std::os::raw::c_void,
        create_cb: spdk_io_channel_create_cb,
        destroy_cb: spdk_io_channel_destroy_cb,
        ctx_size: u32,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Unregister the opaque io_device context as an I/O device."]
    #[doc = ""]
    #[doc = " The actual unregistration might be deferred until all active I/O channels are"]
    #[doc = " destroyed."]
    #[doc = ""]
    #[doc = " \\param io_device The pointer to io_device context."]
    #[doc = " \\param unregister_cb An optional callback function invoked to release any"]
    #[doc = " references to this I/O device."]
    pub fn spdk_io_device_unregister(
        io_device: *mut ::std::os::raw::c_void,
        unregister_cb: spdk_io_device_unregister_cb,
    );
}
extern "C" {
    #[doc = " Get an I/O channel for the specified io_device to be used by the calling thread."]
    #[doc = ""]
    #[doc = " The io_device context pointer specified must have previously been registered"]
    #[doc = " using spdk_io_device_register(). If an existing I/O channel does not exist"]
    #[doc = " yet for the given io_device on the calling thread, it will allocate an I/O"]
    #[doc = " channel and invoke the create_cb function pointer specified in spdk_io_device_register()."]
    #[doc = " If an I/O channel already exists for the given io_device on the calling thread,"]
    #[doc = " its reference is returned rather than creating a new I/O channel."]
    #[doc = ""]
    #[doc = " \\param io_device The pointer to io_device context."]
    #[doc = ""]
    #[doc = " \\return a pointer to the I/O channel for this device on success or NULL on failure."]
    pub fn spdk_get_io_channel(io_device: *mut ::std::os::raw::c_void) -> *mut spdk_io_channel;
}
extern "C" {
    #[doc = " Release a reference to an I/O channel. This happens asynchronously."]
    #[doc = ""]
    #[doc = " This must be called on the same thread that called spdk_get_io_channel()"]
    #[doc = " for the specified I/O channel. If this releases the last reference to the"]
    #[doc = " I/O channel, The destroy_cb function specified in spdk_io_device_register()"]
    #[doc = " will be invoked to release any associated resources."]
    #[doc = ""]
    #[doc = " \\param ch I/O channel to release a reference."]
    pub fn spdk_put_io_channel(ch: *mut spdk_io_channel);
}
extern "C" {
    #[doc = " Get I/O channel from the context buffer. This is the inverse of"]
    #[doc = " spdk_io_channel_get_ctx()."]
    #[doc = ""]
    #[doc = " \\param ctx The pointer to the context buffer."]
    #[doc = ""]
    #[doc = " \\return a pointer to the I/O channel associated with the context buffer."]
    pub fn spdk_io_channel_from_ctx(ctx: *mut ::std::os::raw::c_void) -> *mut spdk_io_channel;
}
extern "C" {
    #[doc = " Get the thread associated with an I/O channel."]
    #[doc = ""]
    #[doc = " \\param ch I/O channel."]
    #[doc = ""]
    #[doc = " \\return a pointer to the thread associated with the I/O channel"]
    pub fn spdk_io_channel_get_thread(ch: *mut spdk_io_channel) -> *mut spdk_thread;
}
extern "C" {
    #[doc = " Call 'fn' on each channel associated with io_device."]
    #[doc = ""]
    #[doc = " This happens asynchronously, so fn may be called after spdk_for_each_channel"]
    #[doc = " returns. 'fn' will be called for each channel serially, such that two calls"]
    #[doc = " to 'fn' will not overlap in time. After 'fn' has been called, call"]
    #[doc = " spdk_for_each_channel_continue() to continue iterating."]
    #[doc = ""]
    #[doc = " \\param io_device 'fn' will be called on each channel associated with this io_device."]
    #[doc = " \\param fn Called on the appropriate thread for each channel associated with io_device."]
    #[doc = " \\param ctx Context buffer registered to spdk_io_channel_iter that can be obatined"]
    #[doc = " form the function spdk_io_channel_iter_get_ctx()."]
    #[doc = " \\param cpl Called on the thread that spdk_for_each_channel was initially called"]
    #[doc = " from when 'fn' has been called on each channel."]
    pub fn spdk_for_each_channel(
        io_device: *mut ::std::os::raw::c_void,
        fn_: spdk_channel_msg,
        ctx: *mut ::std::os::raw::c_void,
        cpl: spdk_channel_for_each_cpl,
    );
}
extern "C" {
    #[doc = " Get io_device from the I/O channel iterator."]
    #[doc = ""]
    #[doc = " \\param i I/O channel iterator."]
    #[doc = ""]
    #[doc = " \\return a pointer to the io_device."]
    pub fn spdk_io_channel_iter_get_io_device(
        i: *mut spdk_io_channel_iter,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get I/O channel from the I/O channel iterator."]
    #[doc = ""]
    #[doc = " \\param i I/O channel iterator."]
    #[doc = ""]
    #[doc = " \\return a pointer to the I/O channel."]
    pub fn spdk_io_channel_iter_get_channel(i: *mut spdk_io_channel_iter) -> *mut spdk_io_channel;
}
extern "C" {
    #[doc = " Get context buffer from the I/O channel iterator."]
    #[doc = ""]
    #[doc = " \\param i I/O channel iterator."]
    #[doc = ""]
    #[doc = " \\return a pointer to the context buffer."]
    pub fn spdk_io_channel_iter_get_ctx(
        i: *mut spdk_io_channel_iter,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get the io_device for the specified I/O channel."]
    #[doc = ""]
    #[doc = " \\param ch I/O channel."]
    #[doc = ""]
    #[doc = " \\return a pointer to the io_device for the I/O channel"]
    pub fn spdk_io_channel_get_io_device(ch: *mut spdk_io_channel) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Helper function to iterate all channels for spdk_for_each_channel()."]
    #[doc = ""]
    #[doc = " \\param i I/O channel iterator."]
    #[doc = " \\param status Status for the I/O channel iterator."]
    pub fn spdk_for_each_channel_continue(
        i: *mut spdk_io_channel_iter,
        status: ::std::os::raw::c_int,
    );
}
#[doc = " A representative for registered interrupt file descriptor."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_interrupt {
    _unused: [u8; 0],
}
#[doc = " Callback function registered for interrupt file descriptor."]
#[doc = ""]
#[doc = " \\param ctx Context passed as arg to spdk_interrupt_register()."]
#[doc = ""]
#[doc = " \\return 0 to indicate that interrupt took place but no events were found;"]
#[doc = " positive to indicate that interrupt took place and some events were processed;"]
#[doc = " negative if no event information is provided."]
pub type spdk_interrupt_fn = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Register an spdk_interrupt on the current thread. The provided function"]
    #[doc = " will be called any time the associated file descriptor is written to."]
    #[doc = ""]
    #[doc = " \\param efd File descriptor of the spdk_interrupt."]
    #[doc = " \\param fn Called each time there are events in spdk_interrupt."]
    #[doc = " \\param arg Function argument for fn."]
    #[doc = " \\param name Human readable name for the spdk_interrupt. Pointer of the spdk_interrupt"]
    #[doc = " name is set if NULL."]
    #[doc = ""]
    #[doc = " \\return a pointer to the spdk_interrupt registered on the current thread on success"]
    #[doc = " or NULL on failure."]
    pub fn spdk_interrupt_register(
        efd: ::std::os::raw::c_int,
        fn_: spdk_interrupt_fn,
        arg: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    ) -> *mut spdk_interrupt;
}
extern "C" {
    #[doc = " Unregister an spdk_interrupt on the current thread."]
    #[doc = ""]
    #[doc = " \\param pintr The spdk_interrupt to unregister."]
    pub fn spdk_interrupt_unregister(pintr: *mut *mut spdk_interrupt);
}
pub const spdk_interrupt_event_types_SPDK_INTERRUPT_EVENT_IN: spdk_interrupt_event_types = 1;
pub const spdk_interrupt_event_types_SPDK_INTERRUPT_EVENT_OUT: spdk_interrupt_event_types = 4;
pub const spdk_interrupt_event_types_SPDK_INTERRUPT_EVENT_ET: spdk_interrupt_event_types =
    2147483648;
pub type spdk_interrupt_event_types = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Change the event_types associated with the spdk_interrupt on the current thread."]
    #[doc = ""]
    #[doc = " \\param intr The pointer to the spdk_interrupt registered on the current thread."]
    #[doc = " \\param event_types New event_types for the spdk_interrupt."]
    #[doc = ""]
    #[doc = " \\return 0 if success or -errno if failed."]
    pub fn spdk_interrupt_set_event_types(
        intr: *mut spdk_interrupt,
        event_types: spdk_interrupt_event_types,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a file descriptor that becomes ready whenever any of the registered"]
    #[doc = " interrupt file descriptors are ready"]
    #[doc = ""]
    #[doc = " \\param thread The thread to get."]
    #[doc = ""]
    #[doc = " \\return The spdk_interrupt fd of thread itself."]
    pub fn spdk_thread_get_interrupt_fd(thread: *mut spdk_thread) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set SPDK run as event driven mode"]
    #[doc = ""]
    #[doc = " \\return 0 on success or -errno on failure"]
    pub fn spdk_interrupt_mode_enable() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reports whether interrupt mode is set."]
    #[doc = ""]
    #[doc = " \\return True if interrupt mode is set, false otherwise."]
    pub fn spdk_interrupt_mode_is_enabled() -> bool;
}
#[doc = " Event handler function."]
#[doc = ""]
#[doc = " \\param arg1 Argument 1."]
#[doc = " \\param arg2 Argument 2."]
pub type spdk_event_fn = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_void),
>;
#[doc = " \\brief An event is a function that is passed to and called on an lcore."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_event {
    _unused: [u8; 0],
}
#[doc = " Callback function for customized shutdown handling of application."]
pub type spdk_app_shutdown_cb = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " Signal handler fucntion."]
#[doc = ""]
#[doc = " \\param signal Signal number."]
pub type spdk_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(signal: ::std::os::raw::c_int)>;
#[doc = " \\brief Event framework initialization options"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_app_opts {
    pub name: *const ::std::os::raw::c_char,
    pub json_config_file: *const ::std::os::raw::c_char,
    pub json_config_ignore_errors: bool,
    pub rpc_addr: *const ::std::os::raw::c_char,
    pub reactor_mask: *const ::std::os::raw::c_char,
    pub tpoint_group_mask: *const ::std::os::raw::c_char,
    pub shm_id: ::std::os::raw::c_int,
    pub shutdown_cb: spdk_app_shutdown_cb,
    pub enable_coredump: bool,
    pub mem_channel: ::std::os::raw::c_int,
    pub main_core: ::std::os::raw::c_int,
    pub mem_size: ::std::os::raw::c_int,
    pub no_pci: bool,
    pub hugepage_single_segments: bool,
    pub unlink_hugepage: bool,
    pub hugedir: *const ::std::os::raw::c_char,
    pub print_level: spdk_log_level,
    pub num_pci_addr: size_t,
    pub pci_blocked: *mut spdk_pci_addr,
    pub pci_allowed: *mut spdk_pci_addr,
    pub iova_mode: *const ::std::os::raw::c_char,
    pub delay_subsystem_init: bool,
    pub num_entries: u64,
    #[doc = " Opaque context for use of the env implementation."]
    pub env_context: *mut ::std::os::raw::c_void,
    #[doc = " for passing user-provided log call"]
    pub log: logfunc,
    pub base_virtaddr: u64,
    #[doc = " The size of spdk_app_opts according to the caller of this library is used for ABI"]
    #[doc = " compatibility. The library uses this field to know how many fields in this"]
    #[doc = " structure are valid. And the library will populate any remaining fields with default values."]
    #[doc = " After that, new added fields should be put after opts_size."]
    pub opts_size: size_t,
}
#[test]
fn bindgen_test_layout_spdk_app_opts() {
    assert_eq!(
        ::std::mem::size_of::<spdk_app_opts>(),
        184usize,
        concat!("Size of: ", stringify!(spdk_app_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_app_opts>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_app_opts))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_json_config_file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).json_config_file) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(json_config_file)
            )
        );
    }
    test_field_json_config_file();
    fn test_field_json_config_ignore_errors() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).json_config_ignore_errors) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(json_config_ignore_errors)
            )
        );
    }
    test_field_json_config_ignore_errors();
    fn test_field_rpc_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rpc_addr) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(rpc_addr)
            )
        );
    }
    test_field_rpc_addr();
    fn test_field_reactor_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reactor_mask) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(reactor_mask)
            )
        );
    }
    test_field_reactor_mask();
    fn test_field_tpoint_group_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tpoint_group_mask) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(tpoint_group_mask)
            )
        );
    }
    test_field_tpoint_group_mask();
    fn test_field_shm_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shm_id) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(shm_id)
            )
        );
    }
    test_field_shm_id();
    fn test_field_shutdown_cb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shutdown_cb) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(shutdown_cb)
            )
        );
    }
    test_field_shutdown_cb();
    fn test_field_enable_coredump() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enable_coredump) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(enable_coredump)
            )
        );
    }
    test_field_enable_coredump();
    fn test_field_mem_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mem_channel) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(mem_channel)
            )
        );
    }
    test_field_mem_channel();
    fn test_field_main_core() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).main_core) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(main_core)
            )
        );
    }
    test_field_main_core();
    fn test_field_mem_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mem_size) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(mem_size)
            )
        );
    }
    test_field_mem_size();
    fn test_field_no_pci() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).no_pci) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(no_pci)
            )
        );
    }
    test_field_no_pci();
    fn test_field_hugepage_single_segments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hugepage_single_segments) as usize - ptr as usize
            },
            81usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(hugepage_single_segments)
            )
        );
    }
    test_field_hugepage_single_segments();
    fn test_field_unlink_hugepage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unlink_hugepage) as usize - ptr as usize
            },
            82usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(unlink_hugepage)
            )
        );
    }
    test_field_unlink_hugepage();
    fn test_field_hugedir() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hugedir) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(hugedir)
            )
        );
    }
    test_field_hugedir();
    fn test_field_print_level() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).print_level) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(print_level)
            )
        );
    }
    test_field_print_level();
    fn test_field_num_pci_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_pci_addr) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(num_pci_addr)
            )
        );
    }
    test_field_num_pci_addr();
    fn test_field_pci_blocked() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pci_blocked) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(pci_blocked)
            )
        );
    }
    test_field_pci_blocked();
    fn test_field_pci_allowed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pci_allowed) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(pci_allowed)
            )
        );
    }
    test_field_pci_allowed();
    fn test_field_iova_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iova_mode) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(iova_mode)
            )
        );
    }
    test_field_iova_mode();
    fn test_field_delay_subsystem_init() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).delay_subsystem_init) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(delay_subsystem_init)
            )
        );
    }
    test_field_delay_subsystem_init();
    fn test_field_num_entries() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_entries) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(num_entries)
            )
        );
    }
    test_field_num_entries();
    fn test_field_env_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).env_context) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(env_context)
            )
        );
    }
    test_field_env_context();
    fn test_field_log() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).log) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(log)
            )
        );
    }
    test_field_log();
    fn test_field_base_virtaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base_virtaddr) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(base_virtaddr)
            )
        );
    }
    test_field_base_virtaddr();
    fn test_field_opts_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).opts_size) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(opts_size)
            )
        );
    }
    test_field_opts_size();
}
extern "C" {
    #[doc = " Initialize the default value of opts"]
    #[doc = ""]
    #[doc = " \\param opts Data structure where SPDK will initialize the default options."]
    #[doc = " \\param opts_size Must be set to sizeof(struct spdk_app_opts)."]
    pub fn spdk_app_opts_init(opts: *mut spdk_app_opts, opts_size: size_t);
}
extern "C" {
    #[doc = " Start the framework."]
    #[doc = ""]
    #[doc = " Before calling this function, opts must be initialized by"]
    #[doc = " spdk_app_opts_init(). Once started, the framework will call start_fn on"]
    #[doc = " an spdk_thread running on the current system thread with the"]
    #[doc = " argument provided."]
    #[doc = ""]
    #[doc = " If opts->delay_subsystem_init is set"]
    #[doc = " (e.g. through --wait-for-rpc flag in spdk_app_parse_args())"]
    #[doc = " this function will only start a limited RPC server accepting"]
    #[doc = " only a few RPC commands - mostly related to pre-initialization."]
    #[doc = " With this option, the framework won't be started and start_fn"]
    #[doc = " won't be called until the user sends an `rpc_framework_start_init`"]
    #[doc = " RPC command, which marks the pre-initialization complete and"]
    #[doc = " allows start_fn to be finally called."]
    #[doc = ""]
    #[doc = " This call will block until spdk_app_stop() is called. If an error"]
    #[doc = " condition occurs during the intialization code within spdk_app_start(),"]
    #[doc = " this function will immediately return before invoking start_fn."]
    #[doc = ""]
    #[doc = " \\param opts_user Initialization options used for this application. It should not be"]
    #[doc = "             NULL. And the opts_size value inside the opts structure should not be zero."]
    #[doc = " \\param start_fn Entry point that will execute on an internally created thread"]
    #[doc = "                 once the framework has been started."]
    #[doc = " \\param ctx Argument passed to function start_fn."]
    #[doc = ""]
    #[doc = " \\return 0 on success or non-zero on failure."]
    pub fn spdk_app_start(
        opts_user: *mut spdk_app_opts,
        start_fn: spdk_msg_fn,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Perform final shutdown operations on an application using the event framework."]
    pub fn spdk_app_fini();
}
extern "C" {
    #[doc = " Start shutting down the framework."]
    #[doc = ""]
    #[doc = " Typically this function is not called directly, and the shutdown process is"]
    #[doc = " started implicitly by a process signal. But in applications that are using"]
    #[doc = " SPDK for a subset of its process threads, this function can be called in lieu"]
    #[doc = " of a signal."]
    pub fn spdk_app_start_shutdown();
}
extern "C" {
    #[doc = " Stop the framework."]
    #[doc = ""]
    #[doc = " This does not wait for all threads to exit. Instead, it kicks off the shutdown"]
    #[doc = " process and returns. Once the shutdown process is complete, spdk_app_start()"]
    #[doc = " will return."]
    #[doc = ""]
    #[doc = " \\param rc The rc value specified here will be returned to caller of spdk_app_start()."]
    pub fn spdk_app_stop(rc: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Return the shared memory id for this application."]
    #[doc = ""]
    #[doc = " \\return shared memory id."]
    pub fn spdk_app_get_shm_id() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a string containing a CPU core mask into a bitmask"]
    #[doc = ""]
    #[doc = " \\param mask String containing a CPU core mask."]
    #[doc = " \\param cpumask Bitmask of CPU cores."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on failure."]
    pub fn spdk_app_parse_core_mask(
        mask: *const ::std::os::raw::c_char,
        cpumask: *mut spdk_cpuset,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the mask of the CPU cores active for this application"]
    #[doc = ""]
    #[doc = " \\return the bitmask of the active CPU cores."]
    pub fn spdk_app_get_core_mask() -> *const spdk_cpuset;
}
pub const spdk_app_parse_args_rvals_SPDK_APP_PARSE_ARGS_HELP: spdk_app_parse_args_rvals = 0;
pub const spdk_app_parse_args_rvals_SPDK_APP_PARSE_ARGS_SUCCESS: spdk_app_parse_args_rvals = 1;
pub const spdk_app_parse_args_rvals_SPDK_APP_PARSE_ARGS_FAIL: spdk_app_parse_args_rvals = 2;
pub type spdk_app_parse_args_rvals = ::std::os::raw::c_uint;
pub use self::spdk_app_parse_args_rvals as spdk_app_parse_args_rvals_t;
extern "C" {
    #[doc = " Helper function for parsing arguments and printing usage messages."]
    #[doc = ""]
    #[doc = " \\param argc Count of arguments in argv parameter array."]
    #[doc = " \\param argv Array of command line arguments."]
    #[doc = " \\param opts Default options for the application."]
    #[doc = " \\param getopt_str String representing the app-specific command line parameters."]
    #[doc = " Characters in this string must not conflict with characters in SPDK_APP_GETOPT_STRING."]
    #[doc = " \\param app_long_opts Array of full-name parameters. Can be NULL."]
    #[doc = " \\param parse Function pointer to call if an argument in getopt_str is found."]
    #[doc = " \\param usage Function pointer to print usage messages for app-specific command"]
    #[doc = "\t\tline parameters."]
    #[doc = "\\return SPDK_APP_PARSE_ARGS_FAIL on failure, SPDK_APP_PARSE_ARGS_SUCCESS on"]
    #[doc = "        success, SPDK_APP_PARSE_ARGS_HELP if '-h' passed as an option."]
    pub fn spdk_app_parse_args(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        opts: *mut spdk_app_opts,
        getopt_str: *const ::std::os::raw::c_char,
        app_long_opts: *mut option,
        parse: ::std::option::Option<
            unsafe extern "C" fn(
                ch: ::std::os::raw::c_int,
                arg: *mut ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int,
        >,
        usage: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> spdk_app_parse_args_rvals_t;
}
extern "C" {
    #[doc = " Print usage strings for common SPDK command line options."]
    #[doc = ""]
    #[doc = " May only be called after spdk_app_parse_args()."]
    pub fn spdk_app_usage();
}
extern "C" {
    #[doc = " Allocate an event to be passed to spdk_event_call()."]
    #[doc = ""]
    #[doc = " \\param lcore Lcore to run this event."]
    #[doc = " \\param fn Function used to execute event."]
    #[doc = " \\param arg1 Argument passed to function fn."]
    #[doc = " \\param arg2 Argument passed to function fn."]
    #[doc = ""]
    #[doc = " \\return a pointer to the allocated event."]
    pub fn spdk_event_allocate(
        lcore: u32,
        fn_: spdk_event_fn,
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut spdk_event;
}
extern "C" {
    #[doc = " Pass the given event to the associated lcore and call the function."]
    #[doc = ""]
    #[doc = " \\param event Event to execute."]
    pub fn spdk_event_call(event: *mut spdk_event);
}
extern "C" {
    #[doc = " Enable or disable monitoring of context switches."]
    #[doc = ""]
    #[doc = " \\param enabled True to enable, false to disable."]
    pub fn spdk_framework_enable_context_switch_monitor(enabled: bool);
}
extern "C" {
    #[doc = " Return whether context switch monitoring is enabled."]
    #[doc = ""]
    #[doc = " \\return true if enabled or false otherwise."]
    pub fn spdk_framework_context_switch_monitor_enabled() -> bool;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
pub type __uint128_t = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigacts {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnode {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct re_guts {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_device {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_pci_addr {
    pub _address: u8,
}
